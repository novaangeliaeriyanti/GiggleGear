module.exports = {

"[project]/node_modules/enhanced-resolve/lib/getPaths.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ /**
 * @param {string} path path
 * @returns {{paths: string[], segments: string[]}}} paths and segments
 */ module.exports = function getPaths(path) {
    if (path === "/") return {
        paths: [
            "/"
        ],
        segments: [
            ""
        ]
    };
    const parts = path.split(/(.*?[\\/]+)/);
    const paths = [
        path
    ];
    const segments = [
        parts[parts.length - 1]
    ];
    let part = parts[parts.length - 1];
    path = path.slice(0, Math.max(0, path.length - part.length - 1));
    for(let i = parts.length - 2; i > 2; i -= 2){
        paths.push(path);
        part = parts[i];
        path = path.slice(0, Math.max(0, path.length - part.length)) || "/";
        segments.push(part.slice(0, -1));
    }
    [, part] = parts;
    segments.push(part);
    paths.push(part);
    return {
        paths,
        segments
    };
};
/**
 * @param {string} path path
 * @returns {string|null} basename or null
 */ module.exports.basename = function basename(path) {
    const i = path.lastIndexOf("/");
    const j = path.lastIndexOf("\\");
    const resolvedPath = i < 0 ? j : j < 0 ? i : i < j ? j : i;
    if (resolvedPath < 0) return null;
    const basename = path.slice(resolvedPath + 1);
    return basename;
};
}}),
"[project]/node_modules/enhanced-resolve/lib/CloneBasenamePlugin.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const { basename } = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/getPaths.js [postcss] (ecmascript)");
/** @typedef {import("./Resolver")} Resolver */ /** @typedef {import("./Resolver").ResolveRequest} ResolveRequest */ /** @typedef {import("./Resolver").ResolveStepHook} ResolveStepHook */ module.exports = class CloneBasenamePlugin {
    /**
	 * @param {string | ResolveStepHook} source source
	 * @param {string | ResolveStepHook} target target
	 */ constructor(source, target){
        this.source = source;
        this.target = target;
    }
    /**
	 * @param {Resolver} resolver the resolver
	 * @returns {void}
	 */ apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("CloneBasenamePlugin", (request, resolveContext, callback)=>{
            const requestPath = request.path;
            const filename = basename(requestPath);
            const filePath = resolver.join(requestPath, filename);
            /** @type {ResolveRequest} */ const obj = {
                ...request,
                path: filePath,
                relativePath: request.relativePath && resolver.join(request.relativePath, filename)
            };
            resolver.doResolve(target, obj, `using path: ${filePath}`, resolveContext, callback);
        });
    }
};
}}),
"[project]/node_modules/enhanced-resolve/lib/LogInfoPlugin.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ /** @typedef {import("./Resolver")} Resolver */ /** @typedef {import("./Resolver").ResolveStepHook} ResolveStepHook */ module.exports = class LogInfoPlugin {
    /**
	 * @param {string | ResolveStepHook} source source
	 */ constructor(source){
        this.source = source;
    }
    /**
	 * @param {Resolver} resolver the resolver
	 * @returns {void}
	 */ apply(resolver) {
        const { source } = this;
        resolver.getHook(this.source).tapAsync("LogInfoPlugin", (request, resolveContext, callback)=>{
            if (!resolveContext.log) return callback();
            const { log } = resolveContext;
            const prefix = `[${source}] `;
            if (request.path) {
                log(`${prefix}Resolving in directory: ${request.path}`);
            }
            if (request.request) {
                log(`${prefix}Resolving request: ${request.request}`);
            }
            if (request.module) log(`${prefix}Request is an module request.`);
            if (request.directory) log(`${prefix}Request is a directory request.`);
            if (request.query) {
                log(`${prefix}Resolving request query: ${request.query}`);
            }
            if (request.fragment) {
                log(`${prefix}Resolving request fragment: ${request.fragment}`);
            }
            if (request.descriptionFilePath) {
                log(`${prefix}Has description data from ${request.descriptionFilePath}`);
            }
            if (request.relativePath) {
                log(`${prefix}Relative path from description file is: ${request.relativePath}`);
            }
            callback();
        });
    }
};
}}),
"[project]/node_modules/enhanced-resolve/lib/forEachBail.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ /** @typedef {import("./Resolver").ResolveRequest} ResolveRequest */ /**
 * @template T
 * @template Z
 * @callback Iterator
 * @param {T} item item
 * @param {(err?: null|Error, result?: null|Z) => void} callback callback
 * @param {number} i index
 * @returns {void}
 */ /**
 * @template T
 * @template Z
 * @param {T[]} array array
 * @param {Iterator<T, Z>} iterator iterator
 * @param {(err?: null|Error, result?: null|Z, i?: number) => void} callback callback after all items are iterated
 * @returns {void}
 */ module.exports = function forEachBail(array, iterator, callback) {
    if (array.length === 0) return callback();
    let i = 0;
    const next = ()=>{
        /** @type {boolean|undefined} */ let loop;
        iterator(array[i++], (err, result)=>{
            if (err || result !== undefined || i >= array.length) {
                return callback(err, result, i);
            }
            if (loop === false) while(next());
            loop = true;
        }, i);
        if (!loop) loop = false;
        return loop;
    };
    while(next());
};
}}),
"[project]/node_modules/enhanced-resolve/lib/util/memoize.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ /**
 * @template T
 * @typedef {() => T} FunctionReturning
 */ /**
 * @template T
 * @param {FunctionReturning<T>} fn memorized function
 * @returns {FunctionReturning<T>} new function
 */ const memoize = (fn)=>{
    let cache = false;
    /** @type {T | undefined} */ let result;
    return ()=>{
        if (cache) {
            return result;
        }
        result = fn();
        cache = true;
        // Allow to clean up memory for fn
        // and all dependent resources
        /** @type {FunctionReturning<T> | undefined} */ fn = undefined;
        return result;
    };
};
module.exports = memoize;
}}),
"[project]/node_modules/enhanced-resolve/lib/CachedInputFileSystem.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ // eslint-disable-next-line n/prefer-global/process
const { nextTick } = __turbopack_context__.r("[externals]/process [external] (process, cjs)");
/** @typedef {import("./Resolver").FileSystem} FileSystem */ /** @typedef {import("./Resolver").PathLike} PathLike */ /** @typedef {import("./Resolver").PathOrFileDescriptor} PathOrFileDescriptor */ /** @typedef {import("./Resolver").SyncFileSystem} SyncFileSystem */ /** @typedef {FileSystem & SyncFileSystem} BaseFileSystem */ /**
 * @template T
 * @typedef {import("./Resolver").FileSystemCallback<T>} FileSystemCallback<T>
 */ /**
 * @param {string} path path
 * @returns {string} dirname
 */ const dirname = (path)=>{
    let idx = path.length - 1;
    while(idx >= 0){
        const char = path.charCodeAt(idx);
        // slash or backslash
        if (char === 47 || char === 92) break;
        idx--;
    }
    if (idx < 0) return "";
    return path.slice(0, idx);
};
/**
 * @template T
 * @param {FileSystemCallback<T>[]} callbacks callbacks
 * @param {Error | null} err error
 * @param {T} result result
 */ const runCallbacks = (callbacks, err, result)=>{
    if (callbacks.length === 1) {
        callbacks[0](err, result);
        callbacks.length = 0;
        return;
    }
    let error;
    for (const callback of callbacks){
        try {
            callback(err, result);
        } catch (err) {
            if (!error) error = err;
        }
    }
    callbacks.length = 0;
    if (error) throw error;
};
// eslint-disable-next-line jsdoc/no-restricted-syntax
/** @typedef {Function} EXPECTED_FUNCTION */ // eslint-disable-next-line jsdoc/no-restricted-syntax
/** @typedef {any} EXPECTED_ANY */ class OperationMergerBackend {
    /**
	 * @param {EXPECTED_FUNCTION | undefined} provider async method in filesystem
	 * @param {EXPECTED_FUNCTION | undefined} syncProvider sync method in filesystem
	 * @param {BaseFileSystem} providerContext call context for the provider methods
	 */ constructor(provider, syncProvider, providerContext){
        this._provider = provider;
        this._syncProvider = syncProvider;
        this._providerContext = providerContext;
        this._activeAsyncOperations = new Map();
        this.provide = this._provider ? /**
				 * @param {PathLike | PathOrFileDescriptor} path path
				 * @param {object | FileSystemCallback<EXPECTED_ANY> | undefined} options options
				 * @param {FileSystemCallback<EXPECTED_ANY>=} callback callback
				 * @returns {EXPECTED_ANY} result
				 */ (path, options, callback)=>{
            if (typeof options === "function") {
                callback = options;
                options = undefined;
            }
            if (typeof path !== "string" && !Buffer.isBuffer(path) && !(path instanceof URL) && typeof path !== "number") {
                /** @type {EXPECTED_FUNCTION} */ callback(new TypeError("path must be a string, Buffer, URL or number"));
                return;
            }
            if (options) {
                return /** @type {EXPECTED_FUNCTION} */ this._provider.call(this._providerContext, path, options, callback);
            }
            let callbacks = this._activeAsyncOperations.get(path);
            if (callbacks) {
                callbacks.push(callback);
                return;
            }
            this._activeAsyncOperations.set(path, callbacks = [
                callback
            ]);
            /** @type {EXPECTED_FUNCTION} */ provider(path, /**
						 * @param {Error} err error
						 * @param {EXPECTED_ANY} result result
						 */ (err, result)=>{
                this._activeAsyncOperations.delete(path);
                runCallbacks(callbacks, err, result);
            });
        } : null;
        this.provideSync = this._syncProvider ? /**
				 * @param {PathLike | PathOrFileDescriptor} path path
				 * @param {object=} options options
				 * @returns {EXPECTED_ANY} result
				 */ (path, options)=>/** @type {EXPECTED_FUNCTION} */ this._syncProvider.call(this._providerContext, path, options) : null;
    }
    purge() {}
    purgeParent() {}
}
/*

IDLE:
	insert data: goto SYNC

SYNC:
	before provide: run ticks
	event loop tick: goto ASYNC_ACTIVE

ASYNC:
	timeout: run tick, goto ASYNC_PASSIVE

ASYNC_PASSIVE:
	before provide: run ticks

IDLE --[insert data]--> SYNC --[event loop tick]--> ASYNC_ACTIVE --[interval tick]-> ASYNC_PASSIVE
                                                          ^                             |
                                                          +---------[insert data]-------+
*/ const STORAGE_MODE_IDLE = 0;
const STORAGE_MODE_SYNC = 1;
const STORAGE_MODE_ASYNC = 2;
/**
 * @callback Provide
 * @param {PathLike | PathOrFileDescriptor} path path
 * @param {EXPECTED_ANY} options options
 * @param {FileSystemCallback<EXPECTED_ANY>} callback callback
 * @returns {void}
 */ class CacheBackend {
    /**
	 * @param {number} duration max cache duration of items
	 * @param {EXPECTED_FUNCTION | undefined} provider async method
	 * @param {EXPECTED_FUNCTION | undefined} syncProvider sync method
	 * @param {BaseFileSystem} providerContext call context for the provider methods
	 */ constructor(duration, provider, syncProvider, providerContext){
        this._duration = duration;
        this._provider = provider;
        this._syncProvider = syncProvider;
        this._providerContext = providerContext;
        /** @type {Map<string, FileSystemCallback<EXPECTED_ANY>[]>} */ this._activeAsyncOperations = new Map();
        /** @type {Map<string, { err: Error | null, result?: EXPECTED_ANY, level: Set<string> }>} */ this._data = new Map();
        /** @type {Set<string>[]} */ this._levels = [];
        for(let i = 0; i < 10; i++)this._levels.push(new Set());
        for(let i = 5000; i < duration; i += 500)this._levels.push(new Set());
        this._currentLevel = 0;
        this._tickInterval = Math.floor(duration / this._levels.length);
        /** @type {STORAGE_MODE_IDLE | STORAGE_MODE_SYNC | STORAGE_MODE_ASYNC} */ this._mode = STORAGE_MODE_IDLE;
        /** @type {NodeJS.Timeout | undefined} */ this._timeout = undefined;
        /** @type {number | undefined} */ this._nextDecay = undefined;
        // eslint-disable-next-line no-warning-comments
        // @ts-ignore
        this.provide = provider ? this.provide.bind(this) : null;
        // eslint-disable-next-line no-warning-comments
        // @ts-ignore
        this.provideSync = syncProvider ? this.provideSync.bind(this) : null;
    }
    /**
	 * @param {PathLike | PathOrFileDescriptor} path path
	 * @param {EXPECTED_ANY} options options
	 * @param {FileSystemCallback<EXPECTED_ANY>} callback callback
	 * @returns {void}
	 */ provide(path, options, callback) {
        if (typeof options === "function") {
            callback = options;
            options = undefined;
        }
        if (typeof path !== "string" && !Buffer.isBuffer(path) && !(path instanceof URL) && typeof path !== "number") {
            callback(new TypeError("path must be a string, Buffer, URL or number"));
            return;
        }
        const strPath = typeof path !== "string" ? path.toString() : path;
        if (options) {
            return /** @type {EXPECTED_FUNCTION} */ this._provider.call(this._providerContext, path, options, callback);
        }
        // When in sync mode we can move to async mode
        if (this._mode === STORAGE_MODE_SYNC) {
            this._enterAsyncMode();
        }
        // Check in cache
        const cacheEntry = this._data.get(strPath);
        if (cacheEntry !== undefined) {
            if (cacheEntry.err) return nextTick(callback, cacheEntry.err);
            return nextTick(callback, null, cacheEntry.result);
        }
        // Check if there is already the same operation running
        let callbacks = this._activeAsyncOperations.get(strPath);
        if (callbacks !== undefined) {
            callbacks.push(callback);
            return;
        }
        this._activeAsyncOperations.set(strPath, callbacks = [
            callback
        ]);
        // Run the operation
        /** @type {EXPECTED_FUNCTION} */ this._provider.call(this._providerContext, path, /**
			 * @param {Error | null} err error
			 * @param {EXPECTED_ANY=} result result
			 */ (err, result)=>{
            this._activeAsyncOperations.delete(strPath);
            this._storeResult(strPath, err, result);
            // Enter async mode if not yet done
            this._enterAsyncMode();
            runCallbacks(callbacks, err, result);
        });
    }
    /**
	 * @param {PathLike | PathOrFileDescriptor} path path
	 * @param {EXPECTED_ANY} options options
	 * @returns {EXPECTED_ANY} result
	 */ provideSync(path, options) {
        if (typeof path !== "string" && !Buffer.isBuffer(path) && !(path instanceof URL) && typeof path !== "number") {
            throw new TypeError("path must be a string");
        }
        const strPath = typeof path !== "string" ? path.toString() : path;
        if (options) {
            return /** @type {EXPECTED_FUNCTION} */ this._syncProvider.call(this._providerContext, path, options);
        }
        // In sync mode we may have to decay some cache items
        if (this._mode === STORAGE_MODE_SYNC) {
            this._runDecays();
        }
        // Check in cache
        const cacheEntry = this._data.get(strPath);
        if (cacheEntry !== undefined) {
            if (cacheEntry.err) throw cacheEntry.err;
            return cacheEntry.result;
        }
        // Get all active async operations
        // This sync operation will also complete them
        const callbacks = this._activeAsyncOperations.get(strPath);
        this._activeAsyncOperations.delete(strPath);
        // Run the operation
        // When in idle mode, we will enter sync mode
        let result;
        try {
            result = /** @type {EXPECTED_FUNCTION} */ this._syncProvider.call(this._providerContext, path);
        } catch (err) {
            this._storeResult(strPath, err, undefined);
            this._enterSyncModeWhenIdle();
            if (callbacks) {
                runCallbacks(callbacks, err, undefined);
            }
            throw err;
        }
        this._storeResult(strPath, null, result);
        this._enterSyncModeWhenIdle();
        if (callbacks) {
            runCallbacks(callbacks, null, result);
        }
        return result;
    }
    /**
	 * @param {(string | Buffer | URL | number | (string | URL | Buffer | number)[] | Set<string | URL | Buffer | number>)=} what what to purge
	 */ purge(what) {
        if (!what) {
            if (this._mode !== STORAGE_MODE_IDLE) {
                this._data.clear();
                for (const level of this._levels){
                    level.clear();
                }
                this._enterIdleMode();
            }
        } else if (typeof what === "string" || Buffer.isBuffer(what) || what instanceof URL || typeof what === "number") {
            const strWhat = typeof what !== "string" ? what.toString() : what;
            for (const [key, data] of this._data){
                if (key.startsWith(strWhat)) {
                    this._data.delete(key);
                    data.level.delete(key);
                }
            }
            if (this._data.size === 0) {
                this._enterIdleMode();
            }
        } else {
            for (const [key, data] of this._data){
                for (const item of what){
                    const strItem = typeof item !== "string" ? item.toString() : item;
                    if (key.startsWith(strItem)) {
                        this._data.delete(key);
                        data.level.delete(key);
                        break;
                    }
                }
            }
            if (this._data.size === 0) {
                this._enterIdleMode();
            }
        }
    }
    /**
	 * @param {(string | Buffer | URL | number | (string | URL | Buffer | number)[] | Set<string | URL | Buffer | number>)=} what what to purge
	 */ purgeParent(what) {
        if (!what) {
            this.purge();
        } else if (typeof what === "string" || Buffer.isBuffer(what) || what instanceof URL || typeof what === "number") {
            const strWhat = typeof what !== "string" ? what.toString() : what;
            this.purge(dirname(strWhat));
        } else {
            const set = new Set();
            for (const item of what){
                const strItem = typeof item !== "string" ? item.toString() : item;
                set.add(dirname(strItem));
            }
            this.purge(set);
        }
    }
    /**
	 * @param {string} path path
	 * @param {Error | null} err error
	 * @param {EXPECTED_ANY} result result
	 */ _storeResult(path, err, result) {
        if (this._data.has(path)) return;
        const level = this._levels[this._currentLevel];
        this._data.set(path, {
            err,
            result,
            level
        });
        level.add(path);
    }
    _decayLevel() {
        const nextLevel = (this._currentLevel + 1) % this._levels.length;
        const decay = this._levels[nextLevel];
        this._currentLevel = nextLevel;
        for (const item of decay){
            this._data.delete(item);
        }
        decay.clear();
        if (this._data.size === 0) {
            this._enterIdleMode();
        } else {
            /** @type {number} */ this._nextDecay += this._tickInterval;
        }
    }
    _runDecays() {
        while(/** @type {number} */ this._nextDecay <= Date.now() && this._mode !== STORAGE_MODE_IDLE){
            this._decayLevel();
        }
    }
    _enterAsyncMode() {
        let timeout = 0;
        switch(this._mode){
            case STORAGE_MODE_ASYNC:
                return;
            case STORAGE_MODE_IDLE:
                this._nextDecay = Date.now() + this._tickInterval;
                timeout = this._tickInterval;
                break;
            case STORAGE_MODE_SYNC:
                this._runDecays();
                // _runDecays may change the mode
                if (/** @type {STORAGE_MODE_IDLE | STORAGE_MODE_SYNC | STORAGE_MODE_ASYNC} */ this._mode === STORAGE_MODE_IDLE) {
                    return;
                }
                timeout = Math.max(0, /** @type {number} */ this._nextDecay - Date.now());
                break;
        }
        this._mode = STORAGE_MODE_ASYNC;
        const ref = setTimeout(()=>{
            this._mode = STORAGE_MODE_SYNC;
            this._runDecays();
        }, timeout);
        if (ref.unref) ref.unref();
        this._timeout = ref;
    }
    _enterSyncModeWhenIdle() {
        if (this._mode === STORAGE_MODE_IDLE) {
            this._mode = STORAGE_MODE_SYNC;
            this._nextDecay = Date.now() + this._tickInterval;
        }
    }
    _enterIdleMode() {
        this._mode = STORAGE_MODE_IDLE;
        this._nextDecay = undefined;
        if (this._timeout) clearTimeout(this._timeout);
    }
}
/**
 * @template {EXPECTED_FUNCTION} Provider
 * @template {EXPECTED_FUNCTION} AsyncProvider
 * @template FileSystem
 * @param {number} duration duration in ms files are cached
 * @param {Provider | undefined} provider provider
 * @param {AsyncProvider | undefined} syncProvider sync provider
 * @param {BaseFileSystem} providerContext provider context
 * @returns {OperationMergerBackend | CacheBackend} backend
 */ const createBackend = (duration, provider, syncProvider, providerContext)=>{
    if (duration > 0) {
        return new CacheBackend(duration, provider, syncProvider, providerContext);
    }
    return new OperationMergerBackend(provider, syncProvider, providerContext);
};
module.exports = class CachedInputFileSystem {
    /**
	 * @param {BaseFileSystem} fileSystem file system
	 * @param {number} duration duration in ms files are cached
	 */ constructor(fileSystem, duration){
        this.fileSystem = fileSystem;
        this._lstatBackend = createBackend(duration, this.fileSystem.lstat, this.fileSystem.lstatSync, this.fileSystem);
        const lstat = this._lstatBackend.provide;
        this.lstat = lstat;
        const lstatSync = this._lstatBackend.provideSync;
        this.lstatSync = lstatSync;
        this._statBackend = createBackend(duration, this.fileSystem.stat, this.fileSystem.statSync, this.fileSystem);
        const stat = this._statBackend.provide;
        this.stat = stat;
        const statSync = this._statBackend.provideSync;
        this.statSync = statSync;
        this._readdirBackend = createBackend(duration, this.fileSystem.readdir, this.fileSystem.readdirSync, this.fileSystem);
        const readdir = this._readdirBackend.provide;
        this.readdir = readdir;
        const readdirSync = this._readdirBackend.provideSync;
        this.readdirSync = readdirSync;
        this._readFileBackend = createBackend(duration, this.fileSystem.readFile, this.fileSystem.readFileSync, this.fileSystem);
        const readFile = this._readFileBackend.provide;
        this.readFile = readFile;
        const readFileSync = this._readFileBackend.provideSync;
        this.readFileSync = readFileSync;
        this._readJsonBackend = createBackend(duration, // prettier-ignore
        this.fileSystem.readJson || this.readFile && (/**
						 * @param {string} path path
						 * @param {FileSystemCallback<EXPECTED_ANY>} callback callback
						 */ (path, callback)=>{
            this.readFile(path, (err, buffer)=>{
                if (err) return callback(err);
                if (!buffer || buffer.length === 0) {
                    return callback(new Error("No file content"));
                }
                let data;
                try {
                    data = JSON.parse(buffer.toString("utf8"));
                } catch (err_) {
                    return callback(err_);
                }
                callback(null, data);
            });
        }), // prettier-ignore
        this.fileSystem.readJsonSync || this.readFileSync && (/**
						 * @param {string} path path
						 * @returns {EXPECTED_ANY} result
						 */ (path)=>{
            const buffer = this.readFileSync(path);
            const data = JSON.parse(buffer.toString("utf8"));
            return data;
        }), this.fileSystem);
        const readJson = this._readJsonBackend.provide;
        this.readJson = readJson;
        const readJsonSync = this._readJsonBackend.provideSync;
        this.readJsonSync = readJsonSync;
        this._readlinkBackend = createBackend(duration, this.fileSystem.readlink, this.fileSystem.readlinkSync, this.fileSystem);
        const readlink = this._readlinkBackend.provide;
        this.readlink = readlink;
        const readlinkSync = this._readlinkBackend.provideSync;
        this.readlinkSync = readlinkSync;
        this._realpathBackend = createBackend(duration, this.fileSystem.realpath, this.fileSystem.realpathSync, this.fileSystem);
        const realpath = this._realpathBackend.provide;
        this.realpath = realpath;
        const realpathSync = this._realpathBackend.provideSync;
        this.realpathSync = realpathSync;
    }
    /**
	 * @param {(string | Buffer | URL | number | (string | URL | Buffer | number)[] | Set<string | URL | Buffer | number>)=} what what to purge
	 */ purge(what) {
        this._statBackend.purge(what);
        this._lstatBackend.purge(what);
        this._readdirBackend.purgeParent(what);
        this._readFileBackend.purge(what);
        this._readlinkBackend.purge(what);
        this._readJsonBackend.purge(what);
        this._realpathBackend.purge(what);
    }
};
}}),
"[project]/node_modules/enhanced-resolve/lib/DescriptionFileUtils.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const forEachBail = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/forEachBail.js [postcss] (ecmascript)");
/** @typedef {import("./Resolver")} Resolver */ /** @typedef {import("./Resolver").JsonObject} JsonObject */ /** @typedef {import("./Resolver").JsonValue} JsonValue */ /** @typedef {import("./Resolver").ResolveContext} ResolveContext */ /** @typedef {import("./Resolver").ResolveRequest} ResolveRequest */ /**
 * @typedef {object} DescriptionFileInfo
 * @property {JsonObject=} content content
 * @property {string} path path
 * @property {string} directory directory
 */ /**
 * @callback ErrorFirstCallback
 * @param {Error|null=} error
 * @param {DescriptionFileInfo=} result
 */ /**
 * @typedef {object} Result
 * @property {string} path path to description file
 * @property {string} directory directory of description file
 * @property {JsonObject} content content of description file
 */ /**
 * @param {string} directory directory
 * @returns {string|null} parent directory or null
 */ function cdUp(directory) {
    if (directory === "/") return null;
    const i = directory.lastIndexOf("/");
    const j = directory.lastIndexOf("\\");
    const path = i < 0 ? j : j < 0 ? i : i < j ? j : i;
    if (path < 0) return null;
    return directory.slice(0, path || 1);
}
/**
 * @param {Resolver} resolver resolver
 * @param {string} directory directory
 * @param {string[]} filenames filenames
 * @param {DescriptionFileInfo|undefined} oldInfo oldInfo
 * @param {ResolveContext} resolveContext resolveContext
 * @param {ErrorFirstCallback} callback callback
 */ function loadDescriptionFile(resolver, directory, filenames, oldInfo, resolveContext, callback) {
    (function findDescriptionFile() {
        if (oldInfo && oldInfo.directory === directory) {
            // We already have info for this directory and can reuse it
            return callback(null, oldInfo);
        }
        forEachBail(filenames, /**
			 * @param {string} filename filename
			 * @param {(err?: null|Error, result?: null|Result) => void} callback callback
			 * @returns {void}
			 */ (filename, callback)=>{
            const descriptionFilePath = resolver.join(directory, filename);
            /**
				 * @param {(null | Error)=} err error
				 * @param {JsonObject=} resolvedContent content
				 * @returns {void}
				 */ function onJson(err, resolvedContent) {
                if (err) {
                    if (resolveContext.log) {
                        resolveContext.log(`${descriptionFilePath} (directory description file): ${err}`);
                    } else {
                        err.message = `${descriptionFilePath} (directory description file): ${err}`;
                    }
                    return callback(err);
                }
                callback(null, {
                    content: resolvedContent,
                    directory,
                    path: descriptionFilePath
                });
            }
            if (resolver.fileSystem.readJson) {
                resolver.fileSystem.readJson(descriptionFilePath, (err, content)=>{
                    if (err) {
                        if (typeof /** @type {NodeJS.ErrnoException} */ err.code !== "undefined") {
                            if (resolveContext.missingDependencies) {
                                resolveContext.missingDependencies.add(descriptionFilePath);
                            }
                            return callback();
                        }
                        if (resolveContext.fileDependencies) {
                            resolveContext.fileDependencies.add(descriptionFilePath);
                        }
                        return onJson(err);
                    }
                    if (resolveContext.fileDependencies) {
                        resolveContext.fileDependencies.add(descriptionFilePath);
                    }
                    onJson(null, content);
                });
            } else {
                resolver.fileSystem.readFile(descriptionFilePath, (err, content)=>{
                    if (err) {
                        if (resolveContext.missingDependencies) {
                            resolveContext.missingDependencies.add(descriptionFilePath);
                        }
                        return callback();
                    }
                    if (resolveContext.fileDependencies) {
                        resolveContext.fileDependencies.add(descriptionFilePath);
                    }
                    /** @type {JsonObject | undefined} */ let json;
                    if (content) {
                        try {
                            json = JSON.parse(content.toString());
                        } catch (/** @type {unknown} */ err_) {
                            return onJson(err_);
                        }
                    } else {
                        return onJson(new Error("No content in file"));
                    }
                    onJson(null, json);
                });
            }
        }, /**
			 * @param {(null | Error)=} err error
			 * @param {(null | Result)=} result result
			 * @returns {void}
			 */ (err, result)=>{
            if (err) return callback(err);
            if (result) return callback(null, result);
            const dir = cdUp(directory);
            if (!dir) {
                return callback();
            }
            directory = dir;
            return findDescriptionFile();
        });
    })();
}
/**
 * @param {JsonObject} content content
 * @param {string|string[]} field field
 * @returns {JsonValue | undefined} field data
 */ function getField(content, field) {
    if (!content) return undefined;
    if (Array.isArray(field)) {
        /** @type {JsonValue} */ let current = content;
        for(let j = 0; j < field.length; j++){
            if (current === null || typeof current !== "object") {
                current = null;
                break;
            }
            current = /** @type {JsonObject} */ current[field[j]];
        }
        return current;
    }
    return content[field];
}
module.exports.cdUp = cdUp;
module.exports.getField = getField;
module.exports.loadDescriptionFile = loadDescriptionFile;
}}),
"[project]/node_modules/enhanced-resolve/lib/getInnerRequest.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ /** @typedef {import("./Resolver")} Resolver */ /** @typedef {import("./Resolver").ResolveRequest} ResolveRequest */ /**
 * @param {Resolver} resolver resolver
 * @param {ResolveRequest} request string
 * @returns {string} inner request
 */ module.exports = function getInnerRequest(resolver, request) {
    if (typeof request.__innerRequest === "string" && request.__innerRequest_request === request.request && request.__innerRequest_relativePath === request.relativePath) {
        return request.__innerRequest;
    }
    /** @type {string|undefined} */ let innerRequest;
    if (request.request) {
        innerRequest = request.request;
        if (/^\.\.?(?:\/|$)/.test(innerRequest) && request.relativePath) {
            innerRequest = resolver.join(request.relativePath, innerRequest);
        }
    } else {
        innerRequest = request.relativePath;
    }
    // eslint-disable-next-line camelcase
    request.__innerRequest_request = request.request;
    // eslint-disable-next-line camelcase
    request.__innerRequest_relativePath = request.relativePath;
    return request.__innerRequest = innerRequest;
};
}}),
"[project]/node_modules/enhanced-resolve/lib/AliasFieldPlugin.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const DescriptionFileUtils = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/DescriptionFileUtils.js [postcss] (ecmascript)");
const getInnerRequest = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/getInnerRequest.js [postcss] (ecmascript)");
/** @typedef {import("./Resolver")} Resolver */ /** @typedef {import("./Resolver").JsonPrimitive} JsonPrimitive */ /** @typedef {import("./Resolver").ResolveRequest} ResolveRequest */ /** @typedef {import("./Resolver").ResolveStepHook} ResolveStepHook */ module.exports = class AliasFieldPlugin {
    /**
	 * @param {string | ResolveStepHook} source source
	 * @param {string | Array<string>} field field
	 * @param {string | ResolveStepHook} target target
	 */ constructor(source, field, target){
        this.source = source;
        this.field = field;
        this.target = target;
    }
    /**
	 * @param {Resolver} resolver the resolver
	 * @returns {void}
	 */ apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("AliasFieldPlugin", (request, resolveContext, callback)=>{
            if (!request.descriptionFileData) return callback();
            const innerRequest = getInnerRequest(resolver, request);
            if (!innerRequest) return callback();
            const fieldData = DescriptionFileUtils.getField(request.descriptionFileData, this.field);
            if (fieldData === null || typeof fieldData !== "object") {
                if (resolveContext.log) {
                    resolveContext.log(`Field '${this.field}' doesn't contain a valid alias configuration`);
                }
                return callback();
            }
            /** @type {JsonPrimitive | undefined} */ const data = Object.prototype.hasOwnProperty.call(fieldData, innerRequest) ? /** @type {{[Key in string]: JsonPrimitive}} */ fieldData[innerRequest] : innerRequest.startsWith("./") ? /** @type {{[Key in string]: JsonPrimitive}} */ fieldData[innerRequest.slice(2)] : undefined;
            if (data === innerRequest) return callback();
            if (data === undefined) return callback();
            if (data === false) {
                /** @type {ResolveRequest} */ const ignoreObj = {
                    ...request,
                    path: false
                };
                if (typeof resolveContext.yield === "function") {
                    resolveContext.yield(ignoreObj);
                    return callback(null, null);
                }
                return callback(null, ignoreObj);
            }
            /** @type {ResolveRequest} */ const obj = {
                ...request,
                path: request.descriptionFileRoot,
                request: data,
                fullySpecified: false
            };
            resolver.doResolve(target, obj, `aliased from description file ${request.descriptionFilePath} with mapping '${innerRequest}' to '${/** @type {string} */ data}'`, resolveContext, (err, result)=>{
                if (err) return callback(err);
                // Don't allow other aliasing or raw request
                if (result === undefined) return callback(null, null);
                callback(null, result);
            });
        });
    }
};
}}),
"[project]/node_modules/enhanced-resolve/lib/util/path.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const CHAR_HASH = "#".charCodeAt(0);
const CHAR_SLASH = "/".charCodeAt(0);
const CHAR_BACKSLASH = "\\".charCodeAt(0);
const CHAR_A = "A".charCodeAt(0);
const CHAR_Z = "Z".charCodeAt(0);
const CHAR_LOWER_A = "a".charCodeAt(0);
const CHAR_LOWER_Z = "z".charCodeAt(0);
const CHAR_DOT = ".".charCodeAt(0);
const CHAR_COLON = ":".charCodeAt(0);
const posixNormalize = path.posix.normalize;
const winNormalize = path.win32.normalize;
/**
 * @enum {number}
 */ const PathType = Object.freeze({
    Empty: 0,
    Normal: 1,
    Relative: 2,
    AbsoluteWin: 3,
    AbsolutePosix: 4,
    Internal: 5
});
const deprecatedInvalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i;
const invalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i;
/**
 * @param {string} maybePath a path
 * @returns {PathType} type of path
 */ const getType = (maybePath)=>{
    switch(maybePath.length){
        case 0:
            return PathType.Empty;
        case 1:
            {
                const c0 = maybePath.charCodeAt(0);
                switch(c0){
                    case CHAR_DOT:
                        return PathType.Relative;
                    case CHAR_SLASH:
                        return PathType.AbsolutePosix;
                    case CHAR_HASH:
                        return PathType.Internal;
                }
                return PathType.Normal;
            }
        case 2:
            {
                const c0 = maybePath.charCodeAt(0);
                switch(c0){
                    case CHAR_DOT:
                        {
                            const c1 = maybePath.charCodeAt(1);
                            switch(c1){
                                case CHAR_DOT:
                                case CHAR_SLASH:
                                    return PathType.Relative;
                            }
                            return PathType.Normal;
                        }
                    case CHAR_SLASH:
                        return PathType.AbsolutePosix;
                    case CHAR_HASH:
                        return PathType.Internal;
                }
                const c1 = maybePath.charCodeAt(1);
                if (c1 === CHAR_COLON && (c0 >= CHAR_A && c0 <= CHAR_Z || c0 >= CHAR_LOWER_A && c0 <= CHAR_LOWER_Z)) {
                    return PathType.AbsoluteWin;
                }
                return PathType.Normal;
            }
    }
    const c0 = maybePath.charCodeAt(0);
    switch(c0){
        case CHAR_DOT:
            {
                const c1 = maybePath.charCodeAt(1);
                switch(c1){
                    case CHAR_SLASH:
                        return PathType.Relative;
                    case CHAR_DOT:
                        {
                            const c2 = maybePath.charCodeAt(2);
                            if (c2 === CHAR_SLASH) return PathType.Relative;
                            return PathType.Normal;
                        }
                }
                return PathType.Normal;
            }
        case CHAR_SLASH:
            return PathType.AbsolutePosix;
        case CHAR_HASH:
            return PathType.Internal;
    }
    const c1 = maybePath.charCodeAt(1);
    if (c1 === CHAR_COLON) {
        const c2 = maybePath.charCodeAt(2);
        if ((c2 === CHAR_BACKSLASH || c2 === CHAR_SLASH) && (c0 >= CHAR_A && c0 <= CHAR_Z || c0 >= CHAR_LOWER_A && c0 <= CHAR_LOWER_Z)) {
            return PathType.AbsoluteWin;
        }
    }
    return PathType.Normal;
};
/**
 * @param {string} maybePath a path
 * @returns {string} the normalized path
 */ const normalize = (maybePath)=>{
    switch(getType(maybePath)){
        case PathType.Empty:
            return maybePath;
        case PathType.AbsoluteWin:
            return winNormalize(maybePath);
        case PathType.Relative:
            {
                const r = posixNormalize(maybePath);
                return getType(r) === PathType.Relative ? r : `./${r}`;
            }
    }
    return posixNormalize(maybePath);
};
/**
 * @param {string} rootPath the root path
 * @param {string | undefined} request the request path
 * @returns {string} the joined path
 */ const join = (rootPath, request)=>{
    if (!request) return normalize(rootPath);
    const requestType = getType(request);
    switch(requestType){
        case PathType.AbsolutePosix:
            return posixNormalize(request);
        case PathType.AbsoluteWin:
            return winNormalize(request);
    }
    switch(getType(rootPath)){
        case PathType.Normal:
        case PathType.Relative:
        case PathType.AbsolutePosix:
            return posixNormalize(`${rootPath}/${request}`);
        case PathType.AbsoluteWin:
            return winNormalize(`${rootPath}\\${request}`);
    }
    switch(requestType){
        case PathType.Empty:
            return rootPath;
        case PathType.Relative:
            {
                const r = posixNormalize(rootPath);
                return getType(r) === PathType.Relative ? r : `./${r}`;
            }
    }
    return posixNormalize(rootPath);
};
/** @type {Map<string, Map<string, string | undefined>>} */ const joinCache = new Map();
/**
 * @param {string} rootPath the root path
 * @param {string} request the request path
 * @returns {string} the joined path
 */ const cachedJoin = (rootPath, request)=>{
    /** @type {string | undefined} */ let cacheEntry;
    let cache = joinCache.get(rootPath);
    if (cache === undefined) {
        joinCache.set(rootPath, cache = new Map());
    } else {
        cacheEntry = cache.get(request);
        if (cacheEntry !== undefined) return cacheEntry;
    }
    cacheEntry = join(rootPath, request);
    cache.set(request, cacheEntry);
    return cacheEntry;
};
module.exports.PathType = PathType;
module.exports.cachedJoin = cachedJoin;
module.exports.deprecatedInvalidSegmentRegEx = deprecatedInvalidSegmentRegEx;
module.exports.getType = getType;
module.exports.invalidSegmentRegEx = invalidSegmentRegEx;
module.exports.join = join;
module.exports.normalize = normalize;
}}),
"[project]/node_modules/enhanced-resolve/lib/AliasPlugin.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const forEachBail = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/forEachBail.js [postcss] (ecmascript)");
const { PathType, getType } = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/util/path.js [postcss] (ecmascript)");
/** @typedef {import("./Resolver")} Resolver */ /** @typedef {import("./Resolver").ResolveRequest} ResolveRequest */ /** @typedef {import("./Resolver").ResolveStepHook} ResolveStepHook */ /** @typedef {string | Array<string> | false} Alias */ /** @typedef {{alias: Alias, name: string, onlyModule?: boolean}} AliasOption */ module.exports = class AliasPlugin {
    /**
	 * @param {string | ResolveStepHook} source source
	 * @param {AliasOption | Array<AliasOption>} options options
	 * @param {string | ResolveStepHook} target target
	 */ constructor(source, options, target){
        this.source = source;
        this.options = Array.isArray(options) ? options : [
            options
        ];
        this.target = target;
    }
    /**
	 * @param {Resolver} resolver the resolver
	 * @returns {void}
	 */ apply(resolver) {
        const target = resolver.ensureHook(this.target);
        /**
		 * @param {string} maybeAbsolutePath path
		 * @returns {null|string} absolute path with slash ending
		 */ const getAbsolutePathWithSlashEnding = (maybeAbsolutePath)=>{
            const type = getType(maybeAbsolutePath);
            if (type === PathType.AbsolutePosix || type === PathType.AbsoluteWin) {
                return resolver.join(maybeAbsolutePath, "_").slice(0, -1);
            }
            return null;
        };
        /**
		 * @param {string} path path
		 * @param {string} maybeSubPath sub path
		 * @returns {boolean} true, if path is sub path
		 */ const isSubPath = (path, maybeSubPath)=>{
            const absolutePath = getAbsolutePathWithSlashEnding(maybeSubPath);
            if (!absolutePath) return false;
            return path.startsWith(absolutePath);
        };
        resolver.getHook(this.source).tapAsync("AliasPlugin", (request, resolveContext, callback)=>{
            const innerRequest = request.request || request.path;
            if (!innerRequest) return callback();
            forEachBail(this.options, (item, callback)=>{
                /** @type {boolean} */ let shouldStop = false;
                const matchRequest = innerRequest === item.name || !item.onlyModule && (request.request ? innerRequest.startsWith(`${item.name}/`) : isSubPath(innerRequest, item.name));
                const splitName = item.name.split("*");
                const matchWildcard = !item.onlyModule && splitName.length === 2;
                if (matchRequest || matchWildcard) {
                    /**
							 * @param {Alias} alias alias
							 * @param {(err?: null|Error, result?: null|ResolveRequest) => void} callback callback
							 * @returns {void}
							 */ const resolveWithAlias = (alias, callback)=>{
                        if (alias === false) {
                            /** @type {ResolveRequest} */ const ignoreObj = {
                                ...request,
                                path: false
                            };
                            if (typeof resolveContext.yield === "function") {
                                resolveContext.yield(ignoreObj);
                                return callback(null, null);
                            }
                            return callback(null, ignoreObj);
                        }
                        let newRequestStr;
                        const [prefix, suffix] = splitName;
                        if (matchWildcard && innerRequest.startsWith(prefix) && innerRequest.endsWith(suffix)) {
                            const match = innerRequest.slice(prefix.length, innerRequest.length - suffix.length);
                            newRequestStr = item.alias.toString().replace("*", match);
                        }
                        if (matchRequest && innerRequest !== alias && !innerRequest.startsWith(`${alias}/`)) {
                            /** @type {string} */ const remainingRequest = innerRequest.slice(item.name.length);
                            newRequestStr = alias + remainingRequest;
                        }
                        if (newRequestStr !== undefined) {
                            shouldStop = true;
                            /** @type {ResolveRequest} */ const obj = {
                                ...request,
                                request: newRequestStr,
                                fullySpecified: false
                            };
                            return resolver.doResolve(target, obj, `aliased with mapping '${item.name}': '${alias}' to '${newRequestStr}'`, resolveContext, (err, result)=>{
                                if (err) return callback(err);
                                if (result) return callback(null, result);
                                return callback();
                            });
                        }
                        return callback();
                    };
                    /**
							 * @param {(null | Error)=} err error
							 * @param {(null | ResolveRequest)=} result result
							 * @returns {void}
							 */ const stoppingCallback = (err, result)=>{
                        if (err) return callback(err);
                        if (result) return callback(null, result);
                        // Don't allow other aliasing or raw request
                        if (shouldStop) return callback(null, null);
                        return callback();
                    };
                    if (Array.isArray(item.alias)) {
                        return forEachBail(item.alias, resolveWithAlias, stoppingCallback);
                    }
                    return resolveWithAlias(item.alias, stoppingCallback);
                }
                return callback();
            }, callback);
        });
    }
};
}}),
"[project]/node_modules/enhanced-resolve/lib/AppendPlugin.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ /** @typedef {import("./Resolver")} Resolver */ /** @typedef {import("./Resolver").ResolveRequest} ResolveRequest */ /** @typedef {import("./Resolver").ResolveStepHook} ResolveStepHook */ module.exports = class AppendPlugin {
    /**
	 * @param {string | ResolveStepHook} source source
	 * @param {string} appending appending
	 * @param {string | ResolveStepHook} target target
	 */ constructor(source, appending, target){
        this.source = source;
        this.appending = appending;
        this.target = target;
    }
    /**
	 * @param {Resolver} resolver the resolver
	 * @returns {void}
	 */ apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("AppendPlugin", (request, resolveContext, callback)=>{
            /** @type {ResolveRequest} */ const obj = {
                ...request,
                path: request.path + this.appending,
                relativePath: request.relativePath && request.relativePath + this.appending
            };
            resolver.doResolve(target, obj, this.appending, resolveContext, callback);
        });
    }
};
}}),
"[project]/node_modules/enhanced-resolve/lib/ConditionalPlugin.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ /** @typedef {import("./Resolver")} Resolver */ /** @typedef {import("./Resolver").ResolveRequest} ResolveRequest */ /** @typedef {import("./Resolver").ResolveStepHook} ResolveStepHook */ module.exports = class ConditionalPlugin {
    /**
	 * @param {string | ResolveStepHook} source source
	 * @param {Partial<ResolveRequest>} test compare object
	 * @param {string | null} message log message
	 * @param {boolean} allowAlternatives when false, do not continue with the current step when "test" matches
	 * @param {string | ResolveStepHook} target target
	 */ constructor(source, test, message, allowAlternatives, target){
        this.source = source;
        this.test = test;
        this.message = message;
        this.allowAlternatives = allowAlternatives;
        this.target = target;
    }
    /**
	 * @param {Resolver} resolver the resolver
	 * @returns {void}
	 */ apply(resolver) {
        const target = resolver.ensureHook(this.target);
        const { test, message, allowAlternatives } = this;
        const keys = Object.keys(test);
        resolver.getHook(this.source).tapAsync("ConditionalPlugin", (request, resolveContext, callback)=>{
            for (const prop of keys){
                if (request[prop] !== test[prop]) return callback();
            }
            resolver.doResolve(target, request, message, resolveContext, allowAlternatives ? callback : (err, result)=>{
                if (err) return callback(err);
                // Don't allow other alternatives
                if (result === undefined) return callback(null, null);
                callback(null, result);
            });
        });
    }
};
}}),
"[project]/node_modules/enhanced-resolve/lib/DescriptionFilePlugin.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const DescriptionFileUtils = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/DescriptionFileUtils.js [postcss] (ecmascript)");
/** @typedef {import("./Resolver")} Resolver */ /** @typedef {import("./Resolver").ResolveRequest} ResolveRequest */ /** @typedef {import("./Resolver").ResolveStepHook} ResolveStepHook */ module.exports = class DescriptionFilePlugin {
    /**
	 * @param {string | ResolveStepHook} source source
	 * @param {string[]} filenames filenames
	 * @param {boolean} pathIsFile pathIsFile
	 * @param {string | ResolveStepHook} target target
	 */ constructor(source, filenames, pathIsFile, target){
        this.source = source;
        this.filenames = filenames;
        this.pathIsFile = pathIsFile;
        this.target = target;
    }
    /**
	 * @param {Resolver} resolver the resolver
	 * @returns {void}
	 */ apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("DescriptionFilePlugin", (request, resolveContext, callback)=>{
            const { path } = request;
            if (!path) return callback();
            const directory = this.pathIsFile ? DescriptionFileUtils.cdUp(path) : path;
            if (!directory) return callback();
            DescriptionFileUtils.loadDescriptionFile(resolver, directory, this.filenames, request.descriptionFilePath ? {
                path: request.descriptionFilePath,
                content: request.descriptionFileData,
                directory: request.descriptionFileRoot
            } : undefined, resolveContext, (err, result)=>{
                if (err) return callback(err);
                if (!result) {
                    if (resolveContext.log) {
                        resolveContext.log(`No description file found in ${directory} or above`);
                    }
                    return callback();
                }
                const relativePath = `.${path.slice(result.directory.length).replace(/\\/g, "/")}`;
                /** @type {ResolveRequest} */ const obj = {
                    ...request,
                    descriptionFilePath: result.path,
                    descriptionFileData: result.content,
                    descriptionFileRoot: result.directory,
                    relativePath
                };
                resolver.doResolve(target, obj, `using description file: ${result.path} (relative path: ${relativePath})`, resolveContext, (err, result)=>{
                    if (err) return callback(err);
                    // Don't allow other processing
                    if (result === undefined) return callback(null, null);
                    callback(null, result);
                });
            });
        });
    }
};
}}),
"[project]/node_modules/enhanced-resolve/lib/DirectoryExistsPlugin.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ /** @typedef {import("./Resolver")} Resolver */ /** @typedef {import("./Resolver").ResolveStepHook} ResolveStepHook */ module.exports = class DirectoryExistsPlugin {
    /**
	 * @param {string | ResolveStepHook} source source
	 * @param {string | ResolveStepHook} target target
	 */ constructor(source, target){
        this.source = source;
        this.target = target;
    }
    /**
	 * @param {Resolver} resolver the resolver
	 * @returns {void}
	 */ apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("DirectoryExistsPlugin", (request, resolveContext, callback)=>{
            const fs = resolver.fileSystem;
            const directory = request.path;
            if (!directory) return callback();
            fs.stat(directory, (err, stat)=>{
                if (err || !stat) {
                    if (resolveContext.missingDependencies) {
                        resolveContext.missingDependencies.add(directory);
                    }
                    if (resolveContext.log) {
                        resolveContext.log(`${directory} doesn't exist`);
                    }
                    return callback();
                }
                if (!stat.isDirectory()) {
                    if (resolveContext.missingDependencies) {
                        resolveContext.missingDependencies.add(directory);
                    }
                    if (resolveContext.log) {
                        resolveContext.log(`${directory} is not a directory`);
                    }
                    return callback();
                }
                if (resolveContext.fileDependencies) {
                    resolveContext.fileDependencies.add(directory);
                }
                resolver.doResolve(target, request, `existing directory ${directory}`, resolveContext, callback);
            });
        });
    }
};
}}),
"[project]/node_modules/enhanced-resolve/lib/util/identifier.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Ivan Kopeykin @vankop
*/ const PATH_QUERY_FRAGMENT_REGEXP = /^(#?(?:\0.|[^?#\0])*)(\?(?:\0.|[^#\0])*)?(#.*)?$/;
const ZERO_ESCAPE_REGEXP = /\0(.)/g;
/**
 * @param {string} identifier identifier
 * @returns {[string, string, string]|null} parsed identifier
 */ function parseIdentifier(identifier) {
    if (!identifier) {
        return null;
    }
    const firstEscape = identifier.indexOf("\0");
    if (firstEscape < 0) {
        // Fast path for inputs that don't use \0 escaping.
        const queryStart = identifier.indexOf("?");
        // Start at index 1 to ignore a possible leading hash.
        const fragmentStart = identifier.indexOf("#", 1);
        if (fragmentStart < 0) {
            if (queryStart < 0) {
                // No fragment, no query
                return [
                    identifier,
                    "",
                    ""
                ];
            }
            // Query, no fragment
            return [
                identifier.slice(0, queryStart),
                identifier.slice(queryStart),
                ""
            ];
        }
        if (queryStart < 0 || fragmentStart < queryStart) {
            // Fragment, no query
            return [
                identifier.slice(0, fragmentStart),
                "",
                identifier.slice(fragmentStart)
            ];
        }
        // Query and fragment
        return [
            identifier.slice(0, queryStart),
            identifier.slice(queryStart, fragmentStart),
            identifier.slice(fragmentStart)
        ];
    }
    const match = PATH_QUERY_FRAGMENT_REGEXP.exec(identifier);
    if (!match) return null;
    return [
        match[1].replace(ZERO_ESCAPE_REGEXP, "$1"),
        match[2] ? match[2].replace(ZERO_ESCAPE_REGEXP, "$1") : "",
        match[3] || ""
    ];
}
module.exports.parseIdentifier = parseIdentifier;
}}),
"[project]/node_modules/enhanced-resolve/lib/util/entrypoints.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Ivan Kopeykin @vankop
*/ const { parseIdentifier } = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/util/identifier.js [postcss] (ecmascript)");
/** @typedef {string|(string|ConditionalMapping)[]} DirectMapping */ /** @typedef {{[k: string]: MappingValue}} ConditionalMapping */ /** @typedef {ConditionalMapping|DirectMapping|null} MappingValue */ /** @typedef {Record<string, MappingValue>|ConditionalMapping|DirectMapping} ExportsField */ /** @typedef {Record<string, MappingValue>} ImportsField */ /**
 * Processing exports/imports field
 * @callback FieldProcessor
 * @param {string} request request
 * @param {Set<string>} conditionNames condition names
 * @returns {[string[], string | null]} resolved paths with used field
 */ /*
Example exports field:
{
  ".": "./main.js",
  "./feature": {
    "browser": "./feature-browser.js",
    "default": "./feature.js"
  }
}
Terminology:

Enhanced-resolve name keys ("." and "./feature") as exports field keys.

If value is string or string[], mapping is called as a direct mapping
and value called as a direct export.

If value is key-value object, mapping is called as a conditional mapping
and value called as a conditional export.

Key in conditional mapping is called condition name.

Conditional mapping nested in another conditional mapping is called nested mapping.

----------

Example imports field:
{
  "#a": "./main.js",
  "#moment": {
    "browser": "./moment/index.js",
    "default": "moment"
  },
  "#moment/": {
    "browser": "./moment/",
    "default": "moment/"
  }
}
Terminology:

Enhanced-resolve name keys ("#a" and "#moment/", "#moment") as imports field keys.

If value is string or string[], mapping is called as a direct mapping
and value called as a direct export.

If value is key-value object, mapping is called as a conditional mapping
and value called as a conditional export.

Key in conditional mapping is called condition name.

Conditional mapping nested in another conditional mapping is called nested mapping.

*/ const slashCode = "/".charCodeAt(0);
const dotCode = ".".charCodeAt(0);
const hashCode = "#".charCodeAt(0);
const patternRegEx = /\*/g;
/**
 * @param {string} a first string
 * @param {string} b second string
 * @returns {number} compare result
 */ function patternKeyCompare(a, b) {
    const aPatternIndex = a.indexOf("*");
    const bPatternIndex = b.indexOf("*");
    const baseLenA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;
    const baseLenB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;
    if (baseLenA > baseLenB) return -1;
    if (baseLenB > baseLenA) return 1;
    if (aPatternIndex === -1) return 1;
    if (bPatternIndex === -1) return -1;
    if (a.length > b.length) return -1;
    if (b.length > a.length) return 1;
    return 0;
}
/**
 * Trying to match request to field
 * @param {string} request request
 * @param {ExportsField | ImportsField} field exports or import field
 * @returns {[MappingValue, string, boolean, boolean, string]|null} match or null, number is negative and one less when it's a folder mapping, number is request.length + 1 for direct mappings
 */ function findMatch(request, field) {
    if (Object.prototype.hasOwnProperty.call(field, request) && !request.includes("*") && !request.endsWith("/")) {
        const target = /** @type {{[k: string]: MappingValue}} */ field[request];
        return [
            target,
            "",
            false,
            false,
            request
        ];
    }
    /** @type {string} */ let bestMatch = "";
    /** @type {string|undefined} */ let bestMatchSubpath;
    const keys = Object.getOwnPropertyNames(field);
    for(let i = 0; i < keys.length; i++){
        const key = keys[i];
        const patternIndex = key.indexOf("*");
        if (patternIndex !== -1 && request.startsWith(key.slice(0, patternIndex))) {
            const patternTrailer = key.slice(patternIndex + 1);
            if (request.length >= key.length && request.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
                bestMatch = key;
                bestMatchSubpath = request.slice(patternIndex, request.length - patternTrailer.length);
            }
        } else if (key[key.length - 1] === "/" && request.startsWith(key) && patternKeyCompare(bestMatch, key) === 1) {
            bestMatch = key;
            bestMatchSubpath = request.slice(key.length);
        }
    }
    if (bestMatch === "") return null;
    const target = /** @type {{[k: string]: MappingValue}} */ field[bestMatch];
    const isSubpathMapping = bestMatch.endsWith("/");
    const isPattern = bestMatch.includes("*");
    return [
        target,
        bestMatchSubpath,
        isSubpathMapping,
        isPattern,
        bestMatch
    ];
}
/**
 * @param {ConditionalMapping | DirectMapping|null} mapping mapping
 * @returns {boolean} is conditional mapping
 */ function isConditionalMapping(mapping) {
    return mapping !== null && typeof mapping === "object" && !Array.isArray(mapping);
}
/**
 * @param {ConditionalMapping} conditionalMapping_ conditional mapping
 * @param {Set<string>} conditionNames condition names
 * @returns {DirectMapping | null} direct mapping if found
 */ function conditionalMapping(conditionalMapping_, conditionNames) {
    /** @type {[ConditionalMapping, string[], number][]} */ const lookup = [
        [
            conditionalMapping_,
            Object.keys(conditionalMapping_),
            0
        ]
    ];
    loop: while(lookup.length > 0){
        const [mapping, conditions, j] = lookup[lookup.length - 1];
        for(let i = j; i < conditions.length; i++){
            const condition = conditions[i];
            if (condition === "default") {
                const innerMapping = mapping[condition];
                // is nested
                if (isConditionalMapping(innerMapping)) {
                    const conditionalMapping = innerMapping;
                    lookup[lookup.length - 1][2] = i + 1;
                    lookup.push([
                        conditionalMapping,
                        Object.keys(conditionalMapping),
                        0
                    ]);
                    continue loop;
                }
                return innerMapping;
            }
            if (conditionNames.has(condition)) {
                const innerMapping = mapping[condition];
                // is nested
                if (isConditionalMapping(innerMapping)) {
                    const conditionalMapping = innerMapping;
                    lookup[lookup.length - 1][2] = i + 1;
                    lookup.push([
                        conditionalMapping,
                        Object.keys(conditionalMapping),
                        0
                    ]);
                    continue loop;
                }
                return innerMapping;
            }
        }
        lookup.pop();
    }
    return null;
}
/**
 * @param {string | undefined} remainingRequest remaining request when folder mapping, undefined for file mappings
 * @param {boolean} isPattern true, if mapping is a pattern (contains "*")
 * @param {boolean} isSubpathMapping true, for subpath mappings
 * @param {string} mappingTarget direct export
 * @param {(d: string, f: boolean) => void} assert asserting direct value
 * @returns {string} mapping result
 */ function targetMapping(remainingRequest, isPattern, isSubpathMapping, mappingTarget, assert) {
    if (remainingRequest === undefined) {
        assert(mappingTarget, false);
        return mappingTarget;
    }
    if (isSubpathMapping) {
        assert(mappingTarget, true);
        return mappingTarget + remainingRequest;
    }
    assert(mappingTarget, false);
    let result = mappingTarget;
    if (isPattern) {
        result = result.replace(patternRegEx, remainingRequest.replace(/\$/g, "$$"));
    }
    return result;
}
/**
 * @param {string|undefined} remainingRequest remaining request when folder mapping, undefined for file mappings
 * @param {boolean} isPattern true, if mapping is a pattern (contains "*")
 * @param {boolean} isSubpathMapping true, for subpath mappings
 * @param {DirectMapping|null} mappingTarget direct export
 * @param {Set<string>} conditionNames condition names
 * @param {(d: string, f: boolean) => void} assert asserting direct value
 * @returns {string[]} mapping result
 */ function directMapping(remainingRequest, isPattern, isSubpathMapping, mappingTarget, conditionNames, assert) {
    if (mappingTarget === null) return [];
    if (typeof mappingTarget === "string") {
        return [
            targetMapping(remainingRequest, isPattern, isSubpathMapping, mappingTarget, assert)
        ];
    }
    /** @type {string[]} */ const targets = [];
    for (const exp of mappingTarget){
        if (typeof exp === "string") {
            targets.push(targetMapping(remainingRequest, isPattern, isSubpathMapping, exp, assert));
            continue;
        }
        const mapping = conditionalMapping(exp, conditionNames);
        if (!mapping) continue;
        const innerExports = directMapping(remainingRequest, isPattern, isSubpathMapping, mapping, conditionNames, assert);
        for (const innerExport of innerExports){
            targets.push(innerExport);
        }
    }
    return targets;
}
/**
 * @param {ExportsField | ImportsField} field root
 * @param {(s: string) => string} normalizeRequest Normalize request, for `imports` field it adds `#`, for `exports` field it adds `.` or `./`
 * @param {(s: string) => string} assertRequest assertRequest
 * @param {(s: string, f: boolean) => void} assertTarget assertTarget
 * @returns {FieldProcessor} field processor
 */ function createFieldProcessor(field, normalizeRequest, assertRequest, assertTarget) {
    return function fieldProcessor(request, conditionNames) {
        request = assertRequest(request);
        const match = findMatch(normalizeRequest(request), field);
        if (match === null) return [
            [],
            null
        ];
        const [mapping, remainingRequest, isSubpathMapping, isPattern, usedField] = match;
        /** @type {DirectMapping | null} */ let direct = null;
        if (isConditionalMapping(mapping)) {
            direct = conditionalMapping(mapping, conditionNames);
            // matching not found
            if (direct === null) return [
                [],
                null
            ];
        } else {
            direct = mapping;
        }
        return [
            directMapping(remainingRequest, isPattern, isSubpathMapping, direct, conditionNames, assertTarget),
            usedField
        ];
    };
}
/**
 * @param {string} request request
 * @returns {string} updated request
 */ function assertExportsFieldRequest(request) {
    if (request.charCodeAt(0) !== dotCode) {
        throw new Error('Request should be relative path and start with "."');
    }
    if (request.length === 1) return "";
    if (request.charCodeAt(1) !== slashCode) {
        throw new Error('Request should be relative path and start with "./"');
    }
    if (request.charCodeAt(request.length - 1) === slashCode) {
        throw new Error("Only requesting file allowed");
    }
    return request.slice(2);
}
/**
 * @param {ExportsField} field exports field
 * @returns {ExportsField} normalized exports field
 */ function buildExportsField(field) {
    // handle syntax sugar, if exports field is direct mapping for "."
    if (typeof field === "string" || Array.isArray(field)) {
        return {
            ".": field
        };
    }
    const keys = Object.keys(field);
    for(let i = 0; i < keys.length; i++){
        const key = keys[i];
        if (key.charCodeAt(0) !== dotCode) {
            // handle syntax sugar, if exports field is conditional mapping for "."
            if (i === 0) {
                while(i < keys.length){
                    const charCode = keys[i].charCodeAt(0);
                    if (charCode === dotCode || charCode === slashCode) {
                        throw new Error(`Exports field key should be relative path and start with "." (key: ${JSON.stringify(key)})`);
                    }
                    i++;
                }
                return {
                    ".": field
                };
            }
            throw new Error(`Exports field key should be relative path and start with "." (key: ${JSON.stringify(key)})`);
        }
        if (key.length === 1) {
            continue;
        }
        if (key.charCodeAt(1) !== slashCode) {
            throw new Error(`Exports field key should be relative path and start with "./" (key: ${JSON.stringify(key)})`);
        }
    }
    return field;
}
/**
 * @param {string} exp export target
 * @param {boolean} expectFolder is folder expected
 */ function assertExportTarget(exp, expectFolder) {
    const parsedIdentifier = parseIdentifier(exp);
    if (!parsedIdentifier) {
        return;
    }
    const [relativePath] = parsedIdentifier;
    const isFolder = relativePath.charCodeAt(relativePath.length - 1) === slashCode;
    if (isFolder !== expectFolder) {
        throw new Error(expectFolder ? `Expecting folder to folder mapping. ${JSON.stringify(exp)} should end with "/"` : `Expecting file to file mapping. ${JSON.stringify(exp)} should not end with "/"`);
    }
}
/**
 * @param {ExportsField} exportsField the exports field
 * @returns {FieldProcessor} process callback
 */ module.exports.processExportsField = function processExportsField(exportsField) {
    return createFieldProcessor(buildExportsField(exportsField), (request)=>request.length === 0 ? "." : `./${request}`, assertExportsFieldRequest, assertExportTarget);
};
/**
 * @param {string} request request
 * @returns {string} updated request
 */ function assertImportsFieldRequest(request) {
    if (request.charCodeAt(0) !== hashCode) {
        throw new Error('Request should start with "#"');
    }
    if (request.length === 1) {
        throw new Error("Request should have at least 2 characters");
    }
    if (request.charCodeAt(1) === slashCode) {
        throw new Error('Request should not start with "#/"');
    }
    if (request.charCodeAt(request.length - 1) === slashCode) {
        throw new Error("Only requesting file allowed");
    }
    return request.slice(1);
}
/**
 * @param {string} imp import target
 * @param {boolean} expectFolder is folder expected
 */ function assertImportTarget(imp, expectFolder) {
    const parsedIdentifier = parseIdentifier(imp);
    if (!parsedIdentifier) {
        return;
    }
    const [relativePath] = parsedIdentifier;
    const isFolder = relativePath.charCodeAt(relativePath.length - 1) === slashCode;
    if (isFolder !== expectFolder) {
        throw new Error(expectFolder ? `Expecting folder to folder mapping. ${JSON.stringify(imp)} should end with "/"` : `Expecting file to file mapping. ${JSON.stringify(imp)} should not end with "/"`);
    }
}
/**
 * @param {ImportsField} importsField the exports field
 * @returns {FieldProcessor} process callback
 */ module.exports.processImportsField = function processImportsField(importsField) {
    return createFieldProcessor(importsField, (request)=>`#${request}`, assertImportsFieldRequest, assertImportTarget);
};
}}),
"[project]/node_modules/enhanced-resolve/lib/ExportsFieldPlugin.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Ivan Kopeykin @vankop
*/ const DescriptionFileUtils = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/DescriptionFileUtils.js [postcss] (ecmascript)");
const forEachBail = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/forEachBail.js [postcss] (ecmascript)");
const { processExportsField } = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/util/entrypoints.js [postcss] (ecmascript)");
const { parseIdentifier } = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/util/identifier.js [postcss] (ecmascript)");
const { deprecatedInvalidSegmentRegEx, invalidSegmentRegEx } = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/util/path.js [postcss] (ecmascript)");
/** @typedef {import("./Resolver")} Resolver */ /** @typedef {import("./Resolver").JsonObject} JsonObject */ /** @typedef {import("./Resolver").ResolveRequest} ResolveRequest */ /** @typedef {import("./Resolver").ResolveStepHook} ResolveStepHook */ /** @typedef {import("./util/entrypoints").ExportsField} ExportsField */ /** @typedef {import("./util/entrypoints").FieldProcessor} FieldProcessor */ module.exports = class ExportsFieldPlugin {
    /**
	 * @param {string | ResolveStepHook} source source
	 * @param {Set<string>} conditionNames condition names
	 * @param {string | string[]} fieldNamePath name path
	 * @param {string | ResolveStepHook} target target
	 */ constructor(source, conditionNames, fieldNamePath, target){
        this.source = source;
        this.target = target;
        this.conditionNames = conditionNames;
        this.fieldName = fieldNamePath;
        /** @type {WeakMap<JsonObject, FieldProcessor>} */ this.fieldProcessorCache = new WeakMap();
    }
    /**
	 * @param {Resolver} resolver the resolver
	 * @returns {void}
	 */ apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("ExportsFieldPlugin", (request, resolveContext, callback)=>{
            // When there is no description file, abort
            if (!request.descriptionFilePath) return callback();
            if (// When the description file is inherited from parent, abort
            // (There is no description file inside of this package)
            request.relativePath !== "." || request.request === undefined) {
                return callback();
            }
            const remainingRequest = request.query || request.fragment ? (request.request === "." ? "./" : request.request) + request.query + request.fragment : request.request;
            const exportsField = DescriptionFileUtils.getField(request.descriptionFileData, this.fieldName);
            if (!exportsField) return callback();
            if (request.directory) {
                return callback(new Error(`Resolving to directories is not possible with the exports field (request was ${remainingRequest}/)`));
            }
            /** @type {string[]} */ let paths;
            /** @type {string | null} */ let usedField;
            try {
                // We attach the cache to the description file instead of the exportsField value
                // because we use a WeakMap and the exportsField could be a string too.
                // Description file is always an object when exports field can be accessed.
                let fieldProcessor = this.fieldProcessorCache.get(request.descriptionFileData);
                if (fieldProcessor === undefined) {
                    fieldProcessor = processExportsField(exportsField);
                    this.fieldProcessorCache.set(request.descriptionFileData, fieldProcessor);
                }
                [paths, usedField] = fieldProcessor(remainingRequest, this.conditionNames);
            } catch (/** @type {unknown} */ err) {
                if (resolveContext.log) {
                    resolveContext.log(`Exports field in ${request.descriptionFilePath} can't be processed: ${err}`);
                }
                return callback(err);
            }
            if (paths.length === 0) {
                return callback(new Error(`Package path ${remainingRequest} is not exported from package ${request.descriptionFileRoot} (see exports field in ${request.descriptionFilePath})`));
            }
            forEachBail(paths, /**
					 * @param {string} path path
					 * @param {(err?: null|Error, result?: null|ResolveRequest) => void} callback callback
					 * @param {number} i index
					 * @returns {void}
					 */ (path, callback, i)=>{
                const parsedIdentifier = parseIdentifier(path);
                if (!parsedIdentifier) return callback();
                const [relativePath, query, fragment] = parsedIdentifier;
                if (relativePath.length === 0 || !relativePath.startsWith("./")) {
                    if (paths.length === i) {
                        return callback(new Error(`Invalid "exports" target "${path}" defined for "${usedField}" in the package config ${request.descriptionFilePath}, targets must start with "./"`));
                    }
                    return callback();
                }
                if (invalidSegmentRegEx.exec(relativePath.slice(2)) !== null && deprecatedInvalidSegmentRegEx.test(relativePath.slice(2)) !== null) {
                    if (paths.length === i) {
                        return callback(new Error(`Invalid "exports" target "${path}" defined for "${usedField}" in the package config ${request.descriptionFilePath}, targets must start with "./"`));
                    }
                    return callback();
                }
                /** @type {ResolveRequest} */ const obj = {
                    ...request,
                    request: undefined,
                    path: resolver.join(request.descriptionFileRoot, relativePath),
                    relativePath,
                    query,
                    fragment
                };
                resolver.doResolve(target, obj, `using exports field: ${path}`, resolveContext, (err, result)=>{
                    if (err) return callback(err);
                    // Don't allow to continue - https://github.com/webpack/enhanced-resolve/issues/400
                    if (result === undefined) return callback(null, null);
                    callback(null, result);
                });
            }, /**
					 * @param {(null | Error)=} err error
					 * @param {(null | ResolveRequest)=} result result
					 * @returns {void}
					 */ (err, result)=>callback(err, result || null));
        });
    }
};
}}),
"[project]/node_modules/enhanced-resolve/lib/ExtensionAliasPlugin.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Ivan Kopeykin @vankop
*/ const forEachBail = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/forEachBail.js [postcss] (ecmascript)");
/** @typedef {import("./Resolver")} Resolver */ /** @typedef {import("./Resolver").ResolveRequest} ResolveRequest */ /** @typedef {import("./Resolver").ResolveStepHook} ResolveStepHook */ /** @typedef {{ alias: string|string[], extension: string }} ExtensionAliasOption */ module.exports = class ExtensionAliasPlugin {
    /**
	 * @param {string | ResolveStepHook} source source
	 * @param {ExtensionAliasOption} options options
	 * @param {string | ResolveStepHook} target target
	 */ constructor(source, options, target){
        this.source = source;
        this.options = options;
        this.target = target;
    }
    /**
	 * @param {Resolver} resolver the resolver
	 * @returns {void}
	 */ apply(resolver) {
        const target = resolver.ensureHook(this.target);
        const { extension, alias } = this.options;
        resolver.getHook(this.source).tapAsync("ExtensionAliasPlugin", (request, resolveContext, callback)=>{
            const requestPath = request.request;
            if (!requestPath || !requestPath.endsWith(extension)) return callback();
            const isAliasString = typeof alias === "string";
            /**
				 * @param {string} alias extension alias
				 * @param {(err?: null | Error, result?: null|ResolveRequest) => void} callback callback
				 * @param {number=} index index
				 * @returns {void}
				 */ const resolve = (alias, callback, index)=>{
                const newRequest = `${requestPath.slice(0, -extension.length)}${alias}`;
                return resolver.doResolve(target, {
                    ...request,
                    request: newRequest,
                    fullySpecified: true
                }, `aliased from extension alias with mapping '${extension}' to '${alias}'`, resolveContext, (err, result)=>{
                    // Throw error if we are on the last alias (for multiple aliases) and it failed, always throw if we are not an array or we have only one alias
                    if (!isAliasString && index) {
                        if (index !== this.options.alias.length) {
                            if (resolveContext.log) {
                                resolveContext.log(`Failed to alias from extension alias with mapping '${extension}' to '${alias}' for '${newRequest}': ${err}`);
                            }
                            return callback(null, result);
                        }
                        return callback(err, result);
                    }
                    callback(err, result);
                });
            };
            /**
				 * @param {(null | Error)=} err error
				 * @param {(null | ResolveRequest)=} result result
				 * @returns {void}
				 */ const stoppingCallback = (err, result)=>{
                if (err) return callback(err);
                if (result) return callback(null, result);
                // Don't allow other aliasing or raw request
                return callback(null, null);
            };
            if (isAliasString) {
                resolve(alias, stoppingCallback);
            } else if (alias.length > 1) {
                forEachBail(alias, resolve, stoppingCallback);
            } else {
                resolve(alias[0], stoppingCallback);
            }
        });
    }
};
}}),
"[project]/node_modules/enhanced-resolve/lib/FileExistsPlugin.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ /** @typedef {import("./Resolver")} Resolver */ /** @typedef {import("./Resolver").ResolveStepHook} ResolveStepHook */ module.exports = class FileExistsPlugin {
    /**
	 * @param {string | ResolveStepHook} source source
	 * @param {string | ResolveStepHook} target target
	 */ constructor(source, target){
        this.source = source;
        this.target = target;
    }
    /**
	 * @param {Resolver} resolver the resolver
	 * @returns {void}
	 */ apply(resolver) {
        const target = resolver.ensureHook(this.target);
        const fs = resolver.fileSystem;
        resolver.getHook(this.source).tapAsync("FileExistsPlugin", (request, resolveContext, callback)=>{
            const file = request.path;
            if (!file) return callback();
            fs.stat(file, (err, stat)=>{
                if (err || !stat) {
                    if (resolveContext.missingDependencies) {
                        resolveContext.missingDependencies.add(file);
                    }
                    if (resolveContext.log) resolveContext.log(`${file} doesn't exist`);
                    return callback();
                }
                if (!stat.isFile()) {
                    if (resolveContext.missingDependencies) {
                        resolveContext.missingDependencies.add(file);
                    }
                    if (resolveContext.log) resolveContext.log(`${file} is not a file`);
                    return callback();
                }
                if (resolveContext.fileDependencies) {
                    resolveContext.fileDependencies.add(file);
                }
                resolver.doResolve(target, request, `existing file: ${file}`, resolveContext, callback);
            });
        });
    }
};
}}),
"[project]/node_modules/enhanced-resolve/lib/ImportsFieldPlugin.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Ivan Kopeykin @vankop
*/ const DescriptionFileUtils = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/DescriptionFileUtils.js [postcss] (ecmascript)");
const forEachBail = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/forEachBail.js [postcss] (ecmascript)");
const { processImportsField } = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/util/entrypoints.js [postcss] (ecmascript)");
const { parseIdentifier } = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/util/identifier.js [postcss] (ecmascript)");
const { deprecatedInvalidSegmentRegEx, invalidSegmentRegEx } = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/util/path.js [postcss] (ecmascript)");
/** @typedef {import("./Resolver")} Resolver */ /** @typedef {import("./Resolver").JsonObject} JsonObject */ /** @typedef {import("./Resolver").ResolveRequest} ResolveRequest */ /** @typedef {import("./Resolver").ResolveStepHook} ResolveStepHook */ /** @typedef {import("./util/entrypoints").FieldProcessor} FieldProcessor */ /** @typedef {import("./util/entrypoints").ImportsField} ImportsField */ const dotCode = ".".charCodeAt(0);
module.exports = class ImportsFieldPlugin {
    /**
	 * @param {string | ResolveStepHook} source source
	 * @param {Set<string>} conditionNames condition names
	 * @param {string | string[]} fieldNamePath name path
	 * @param {string | ResolveStepHook} targetFile target file
	 * @param {string | ResolveStepHook} targetPackage target package
	 */ constructor(source, conditionNames, fieldNamePath, targetFile, targetPackage){
        this.source = source;
        this.targetFile = targetFile;
        this.targetPackage = targetPackage;
        this.conditionNames = conditionNames;
        this.fieldName = fieldNamePath;
        /** @type {WeakMap<JsonObject, FieldProcessor>} */ this.fieldProcessorCache = new WeakMap();
    }
    /**
	 * @param {Resolver} resolver the resolver
	 * @returns {void}
	 */ apply(resolver) {
        const targetFile = resolver.ensureHook(this.targetFile);
        const targetPackage = resolver.ensureHook(this.targetPackage);
        resolver.getHook(this.source).tapAsync("ImportsFieldPlugin", (request, resolveContext, callback)=>{
            // When there is no description file, abort
            if (!request.descriptionFilePath || request.request === undefined) {
                return callback();
            }
            const remainingRequest = request.request + request.query + request.fragment;
            const importsField = DescriptionFileUtils.getField(request.descriptionFileData, this.fieldName);
            if (!importsField) return callback();
            if (request.directory) {
                return callback(new Error(`Resolving to directories is not possible with the imports field (request was ${remainingRequest}/)`));
            }
            /** @type {string[]} */ let paths;
            /** @type {string | null} */ let usedField;
            try {
                // We attach the cache to the description file instead of the importsField value
                // because we use a WeakMap and the importsField could be a string too.
                // Description file is always an object when exports field can be accessed.
                let fieldProcessor = this.fieldProcessorCache.get(request.descriptionFileData);
                if (fieldProcessor === undefined) {
                    fieldProcessor = processImportsField(importsField);
                    this.fieldProcessorCache.set(request.descriptionFileData, fieldProcessor);
                }
                [paths, usedField] = fieldProcessor(remainingRequest, this.conditionNames);
            } catch (/** @type {unknown} */ err) {
                if (resolveContext.log) {
                    resolveContext.log(`Imports field in ${request.descriptionFilePath} can't be processed: ${err}`);
                }
                return callback(err);
            }
            if (paths.length === 0) {
                return callback(new Error(`Package import ${remainingRequest} is not imported from package ${request.descriptionFileRoot} (see imports field in ${request.descriptionFilePath})`));
            }
            forEachBail(paths, /**
					 * @param {string} path path
					 * @param {(err?: null|Error, result?: null|ResolveRequest) => void} callback callback
					 * @param {number} i index
					 * @returns {void}
					 */ (path, callback, i)=>{
                const parsedIdentifier = parseIdentifier(path);
                if (!parsedIdentifier) return callback();
                const [path_, query, fragment] = parsedIdentifier;
                switch(path_.charCodeAt(0)){
                    // should be relative
                    case dotCode:
                        {
                            if (invalidSegmentRegEx.exec(path_.slice(2)) !== null && deprecatedInvalidSegmentRegEx.test(path_.slice(2)) !== null) {
                                if (paths.length === i) {
                                    return callback(new Error(`Invalid "imports" target "${path}" defined for "${usedField}" in the package config ${request.descriptionFilePath}, targets must start with "./"`));
                                }
                                return callback();
                            }
                            /** @type {ResolveRequest} */ const obj = {
                                ...request,
                                request: undefined,
                                path: resolver.join(request.descriptionFileRoot, path_),
                                relativePath: path_,
                                query,
                                fragment
                            };
                            resolver.doResolve(targetFile, obj, `using imports field: ${path}`, resolveContext, (err, result)=>{
                                if (err) return callback(err);
                                // Don't allow to continue - https://github.com/webpack/enhanced-resolve/issues/400
                                if (result === undefined) return callback(null, null);
                                callback(null, result);
                            });
                            break;
                        }
                    // package resolving
                    default:
                        {
                            /** @type {ResolveRequest} */ const obj = {
                                ...request,
                                request: path_,
                                relativePath: path_,
                                fullySpecified: true,
                                query,
                                fragment
                            };
                            resolver.doResolve(targetPackage, obj, `using imports field: ${path}`, resolveContext, (err, result)=>{
                                if (err) return callback(err);
                                // Don't allow to continue - https://github.com/webpack/enhanced-resolve/issues/400
                                if (result === undefined) return callback(null, null);
                                callback(null, result);
                            });
                        }
                }
            }, /**
					 * @param {(null|Error)=} err error
					 * @param {(null|ResolveRequest)=} result result
					 * @returns {void}
					 */ (err, result)=>callback(err, result || null));
        });
    }
};
}}),
"[project]/node_modules/enhanced-resolve/lib/JoinRequestPartPlugin.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ /** @typedef {import("./Resolver")} Resolver */ /** @typedef {import("./Resolver").ResolveRequest} ResolveRequest */ /** @typedef {import("./Resolver").ResolveStepHook} ResolveStepHook */ const namespaceStartCharCode = "@".charCodeAt(0);
module.exports = class JoinRequestPartPlugin {
    /**
	 * @param {string | ResolveStepHook} source source
	 * @param {string | ResolveStepHook} target target
	 */ constructor(source, target){
        this.source = source;
        this.target = target;
    }
    /**
	 * @param {Resolver} resolver the resolver
	 * @returns {void}
	 */ apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("JoinRequestPartPlugin", (request, resolveContext, callback)=>{
            const req = request.request || "";
            let i = req.indexOf("/", 3);
            if (i >= 0 && req.charCodeAt(2) === namespaceStartCharCode) {
                i = req.indexOf("/", i + 1);
            }
            /** @type {string} */ let moduleName;
            /** @type {string} */ let remainingRequest;
            /** @type {boolean} */ let fullySpecified;
            if (i < 0) {
                moduleName = req;
                remainingRequest = ".";
                fullySpecified = false;
            } else {
                moduleName = req.slice(0, i);
                remainingRequest = `.${req.slice(i)}`;
                fullySpecified = request.fullySpecified;
            }
            /** @type {ResolveRequest} */ const obj = {
                ...request,
                path: resolver.join(request.path, moduleName),
                relativePath: request.relativePath && resolver.join(request.relativePath, moduleName),
                request: remainingRequest,
                fullySpecified
            };
            resolver.doResolve(target, obj, null, resolveContext, callback);
        });
    }
};
}}),
"[project]/node_modules/enhanced-resolve/lib/JoinRequestPlugin.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ /** @typedef {import("./Resolver")} Resolver */ /** @typedef {import("./Resolver").ResolveRequest} ResolveRequest */ /** @typedef {import("./Resolver").ResolveStepHook} ResolveStepHook */ module.exports = class JoinRequestPlugin {
    /**
	 * @param {string | ResolveStepHook} source source
	 * @param {string | ResolveStepHook} target target
	 */ constructor(source, target){
        this.source = source;
        this.target = target;
    }
    /**
	 * @param {Resolver} resolver the resolver
	 * @returns {void}
	 */ apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("JoinRequestPlugin", (request, resolveContext, callback)=>{
            const requestPath = request.path;
            const requestRequest = request.request;
            /** @type {ResolveRequest} */ const obj = {
                ...request,
                path: resolver.join(requestPath, requestRequest),
                relativePath: request.relativePath && resolver.join(request.relativePath, requestRequest),
                request: undefined
            };
            resolver.doResolve(target, obj, null, resolveContext, callback);
        });
    }
};
}}),
"[project]/node_modules/enhanced-resolve/lib/MainFieldPlugin.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const DescriptionFileUtils = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/DescriptionFileUtils.js [postcss] (ecmascript)");
/** @typedef {import("./Resolver")} Resolver */ /** @typedef {import("./Resolver").JsonObject} JsonObject */ /** @typedef {import("./Resolver").ResolveRequest} ResolveRequest */ /** @typedef {import("./Resolver").ResolveStepHook} ResolveStepHook */ /** @typedef {{name: string|Array<string>, forceRelative: boolean}} MainFieldOptions */ const alreadyTriedMainField = Symbol("alreadyTriedMainField");
module.exports = class MainFieldPlugin {
    /**
	 * @param {string | ResolveStepHook} source source
	 * @param {MainFieldOptions} options options
	 * @param {string | ResolveStepHook} target target
	 */ constructor(source, options, target){
        this.source = source;
        this.options = options;
        this.target = target;
    }
    /**
	 * @param {Resolver} resolver the resolver
	 * @returns {void}
	 */ apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("MainFieldPlugin", (request, resolveContext, callback)=>{
            if (request.path !== request.descriptionFileRoot || /** @type {ResolveRequest & { [alreadyTriedMainField]?: string }} */ request[alreadyTriedMainField] === request.descriptionFilePath || !request.descriptionFilePath) {
                return callback();
            }
            const filename = path.basename(request.descriptionFilePath);
            let mainModule = DescriptionFileUtils.getField(request.descriptionFileData, this.options.name);
            if (!mainModule || typeof mainModule !== "string" || mainModule === "." || mainModule === "./") {
                return callback();
            }
            if (this.options.forceRelative && !/^\.\.?\//.test(mainModule)) {
                mainModule = `./${mainModule}`;
            }
            /** @type {ResolveRequest & { [alreadyTriedMainField]?: string }} */ const obj = {
                ...request,
                request: mainModule,
                module: false,
                directory: mainModule.endsWith("/"),
                [alreadyTriedMainField]: request.descriptionFilePath
            };
            return resolver.doResolve(target, obj, `use ${mainModule} from ${this.options.name} in ${filename}`, resolveContext, callback);
        });
    }
};
}}),
"[project]/node_modules/enhanced-resolve/lib/ModulesInHierarchicalDirectoriesPlugin.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const forEachBail = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/forEachBail.js [postcss] (ecmascript)");
const getPaths = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/getPaths.js [postcss] (ecmascript)");
/** @typedef {import("./Resolver")} Resolver */ /** @typedef {import("./Resolver").ResolveRequest} ResolveRequest */ /** @typedef {import("./Resolver").ResolveStepHook} ResolveStepHook */ module.exports = class ModulesInHierarchicalDirectoriesPlugin {
    /**
	 * @param {string | ResolveStepHook} source source
	 * @param {string | Array<string>} directories directories
	 * @param {string | ResolveStepHook} target target
	 */ constructor(source, directories, target){
        this.source = source;
        this.directories = /** @type {Array<string>} */ [
            ...directories
        ];
        this.target = target;
    }
    /**
	 * @param {Resolver} resolver the resolver
	 * @returns {void}
	 */ apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("ModulesInHierarchicalDirectoriesPlugin", (request, resolveContext, callback)=>{
            const fs = resolver.fileSystem;
            const addrs = getPaths(request.path).paths.map((path)=>this.directories.map((directory)=>resolver.join(path, directory))).reduce((array, path)=>{
                array.push(...path);
                return array;
            }, []);
            forEachBail(addrs, /**
						 * @param {string} addr addr
						 * @param {(err?: null|Error, result?: null|ResolveRequest) => void} callback callback
						 * @returns {void}
						 */ (addr, callback)=>{
                fs.stat(addr, (err, stat)=>{
                    if (!err && stat && stat.isDirectory()) {
                        /** @type {ResolveRequest} */ const obj = {
                            ...request,
                            path: addr,
                            request: `./${request.request}`,
                            module: false
                        };
                        const message = `looking for modules in ${addr}`;
                        return resolver.doResolve(target, obj, message, resolveContext, callback);
                    }
                    if (resolveContext.log) {
                        resolveContext.log(`${addr} doesn't exist or is not a directory`);
                    }
                    if (resolveContext.missingDependencies) {
                        resolveContext.missingDependencies.add(addr);
                    }
                    return callback();
                });
            }, callback);
        });
    }
};
}}),
"[project]/node_modules/enhanced-resolve/lib/ModulesInRootPlugin.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ /** @typedef {import("./Resolver")} Resolver */ /** @typedef {import("./Resolver").ResolveRequest} ResolveRequest */ /** @typedef {import("./Resolver").ResolveStepHook} ResolveStepHook */ module.exports = class ModulesInRootPlugin {
    /**
	 * @param {string | ResolveStepHook} source source
	 * @param {string} path path
	 * @param {string | ResolveStepHook} target target
	 */ constructor(source, path, target){
        this.source = source;
        this.path = path;
        this.target = target;
    }
    /**
	 * @param {Resolver} resolver the resolver
	 * @returns {void}
	 */ apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("ModulesInRootPlugin", (request, resolveContext, callback)=>{
            /** @type {ResolveRequest} */ const obj = {
                ...request,
                path: this.path,
                request: `./${request.request}`,
                module: false
            };
            resolver.doResolve(target, obj, `looking for modules in ${this.path}`, resolveContext, callback);
        });
    }
};
}}),
"[project]/node_modules/enhanced-resolve/lib/NextPlugin.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ /** @typedef {import("./Resolver")} Resolver */ /** @typedef {import("./Resolver").ResolveStepHook} ResolveStepHook */ module.exports = class NextPlugin {
    /**
	 * @param {string | ResolveStepHook} source source
	 * @param {string | ResolveStepHook} target target
	 */ constructor(source, target){
        this.source = source;
        this.target = target;
    }
    /**
	 * @param {Resolver} resolver the resolver
	 * @returns {void}
	 */ apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("NextPlugin", (request, resolveContext, callback)=>{
            resolver.doResolve(target, request, null, resolveContext, callback);
        });
    }
};
}}),
"[project]/node_modules/enhanced-resolve/lib/ParsePlugin.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ /** @typedef {import("./Resolver")} Resolver */ /** @typedef {import("./Resolver").ResolveRequest} ResolveRequest */ /** @typedef {import("./Resolver").ResolveStepHook} ResolveStepHook */ module.exports = class ParsePlugin {
    /**
	 * @param {string | ResolveStepHook} source source
	 * @param {Partial<ResolveRequest>} requestOptions request options
	 * @param {string | ResolveStepHook} target target
	 */ constructor(source, requestOptions, target){
        this.source = source;
        this.requestOptions = requestOptions;
        this.target = target;
    }
    /**
	 * @param {Resolver} resolver the resolver
	 * @returns {void}
	 */ apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("ParsePlugin", (request, resolveContext, callback)=>{
            const parsed = resolver.parse(request.request);
            /** @type {ResolveRequest} */ const obj = {
                ...request,
                ...parsed,
                ...this.requestOptions
            };
            if (request.query && !parsed.query) {
                obj.query = request.query;
            }
            if (request.fragment && !parsed.fragment) {
                obj.fragment = request.fragment;
            }
            if (parsed && resolveContext.log) {
                if (parsed.module) resolveContext.log("Parsed request is a module");
                if (parsed.directory) {
                    resolveContext.log("Parsed request is a directory");
                }
            }
            // There is an edge-case where a request with # can be a path or a fragment -> try both
            if (obj.request && !obj.query && obj.fragment) {
                const directory = obj.fragment.endsWith("/");
                /** @type {ResolveRequest} */ const alternative = {
                    ...obj,
                    directory,
                    request: obj.request + (obj.directory ? "/" : "") + (directory ? obj.fragment.slice(0, -1) : obj.fragment),
                    fragment: ""
                };
                resolver.doResolve(target, alternative, null, resolveContext, (err, result)=>{
                    if (err) return callback(err);
                    if (result) return callback(null, result);
                    resolver.doResolve(target, obj, null, resolveContext, callback);
                });
                return;
            }
            resolver.doResolve(target, obj, null, resolveContext, callback);
        });
    }
};
}}),
"[project]/node_modules/enhanced-resolve/lib/PnpPlugin.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Mal Nison @arcanis
*/ /** @typedef {import("./Resolver")} Resolver */ /** @typedef {import("./Resolver").ResolveStepHook} ResolveStepHook */ /** @typedef {import("./Resolver").ResolveRequest} ResolveRequest */ /**
 * @typedef {object} PnpApiImpl
 * @property {(packageName: string, issuer: string, options: { considerBuiltins: boolean }) => string | null} resolveToUnqualified resolve to unqualified
 */ module.exports = class PnpPlugin {
    /**
	 * @param {string | ResolveStepHook} source source
	 * @param {PnpApiImpl} pnpApi pnpApi
	 * @param {string | ResolveStepHook} target target
	 * @param {string | ResolveStepHook} alternateTarget alternateTarget
	 */ constructor(source, pnpApi, target, alternateTarget){
        this.source = source;
        this.pnpApi = pnpApi;
        this.target = target;
        this.alternateTarget = alternateTarget;
    }
    /**
	 * @param {Resolver} resolver the resolver
	 * @returns {void}
	 */ apply(resolver) {
        /** @type {ResolveStepHook} */ const target = resolver.ensureHook(this.target);
        const alternateTarget = resolver.ensureHook(this.alternateTarget);
        resolver.getHook(this.source).tapAsync("PnpPlugin", (request, resolveContext, callback)=>{
            const req = request.request;
            if (!req) return callback();
            // The trailing slash indicates to PnP that this value is a folder rather than a file
            const issuer = `${request.path}/`;
            const packageMatch = /^(@[^/]+\/)?[^/]+/.exec(req);
            if (!packageMatch) return callback();
            const [packageName] = packageMatch;
            const innerRequest = `.${req.slice(packageName.length)}`;
            /** @type {string|undefined|null} */ let resolution;
            /** @type {string|undefined|null} */ let apiResolution;
            try {
                resolution = this.pnpApi.resolveToUnqualified(packageName, issuer, {
                    considerBuiltins: false
                });
                if (resolution === null) {
                    // This is either not a PnP managed issuer or it's a Node builtin
                    // Try to continue resolving with our alternatives
                    resolver.doResolve(alternateTarget, request, "issuer is not managed by a pnpapi", resolveContext, (err, result)=>{
                        if (err) return callback(err);
                        if (result) return callback(null, result);
                        // Skip alternatives
                        return callback(null, null);
                    });
                    return;
                }
                if (resolveContext.fileDependencies) {
                    apiResolution = this.pnpApi.resolveToUnqualified("pnpapi", issuer, {
                        considerBuiltins: false
                    });
                }
            } catch (/** @type {unknown} */ error) {
                if (/** @type {Error & { code: string }} */ error.code === "MODULE_NOT_FOUND" && /** @type {Error & { pnpCode: string }} */ error.pnpCode === "UNDECLARED_DEPENDENCY") {
                    // This is not a PnP managed dependency.
                    // Try to continue resolving with our alternatives
                    if (resolveContext.log) {
                        resolveContext.log("request is not managed by the pnpapi");
                        for (const line of error.message.split("\n").filter(Boolean)){
                            resolveContext.log(`  ${line}`);
                        }
                    }
                    return callback();
                }
                return callback(error);
            }
            if (resolution === packageName) return callback();
            if (apiResolution && resolveContext.fileDependencies) {
                resolveContext.fileDependencies.add(apiResolution);
            }
            /** @type {ResolveRequest} */ const obj = {
                ...request,
                path: resolution,
                request: innerRequest,
                ignoreSymlinks: true,
                fullySpecified: request.fullySpecified && innerRequest !== "."
            };
            resolver.doResolve(target, obj, `resolved by pnp to ${resolution}`, resolveContext, (err, result)=>{
                if (err) return callback(err);
                if (result) return callback(null, result);
                // Skip alternatives
                return callback(null, null);
            });
        });
    }
};
}}),
"[project]/node_modules/enhanced-resolve/lib/createInnerContext.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ /** @typedef {import("./Resolver").ResolveContext} ResolveContext */ /**
 * @param {ResolveContext} options options for inner context
 * @param {null|string} message message to log
 * @returns {ResolveContext} inner context
 */ module.exports = function createInnerContext(options, message) {
    let messageReported = false;
    let innerLog;
    if (options.log) {
        if (message) {
            /**
			 * @param {string} msg message
			 */ innerLog = (msg)=>{
                if (!messageReported) {
                    /** @type {((str: string) => void)} */ options.log(message);
                    messageReported = true;
                }
                /** @type {((str: string) => void)} */ options.log(`  ${msg}`);
            };
        } else {
            innerLog = options.log;
        }
    }
    return {
        log: innerLog,
        yield: options.yield,
        fileDependencies: options.fileDependencies,
        contextDependencies: options.contextDependencies,
        missingDependencies: options.missingDependencies,
        stack: options.stack
    };
};
}}),
"[project]/node_modules/enhanced-resolve/lib/Resolver.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const { AsyncSeriesBailHook, AsyncSeriesHook, SyncHook } = __turbopack_context__.r("[project]/node_modules/tapable/lib/index.js [postcss] (ecmascript)");
const createInnerContext = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/createInnerContext.js [postcss] (ecmascript)");
const { parseIdentifier } = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/util/identifier.js [postcss] (ecmascript)");
const { PathType, cachedJoin: join, getType, normalize } = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/util/path.js [postcss] (ecmascript)");
/** @typedef {import("./ResolverFactory").ResolveOptions} ResolveOptions */ /** @typedef {Error & { details?: string }} ErrorWithDetail */ /** @typedef {(err: ErrorWithDetail | null, res?: string | false, req?: ResolveRequest) => void} ResolveCallback */ /**
 * @typedef {object} PossibleFileSystemError
 * @property {string=} code code
 * @property {number=} errno number
 * @property {string=} path path
 * @property {string=} syscall syscall
 */ /**
 * @template T
 * @callback FileSystemCallback
 * @param {PossibleFileSystemError & Error | null} err
 * @param {T=} result
 */ /**
 * @typedef {string | Buffer | URL} PathLike
 */ /**
 * @typedef {PathLike | number} PathOrFileDescriptor
 */ /**
 * @typedef {object} ObjectEncodingOptions
 * @property {BufferEncoding | null | undefined=} encoding encoding
 */ /**
 * @typedef {ObjectEncodingOptions | BufferEncoding | undefined | null} EncodingOption
 */ /** @typedef {(err: NodeJS.ErrnoException | null, result?: string) => void} StringCallback */ /** @typedef {(err: NodeJS.ErrnoException | null, result?: Buffer) => void} BufferCallback */ /** @typedef {(err: NodeJS.ErrnoException | null, result?: (string | Buffer)) => void} StringOrBufferCallback */ /** @typedef {(err: NodeJS.ErrnoException | null, result?: IStats) => void} StatsCallback */ /** @typedef {(err: NodeJS.ErrnoException | null, result?: IBigIntStats) => void} BigIntStatsCallback */ /** @typedef {(err: NodeJS.ErrnoException | null, result?: (IStats | IBigIntStats)) => void} StatsOrBigIntStatsCallback */ /** @typedef {(err: NodeJS.ErrnoException | Error | null, result?: JsonObject) => void} ReadJsonCallback */ /**
 * @template T
 * @typedef {object} IStatsBase
 * @property {() => boolean} isFile is file
 * @property {() => boolean} isDirectory is directory
 * @property {() => boolean} isBlockDevice is block device
 * @property {() => boolean} isCharacterDevice is character device
 * @property {() => boolean} isSymbolicLink is symbolic link
 * @property {() => boolean} isFIFO is FIFO
 * @property {() => boolean} isSocket is socket
 * @property {T} dev dev
 * @property {T} ino ino
 * @property {T} mode mode
 * @property {T} nlink nlink
 * @property {T} uid uid
 * @property {T} gid gid
 * @property {T} rdev rdev
 * @property {T} size size
 * @property {T} blksize blksize
 * @property {T} blocks blocks
 * @property {T} atimeMs atime ms
 * @property {T} mtimeMs mtime ms
 * @property {T} ctimeMs ctime ms
 * @property {T} birthtimeMs birthtime ms
 * @property {Date} atime atime
 * @property {Date} mtime mtime
 * @property {Date} ctime ctime
 * @property {Date} birthtime birthtime
 */ /**
 * @typedef {IStatsBase<number>} IStats
 */ /**
 * @typedef {IStatsBase<bigint> & { atimeNs: bigint, mtimeNs: bigint, ctimeNs: bigint, birthtimeNs: bigint }} IBigIntStats
 */ /**
 * @template {string | Buffer} [T=string]
 * @typedef {object} Dirent
 * @property {() => boolean} isFile true when is file, otherwise false
 * @property {() => boolean} isDirectory true when is directory, otherwise false
 * @property {() => boolean} isBlockDevice true when is block device, otherwise false
 * @property {() => boolean} isCharacterDevice true when is character device, otherwise false
 * @property {() => boolean} isSymbolicLink true when is symbolic link, otherwise false
 * @property {() => boolean} isFIFO true when is FIFO, otherwise false
 * @property {() => boolean} isSocket true when is socket, otherwise false
 * @property {T} name name
 * @property {string} parentPath path
 * @property {string=} path path
 */ /**
 * @typedef {object} StatOptions
 * @property {(boolean | undefined)=} bigint need bigint values
 */ /**
 * @typedef {object} StatSyncOptions
 * @property {(boolean | undefined)=} bigint need bigint values
 * @property {(boolean | undefined)=} throwIfNoEntry throw if no entry
 */ /**
 * @typedef {{
 * (path: PathOrFileDescriptor, options: ({ encoding?: null | undefined, flag?: string | undefined } & import("events").Abortable) | undefined | null, callback: BufferCallback): void;
 * (path: PathOrFileDescriptor, options: ({ encoding: BufferEncoding, flag?: string | undefined } & import("events").Abortable) | BufferEncoding, callback: StringCallback): void;
 * (path: PathOrFileDescriptor, options: (ObjectEncodingOptions & { flag?: string | undefined } & import("events").Abortable) | BufferEncoding | undefined | null, callback: StringOrBufferCallback): void;
 * (path: PathOrFileDescriptor, callback: BufferCallback): void;
 * }} ReadFile
 */ /**
 * @typedef {'buffer'| { encoding: 'buffer' }} BufferEncodingOption
 */ /**
 * @typedef {{
 * (path: PathOrFileDescriptor, options?: { encoding?: null | undefined, flag?: string | undefined } | null): Buffer;
 * (path: PathOrFileDescriptor, options: { encoding: BufferEncoding, flag?: string | undefined } | BufferEncoding): string;
 * (path: PathOrFileDescriptor, options?: (ObjectEncodingOptions & { flag?: string | undefined }) | BufferEncoding | null): string | Buffer;
 * }} ReadFileSync
 */ /**
 * @typedef {{
 * (path: PathLike, options: { encoding: BufferEncoding | null, withFileTypes?: false | undefined, recursive?: boolean | undefined } | BufferEncoding | undefined | null, callback: (err: NodeJS.ErrnoException | null, files?: string[]) => void): void;
 * (path: PathLike, options: { encoding: 'buffer', withFileTypes?: false | undefined, recursive?: boolean | undefined } | 'buffer', callback: (err: NodeJS.ErrnoException | null, files?: Buffer[]) => void): void;
 * (path: PathLike, options: (ObjectEncodingOptions & { withFileTypes?: false | undefined, recursive?: boolean | undefined }) | BufferEncoding | undefined | null, callback: (err: NodeJS.ErrnoException | null, files?: string[] | Buffer[]) => void): void;
 * (path: PathLike, callback: (err: NodeJS.ErrnoException | null, files?: string[]) => void): void;
 * (path: PathLike, options: ObjectEncodingOptions & { withFileTypes: true, recursive?: boolean | undefined }, callback: (err: NodeJS.ErrnoException | null, files?: Dirent<string>[]) => void): void;
 * (path: PathLike, options: { encoding: 'buffer', withFileTypes: true, recursive?: boolean | undefined }, callback: (err: NodeJS.ErrnoException | null, files: Dirent<Buffer>[]) => void): void;
 * }} Readdir
 */ /**
 * @typedef {{
 * (path: PathLike, options?: { encoding: BufferEncoding | null, withFileTypes?: false | undefined, recursive?: boolean | undefined; } | BufferEncoding | null): string[];
 * (path: PathLike, options: { encoding: 'buffer', withFileTypes?: false | undefined, recursive?: boolean | undefined } | 'buffer'): Buffer[];
 * (path: PathLike, options?: (ObjectEncodingOptions & { withFileTypes?: false | undefined, recursive?: boolean | undefined }) | BufferEncoding | null): string[] | Buffer[];
 * (path: PathLike, options: ObjectEncodingOptions & { withFileTypes: true, recursive?: boolean | undefined }): Dirent[];
 * (path: PathLike, options: { encoding: "buffer", withFileTypes: true, recursive?: boolean | undefined }): Dirent<Buffer>[];
 * }} ReaddirSync
 */ /**
 * @typedef {(pathOrFileDescription: PathOrFileDescriptor, callback: ReadJsonCallback) => void} ReadJson
 */ /**
 * @typedef {(pathOrFileDescription: PathOrFileDescriptor) => JsonObject} ReadJsonSync
 */ /**
 * @typedef {{
 * (path: PathLike, options: EncodingOption, callback: StringCallback): void;
 * (path: PathLike, options: BufferEncodingOption, callback: BufferCallback): void;
 * (path: PathLike, options: EncodingOption, callback: StringOrBufferCallback): void;
 * (path: PathLike, callback: StringCallback): void;
 * }} Readlink
 */ /**
 * @typedef {{
 * (path: PathLike, options?: EncodingOption): string;
 * (path: PathLike, options: BufferEncodingOption): Buffer;
 * (path: PathLike, options?: EncodingOption): string | Buffer;
 * }} ReadlinkSync
 */ /**
 * @typedef {{
 * (path: PathLike, callback: StatsCallback): void;
 * (path: PathLike, options: (StatOptions & { bigint?: false | undefined }) | undefined, callback: StatsCallback): void;
 * (path: PathLike, options: StatOptions & { bigint: true }, callback: BigIntStatsCallback): void;
 * (path: PathLike, options: StatOptions | undefined, callback: StatsOrBigIntStatsCallback): void;
 * }} LStat
 */ /**
 * @typedef {{
 * (path: PathLike, options?: undefined): IStats;
 * (path: PathLike, options?: StatSyncOptions & { bigint?: false | undefined, throwIfNoEntry: false }): IStats | undefined;
 * (path: PathLike, options: StatSyncOptions & { bigint: true, throwIfNoEntry: false }): IBigIntStats | undefined;
 * (path: PathLike, options?: StatSyncOptions & { bigint?: false | undefined }): IStats;
 * (path: PathLike, options: StatSyncOptions & { bigint: true }): IBigIntStats;
 * (path: PathLike,  options: StatSyncOptions & { bigint: boolean, throwIfNoEntry?: false | undefined }): IStats | IBigIntStats;
 * (path: PathLike,  options?: StatSyncOptions): IStats | IBigIntStats | undefined;
 * }} LStatSync
 */ /**
 * @typedef {{
 * (path: PathLike, callback: StatsCallback): void;
 * (path: PathLike, options: (StatOptions & { bigint?: false | undefined }) | undefined, callback: StatsCallback): void;
 * (path: PathLike, options: StatOptions & { bigint: true }, callback: BigIntStatsCallback): void;
 * (path: PathLike, options: StatOptions | undefined, callback: StatsOrBigIntStatsCallback): void;
 * }} Stat
 */ /**
 * @typedef {{
 * (path: PathLike, options?: undefined): IStats;
 * (path: PathLike, options?: StatSyncOptions & { bigint?: false | undefined, throwIfNoEntry: false }): IStats | undefined;
 * (path: PathLike, options: StatSyncOptions & { bigint: true, throwIfNoEntry: false }): IBigIntStats | undefined;
 * (path: PathLike, options?: StatSyncOptions & { bigint?: false | undefined }): IStats;
 * (path: PathLike, options: StatSyncOptions & { bigint: true }): IBigIntStats;
 * (path: PathLike,  options: StatSyncOptions & { bigint: boolean, throwIfNoEntry?: false | undefined }): IStats | IBigIntStats;
 * (path: PathLike,  options?: StatSyncOptions): IStats | IBigIntStats | undefined;
 * }} StatSync
 */ /**
 * @typedef {{
 * (path: PathLike, options: EncodingOption, callback: StringCallback): void;
 * (path: PathLike, options: BufferEncodingOption, callback: BufferCallback): void;
 * (path: PathLike, options: EncodingOption, callback: StringOrBufferCallback): void;
 * (path: PathLike, callback: StringCallback): void;
 * }} RealPath
 */ /**
 * @typedef {{
 * (path: PathLike, options?: EncodingOption): string;
 * (path: PathLike, options: BufferEncodingOption): Buffer;
 * (path: PathLike, options?: EncodingOption): string | Buffer;
 * }} RealPathSync
 */ /**
 * @typedef {object} FileSystem
 * @property {ReadFile} readFile read file method
 * @property {Readdir} readdir readdir method
 * @property {ReadJson=} readJson read json method
 * @property {Readlink} readlink read link method
 * @property {LStat=} lstat lstat method
 * @property {Stat} stat stat method
 * @property {RealPath=} realpath realpath method
 */ /**
 * @typedef {object} SyncFileSystem
 * @property {ReadFileSync} readFileSync read file sync method
 * @property {ReaddirSync} readdirSync read dir sync method
 * @property {ReadJsonSync=} readJsonSync read json sync method
 * @property {ReadlinkSync} readlinkSync read link sync method
 * @property {LStatSync=} lstatSync lstat sync method
 * @property {StatSync} statSync stat sync method
 * @property {RealPathSync=} realpathSync real path sync method
 */ /**
 * @typedef {object} ParsedIdentifier
 * @property {string} request request
 * @property {string} query query
 * @property {string} fragment fragment
 * @property {boolean} directory is directory
 * @property {boolean} module is module
 * @property {boolean} file is file
 * @property {boolean} internal is internal
 */ /** @typedef {string | number | boolean | null} JsonPrimitive */ /** @typedef {JsonValue[]} JsonArray */ /** @typedef {JsonPrimitive | JsonObject | JsonArray} JsonValue */ /** @typedef {{ [Key in string]?: JsonValue | undefined }} JsonObject */ // eslint-disable-next-line jsdoc/require-property
/** @typedef {object} Context */ /**
 * @typedef {object} BaseResolveRequest
 * @property {string | false} path path
 * @property {Context=} context content
 * @property {string=} descriptionFilePath description file path
 * @property {string=} descriptionFileRoot description file root
 * @property {JsonObject=} descriptionFileData description file data
 * @property {string=} relativePath relative path
 * @property {boolean=} ignoreSymlinks true when need to ignore symlinks, otherwise false
 * @property {boolean=} fullySpecified true when full specified, otherwise false
 * @property {string=} __innerRequest inner request for internal usage
 * @property {string=} __innerRequest_request inner request for internal usage
 * @property {string=} __innerRequest_relativePath inner relative path for internal usage
 */ /** @typedef {BaseResolveRequest & Partial<ParsedIdentifier>} ResolveRequest */ /**
 * String with special formatting
 * @typedef {string} StackEntry
 */ /**
 * @template T
 * @typedef {{ add: (item: T) => void }} WriteOnlySet
 */ /** @typedef {(request: ResolveRequest) => void} ResolveContextYield */ /**
 * Resolve context
 * @typedef {object} ResolveContext
 * @property {WriteOnlySet<string>=} contextDependencies directories that was found on file system
 * @property {WriteOnlySet<string>=} fileDependencies files that was found on file system
 * @property {WriteOnlySet<string>=} missingDependencies dependencies that was not found on file system
 * @property {Set<StackEntry>=} stack set of hooks' calls. For instance, `resolve  parsedResolve  describedResolve`,
 * @property {((str: string) => void)=} log log function
 * @property {ResolveContextYield=} yield yield result, if provided plugins can return several results
 */ /** @typedef {AsyncSeriesBailHook<[ResolveRequest, ResolveContext], ResolveRequest | null>} ResolveStepHook */ /**
 * @typedef {object} KnownHooks
 * @property {SyncHook<[ResolveStepHook, ResolveRequest], void>} resolveStep resolve step hook
 * @property {SyncHook<[ResolveRequest, Error]>} noResolve no resolve hook
 * @property {ResolveStepHook} resolve resolve hook
 * @property {AsyncSeriesHook<[ResolveRequest, ResolveContext]>} result result hook
 */ /**
 * @typedef {{[key: string]: ResolveStepHook}} EnsuredHooks
 */ /**
 * @param {string} str input string
 * @returns {string} in camel case
 */ function toCamelCase(str) {
    return str.replace(/-([a-z])/g, (str)=>str.slice(1).toUpperCase());
}
class Resolver {
    /**
	 * @param {ResolveStepHook} hook hook
	 * @param {ResolveRequest} request request
	 * @returns {StackEntry} stack entry
	 */ static createStackEntry(hook, request) {
        return `${hook.name}: (${request.path}) ${request.request || ""}${request.query || ""}${request.fragment || ""}${request.directory ? " directory" : ""}${request.module ? " module" : ""}`;
    }
    /**
	 * @param {FileSystem} fileSystem a filesystem
	 * @param {ResolveOptions} options options
	 */ constructor(fileSystem, options){
        this.fileSystem = fileSystem;
        this.options = options;
        /** @type {KnownHooks} */ this.hooks = {
            resolveStep: new SyncHook([
                "hook",
                "request"
            ], "resolveStep"),
            noResolve: new SyncHook([
                "request",
                "error"
            ], "noResolve"),
            resolve: new AsyncSeriesBailHook([
                "request",
                "resolveContext"
            ], "resolve"),
            result: new AsyncSeriesHook([
                "result",
                "resolveContext"
            ], "result")
        };
    }
    /**
	 * @param {string | ResolveStepHook} name hook name or hook itself
	 * @returns {ResolveStepHook} the hook
	 */ ensureHook(name) {
        if (typeof name !== "string") {
            return name;
        }
        name = toCamelCase(name);
        if (name.startsWith("before")) {
            return this.ensureHook(name[6].toLowerCase() + name.slice(7)).withOptions({
                stage: -10
            });
        }
        if (name.startsWith("after")) {
            return this.ensureHook(name[5].toLowerCase() + name.slice(6)).withOptions({
                stage: 10
            });
        }
        /** @type {ResolveStepHook} */ const hook = /** @type {KnownHooks & EnsuredHooks} */ this.hooks[name];
        if (!hook) {
            /** @type {KnownHooks & EnsuredHooks} */ this.hooks[name] = new AsyncSeriesBailHook([
                "request",
                "resolveContext"
            ], name);
            return /** @type {KnownHooks & EnsuredHooks} */ this.hooks[name];
        }
        return hook;
    }
    /**
	 * @param {string | ResolveStepHook} name hook name or hook itself
	 * @returns {ResolveStepHook} the hook
	 */ getHook(name) {
        if (typeof name !== "string") {
            return name;
        }
        name = toCamelCase(name);
        if (name.startsWith("before")) {
            return this.getHook(name[6].toLowerCase() + name.slice(7)).withOptions({
                stage: -10
            });
        }
        if (name.startsWith("after")) {
            return this.getHook(name[5].toLowerCase() + name.slice(6)).withOptions({
                stage: 10
            });
        }
        /** @type {ResolveStepHook} */ const hook = /** @type {KnownHooks & EnsuredHooks} */ this.hooks[name];
        if (!hook) {
            throw new Error(`Hook ${name} doesn't exist`);
        }
        return hook;
    }
    /**
	 * @param {object} context context information object
	 * @param {string} path context path
	 * @param {string} request request string
	 * @returns {string | false} result
	 */ resolveSync(context, path, request) {
        /** @type {Error | null | undefined} */ let err;
        /** @type {string | false | undefined} */ let result;
        let sync = false;
        this.resolve(context, path, request, {}, (_err, r)=>{
            err = _err;
            result = r;
            sync = true;
        });
        if (!sync) {
            throw new Error("Cannot 'resolveSync' because the fileSystem is not sync. Use 'resolve'!");
        }
        if (err) throw err;
        if (result === undefined) throw new Error("No result");
        return result;
    }
    /**
	 * @param {object} context context information object
	 * @param {string} path context path
	 * @param {string} request request string
	 * @param {ResolveContext} resolveContext resolve context
	 * @param {ResolveCallback} callback callback function
	 * @returns {void}
	 */ resolve(context, path, request, resolveContext, callback) {
        if (!context || typeof context !== "object") {
            return callback(new Error("context argument is not an object"));
        }
        if (typeof path !== "string") {
            return callback(new Error("path argument is not a string"));
        }
        if (typeof request !== "string") {
            return callback(new Error("request argument is not a string"));
        }
        if (!resolveContext) {
            return callback(new Error("resolveContext argument is not set"));
        }
        /** @type {ResolveRequest} */ const obj = {
            context,
            path,
            request
        };
        /** @type {ResolveContextYield | undefined} */ let yield_;
        let yieldCalled = false;
        /** @type {ResolveContextYield | undefined} */ let finishYield;
        if (typeof resolveContext.yield === "function") {
            const old = resolveContext.yield;
            /**
			 * @param {ResolveRequest} obj object
			 */ yield_ = (obj)=>{
                old(obj);
                yieldCalled = true;
            };
            /**
			 * @param {ResolveRequest} result result
			 * @returns {void}
			 */ finishYield = (result)=>{
                if (result) {
                    /** @type {ResolveContextYield} */ yield_(result);
                }
                callback(null);
            };
        }
        const message = `resolve '${request}' in '${path}'`;
        /**
		 * @param {ResolveRequest} result result
		 * @returns {void}
		 */ const finishResolved = (result)=>callback(null, result.path === false ? false : `${result.path.replace(/#/g, "\0#")}${result.query ? result.query.replace(/#/g, "\0#") : ""}${result.fragment || ""}`, result);
        /**
		 * @param {string[]} log logs
		 * @returns {void}
		 */ const finishWithoutResolve = (log)=>{
            /**
			 * @type {ErrorWithDetail}
			 */ const error = new Error(`Can't ${message}`);
            error.details = log.join("\n");
            this.hooks.noResolve.call(obj, error);
            return callback(error);
        };
        if (resolveContext.log) {
            // We need log anyway to capture it in case of an error
            const parentLog = resolveContext.log;
            /** @type {string[]} */ const log = [];
            return this.doResolve(this.hooks.resolve, obj, message, {
                log: (msg)=>{
                    parentLog(msg);
                    log.push(msg);
                },
                yield: yield_,
                fileDependencies: resolveContext.fileDependencies,
                contextDependencies: resolveContext.contextDependencies,
                missingDependencies: resolveContext.missingDependencies,
                stack: resolveContext.stack
            }, (err, result)=>{
                if (err) return callback(err);
                if (yieldCalled || result && yield_) {
                    return /** @type {ResolveContextYield} */ finishYield(result);
                }
                if (result) return finishResolved(result);
                return finishWithoutResolve(log);
            });
        }
        // Try to resolve assuming there is no error
        // We don't log stuff in this case
        return this.doResolve(this.hooks.resolve, obj, message, {
            log: undefined,
            yield: yield_,
            fileDependencies: resolveContext.fileDependencies,
            contextDependencies: resolveContext.contextDependencies,
            missingDependencies: resolveContext.missingDependencies,
            stack: resolveContext.stack
        }, (err, result)=>{
            if (err) return callback(err);
            if (yieldCalled || result && yield_) {
                return /** @type {ResolveContextYield} */ finishYield(result);
            }
            if (result) return finishResolved(result);
            // log is missing for the error details
            // so we redo the resolving for the log info
            // this is more expensive to the success case
            // is assumed by default
            /** @type {string[]} */ const log = [];
            return this.doResolve(this.hooks.resolve, obj, message, {
                log: (msg)=>log.push(msg),
                yield: yield_,
                stack: resolveContext.stack
            }, (err, result)=>{
                if (err) return callback(err);
                // In a case that there is a race condition and yield will be called
                if (yieldCalled || result && yield_) {
                    return /** @type {ResolveContextYield} */ finishYield(result);
                }
                return finishWithoutResolve(log);
            });
        });
    }
    /**
	 * @param {ResolveStepHook} hook hook
	 * @param {ResolveRequest} request request
	 * @param {null|string} message string
	 * @param {ResolveContext} resolveContext resolver context
	 * @param {(err?: null|Error, result?: ResolveRequest) => void} callback callback
	 * @returns {void}
	 */ doResolve(hook, request, message, resolveContext, callback) {
        const stackEntry = Resolver.createStackEntry(hook, request);
        /** @type {Set<string> | undefined} */ let newStack;
        if (resolveContext.stack) {
            newStack = new Set(resolveContext.stack);
            if (resolveContext.stack.has(stackEntry)) {
                /**
				 * Prevent recursion
				 * @type {Error & {recursion?: boolean}}
				 */ const recursionError = new Error(`Recursion in resolving\nStack:\n  ${[
                    ...newStack
                ].join("\n  ")}`);
                recursionError.recursion = true;
                if (resolveContext.log) {
                    resolveContext.log("abort resolving because of recursion");
                }
                return callback(recursionError);
            }
            newStack.add(stackEntry);
        } else {
            // creating a set with new Set([item])
            // allocates a new array that has to be garbage collected
            // this is an EXTREMELY hot path, so let's avoid it
            newStack = new Set();
            newStack.add(stackEntry);
        }
        this.hooks.resolveStep.call(hook, request);
        if (hook.isUsed()) {
            const innerContext = createInnerContext({
                log: resolveContext.log,
                yield: resolveContext.yield,
                fileDependencies: resolveContext.fileDependencies,
                contextDependencies: resolveContext.contextDependencies,
                missingDependencies: resolveContext.missingDependencies,
                stack: newStack
            }, message);
            return hook.callAsync(request, innerContext, (err, result)=>{
                if (err) return callback(err);
                if (result) return callback(null, result);
                callback();
            });
        }
        callback();
    }
    /**
	 * @param {string} identifier identifier
	 * @returns {ParsedIdentifier} parsed identifier
	 */ parse(identifier) {
        const part = {
            request: "",
            query: "",
            fragment: "",
            module: false,
            directory: false,
            file: false,
            internal: false
        };
        const parsedIdentifier = parseIdentifier(identifier);
        if (!parsedIdentifier) return part;
        [part.request, part.query, part.fragment] = parsedIdentifier;
        if (part.request.length > 0) {
            part.internal = this.isPrivate(identifier);
            part.module = this.isModule(part.request);
            part.directory = this.isDirectory(part.request);
            if (part.directory) {
                part.request = part.request.slice(0, -1);
            }
        }
        return part;
    }
    /**
	 * @param {string} path path
	 * @returns {boolean} true, if the path is a module
	 */ isModule(path) {
        return getType(path) === PathType.Normal;
    }
    /**
	 * @param {string} path path
	 * @returns {boolean} true, if the path is private
	 */ isPrivate(path) {
        return getType(path) === PathType.Internal;
    }
    /**
	 * @param {string} path a path
	 * @returns {boolean} true, if the path is a directory path
	 */ isDirectory(path) {
        return path.endsWith("/");
    }
    /**
	 * @param {string} path path
	 * @param {string} request request
	 * @returns {string} joined path
	 */ join(path, request) {
        return join(path, request);
    }
    /**
	 * @param {string} path path
	 * @returns {string} normalized path
	 */ normalize(path) {
        return normalize(path);
    }
}
module.exports = Resolver;
}}),
"[project]/node_modules/enhanced-resolve/lib/RestrictionsPlugin.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Ivan Kopeykin @vankop
*/ /** @typedef {import("./Resolver")} Resolver */ /** @typedef {import("./Resolver").ResolveStepHook} ResolveStepHook */ const slashCode = "/".charCodeAt(0);
const backslashCode = "\\".charCodeAt(0);
/**
 * @param {string} path path
 * @param {string} parent parent path
 * @returns {boolean} true, if path is inside of parent
 */ const isInside = (path, parent)=>{
    if (!path.startsWith(parent)) return false;
    if (path.length === parent.length) return true;
    const charCode = path.charCodeAt(parent.length);
    return charCode === slashCode || charCode === backslashCode;
};
module.exports = class RestrictionsPlugin {
    /**
	 * @param {string | ResolveStepHook} source source
	 * @param {Set<string | RegExp>} restrictions restrictions
	 */ constructor(source, restrictions){
        this.source = source;
        this.restrictions = restrictions;
    }
    /**
	 * @param {Resolver} resolver the resolver
	 * @returns {void}
	 */ apply(resolver) {
        resolver.getHook(this.source).tapAsync("RestrictionsPlugin", (request, resolveContext, callback)=>{
            if (typeof request.path === "string") {
                const { path } = request;
                for (const rule of this.restrictions){
                    if (typeof rule === "string") {
                        if (!isInside(path, rule)) {
                            if (resolveContext.log) {
                                resolveContext.log(`${path} is not inside of the restriction ${rule}`);
                            }
                            return callback(null, null);
                        }
                    } else if (!rule.test(path)) {
                        if (resolveContext.log) {
                            resolveContext.log(`${path} doesn't match the restriction ${rule}`);
                        }
                        return callback(null, null);
                    }
                }
            }
            callback();
        });
    }
};
}}),
"[project]/node_modules/enhanced-resolve/lib/ResultPlugin.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ /** @typedef {import("./Resolver")} Resolver */ /** @typedef {import("./Resolver").ResolveStepHook} ResolveStepHook */ module.exports = class ResultPlugin {
    /**
	 * @param {ResolveStepHook} source source
	 */ constructor(source){
        this.source = source;
    }
    /**
	 * @param {Resolver} resolver the resolver
	 * @returns {void}
	 */ apply(resolver) {
        this.source.tapAsync("ResultPlugin", (request, resolverContext, callback)=>{
            const obj = {
                ...request
            };
            if (resolverContext.log) {
                resolverContext.log(`reporting result ${obj.path}`);
            }
            resolver.hooks.result.callAsync(obj, resolverContext, (err)=>{
                if (err) return callback(err);
                if (typeof resolverContext.yield === "function") {
                    resolverContext.yield(obj);
                    callback(null, null);
                } else {
                    callback(null, obj);
                }
            });
        });
    }
};
}}),
"[project]/node_modules/enhanced-resolve/lib/RootsPlugin.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Ivan Kopeykin @vankop
*/ const forEachBail = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/forEachBail.js [postcss] (ecmascript)");
/** @typedef {import("./Resolver")} Resolver */ /** @typedef {import("./Resolver").ResolveRequest} ResolveRequest */ /** @typedef {import("./Resolver").ResolveStepHook} ResolveStepHook */ class RootsPlugin {
    /**
	 * @param {string | ResolveStepHook} source source hook
	 * @param {Set<string>} roots roots
	 * @param {string | ResolveStepHook} target target hook
	 */ constructor(source, roots, target){
        this.roots = [
            ...roots
        ];
        this.source = source;
        this.target = target;
    }
    /**
	 * @param {Resolver} resolver the resolver
	 * @returns {void}
	 */ apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("RootsPlugin", (request, resolveContext, callback)=>{
            const req = request.request;
            if (!req) return callback();
            if (!req.startsWith("/")) return callback();
            forEachBail(this.roots, /**
					 * @param {string} root root
					 * @param {(err?: null|Error, result?: null|ResolveRequest) => void} callback callback
					 * @returns {void}
					 */ (root, callback)=>{
                const path = resolver.join(root, req.slice(1));
                /** @type {ResolveRequest} */ const obj = {
                    ...request,
                    path,
                    relativePath: request.relativePath && path
                };
                resolver.doResolve(target, obj, `root path ${root}`, resolveContext, callback);
            }, callback);
        });
    }
}
module.exports = RootsPlugin;
}}),
"[project]/node_modules/enhanced-resolve/lib/SelfReferencePlugin.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const DescriptionFileUtils = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/DescriptionFileUtils.js [postcss] (ecmascript)");
/** @typedef {import("./Resolver")} Resolver */ /** @typedef {import("./Resolver").JsonObject} JsonObject */ /** @typedef {import("./Resolver").ResolveRequest} ResolveRequest */ /** @typedef {import("./Resolver").ResolveStepHook} ResolveStepHook */ const slashCode = "/".charCodeAt(0);
module.exports = class SelfReferencePlugin {
    /**
	 * @param {string | ResolveStepHook} source source
	 * @param {string | string[]} fieldNamePath name path
	 * @param {string | ResolveStepHook} target target
	 */ constructor(source, fieldNamePath, target){
        this.source = source;
        this.target = target;
        this.fieldName = fieldNamePath;
    }
    /**
	 * @param {Resolver} resolver the resolver
	 * @returns {void}
	 */ apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("SelfReferencePlugin", (request, resolveContext, callback)=>{
            if (!request.descriptionFilePath) return callback();
            const req = request.request;
            if (!req) return callback();
            // Feature is only enabled when an exports field is present
            const exportsField = DescriptionFileUtils.getField(request.descriptionFileData, this.fieldName);
            if (!exportsField) return callback();
            const name = DescriptionFileUtils.getField(request.descriptionFileData, "name");
            if (typeof name !== "string") return callback();
            if (req.startsWith(name) && (req.length === name.length || req.charCodeAt(name.length) === slashCode)) {
                const remainingRequest = `.${req.slice(name.length)}`;
                /** @type {ResolveRequest} */ const obj = {
                    ...request,
                    request: remainingRequest,
                    path: request.descriptionFileRoot,
                    relativePath: "."
                };
                resolver.doResolve(target, obj, "self reference", resolveContext, callback);
            } else {
                return callback();
            }
        });
    }
};
}}),
"[project]/node_modules/enhanced-resolve/lib/SymlinkPlugin.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const forEachBail = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/forEachBail.js [postcss] (ecmascript)");
const getPaths = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/getPaths.js [postcss] (ecmascript)");
const { PathType, getType } = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/util/path.js [postcss] (ecmascript)");
/** @typedef {import("./Resolver")} Resolver */ /** @typedef {import("./Resolver").ResolveRequest} ResolveRequest */ /** @typedef {import("./Resolver").ResolveStepHook} ResolveStepHook */ module.exports = class SymlinkPlugin {
    /**
	 * @param {string | ResolveStepHook} source source
	 * @param {string | ResolveStepHook} target target
	 */ constructor(source, target){
        this.source = source;
        this.target = target;
    }
    /**
	 * @param {Resolver} resolver the resolver
	 * @returns {void}
	 */ apply(resolver) {
        const target = resolver.ensureHook(this.target);
        const fs = resolver.fileSystem;
        resolver.getHook(this.source).tapAsync("SymlinkPlugin", (request, resolveContext, callback)=>{
            if (request.ignoreSymlinks) return callback();
            const pathsResult = getPaths(request.path);
            const pathSegments = pathsResult.segments;
            const { paths } = pathsResult;
            let containsSymlink = false;
            let idx = -1;
            forEachBail(paths, /**
					 * @param {string} path path
					 * @param {(err?: null|Error, result?: null|number) => void} callback callback
					 * @returns {void}
					 */ (path, callback)=>{
                idx++;
                if (resolveContext.fileDependencies) {
                    resolveContext.fileDependencies.add(path);
                }
                fs.readlink(path, (err, result)=>{
                    if (!err && result) {
                        pathSegments[idx] = result;
                        containsSymlink = true;
                        // Shortcut when absolute symlink found
                        const resultType = getType(result.toString());
                        if (resultType === PathType.AbsoluteWin || resultType === PathType.AbsolutePosix) {
                            return callback(null, idx);
                        }
                    }
                    callback();
                });
            }, /**
					 * @param {(null | Error)=} err error
					 * @param {(null|number)=} idx result
					 * @returns {void}
					 */ (err, idx)=>{
                if (!containsSymlink) return callback();
                const resultSegments = typeof idx === "number" ? pathSegments.slice(0, idx + 1) : [
                    ...pathSegments
                ];
                const result = resultSegments.reduceRight((a, b)=>resolver.join(a, b));
                /** @type {ResolveRequest} */ const obj = {
                    ...request,
                    path: result
                };
                resolver.doResolve(target, obj, `resolved symlink to ${result}`, resolveContext, callback);
            });
        });
    }
};
}}),
"[project]/node_modules/enhanced-resolve/lib/SyncAsyncFileSystemDecorator.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ /** @typedef {import("./Resolver").FileSystem} FileSystem */ /** @typedef {import("./Resolver").StringCallback} StringCallback */ /** @typedef {import("./Resolver").SyncFileSystem} SyncFileSystem */ // eslint-disable-next-line jsdoc/no-restricted-syntax
/** @typedef {Function} SyncOrAsyncFunction */ // eslint-disable-next-line jsdoc/no-restricted-syntax
/** @typedef {any} ResultOfSyncOrAsyncFunction */ /**
 * @param {SyncFileSystem} fs file system implementation
 * @constructor
 */ function SyncAsyncFileSystemDecorator(fs) {
    this.fs = fs;
    this.lstat = undefined;
    this.lstatSync = undefined;
    const { lstatSync } = fs;
    if (lstatSync) {
        this.lstat = (arg, options, callback)=>{
            let result;
            try {
                result = /** @type {SyncOrAsyncFunction | undefined} */ callback ? lstatSync.call(fs, arg, options) : lstatSync.call(fs, arg);
            } catch (err) {
                return (callback || options)(err);
            }
            (callback || options)(null, result);
        };
        this.lstatSync = (arg, options)=>lstatSync.call(fs, arg, options);
    }
    this.stat = (arg, options, callback)=>{
        let result;
        try {
            result = /** @type {SyncOrAsyncFunction | undefined} */ callback ? fs.statSync(arg, options) : fs.statSync(arg);
        } catch (err) {
            return (callback || options)(err);
        }
        (callback || options)(null, result);
    };
    this.statSync = (arg, options)=>fs.statSync(arg, options);
    this.readdir = (arg, options, callback)=>{
        let result;
        try {
            result = /** @type {SyncOrAsyncFunction | undefined} */ callback ? fs.readdirSync(arg, options) : fs.readdirSync(arg);
        } catch (err) {
            return (callback || options)(err, []);
        }
        (callback || options)(null, result);
    };
    this.readdirSync = (arg, options)=>fs.readdirSync(arg, options);
    this.readFile = (arg, options, callback)=>{
        let result;
        try {
            result = /** @type {SyncOrAsyncFunction | undefined} */ callback ? fs.readFileSync(arg, options) : fs.readFileSync(arg);
        } catch (err) {
            return (callback || options)(err);
        }
        (callback || options)(null, result);
    };
    this.readFileSync = (arg, options)=>fs.readFileSync(arg, options);
    this.readlink = (arg, options, callback)=>{
        let result;
        try {
            result = /** @type {SyncOrAsyncFunction | undefined} */ callback ? fs.readlinkSync(arg, options) : fs.readlinkSync(arg);
        } catch (err) {
            return (callback || options)(err);
        }
        (callback || options)(null, result);
    };
    this.readlinkSync = (arg, options)=>fs.readlinkSync(arg, options);
    this.readJson = undefined;
    this.readJsonSync = undefined;
    const { readJsonSync } = fs;
    if (readJsonSync) {
        this.readJson = (arg, callback)=>{
            let result;
            try {
                result = readJsonSync.call(fs, arg);
            } catch (err) {
                return callback(err);
            }
            callback(null, result);
        };
        this.readJsonSync = (arg)=>readJsonSync.call(fs, arg);
    }
    this.realpath = undefined;
    this.realpathSync = undefined;
    const { realpathSync } = fs;
    if (realpathSync) {
        this.realpath = (arg, options, callback)=>{
            let result;
            try {
                result = /** @type {SyncOrAsyncFunction | undefined} */ callback ? realpathSync.call(fs, arg, options) : realpathSync.call(fs, arg);
            } catch (err) {
                return (callback || options)(err);
            }
            (callback || options)(null, result);
        };
        this.realpathSync = (arg, options)=>realpathSync.call(fs, arg, options);
    }
}
module.exports = SyncAsyncFileSystemDecorator;
}}),
"[project]/node_modules/enhanced-resolve/lib/TryNextPlugin.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ /** @typedef {import("./Resolver")} Resolver */ /** @typedef {import("./Resolver").ResolveStepHook} ResolveStepHook */ module.exports = class TryNextPlugin {
    /**
	 * @param {string | ResolveStepHook} source source
	 * @param {string} message message
	 * @param {string | ResolveStepHook} target target
	 */ constructor(source, message, target){
        this.source = source;
        this.message = message;
        this.target = target;
    }
    /**
	 * @param {Resolver} resolver the resolver
	 * @returns {void}
	 */ apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("TryNextPlugin", (request, resolveContext, callback)=>{
            resolver.doResolve(target, request, this.message, resolveContext, callback);
        });
    }
};
}}),
"[project]/node_modules/enhanced-resolve/lib/UnsafeCachePlugin.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ /** @typedef {import("./Resolver")} Resolver */ /** @typedef {import("./Resolver").ResolveRequest} ResolveRequest */ /** @typedef {import("./Resolver").ResolveStepHook} ResolveStepHook */ /** @typedef {import("./Resolver").ResolveContextYield} ResolveContextYield */ /** @typedef {{ [k: string]: undefined | ResolveRequest | ResolveRequest[] }} Cache */ /**
 * @param {string} type type of cache
 * @param {ResolveRequest} request request
 * @param {boolean} withContext cache with context?
 * @returns {string} cache id
 */ function getCacheId(type, request, withContext) {
    return JSON.stringify({
        type,
        context: withContext ? request.context : "",
        path: request.path,
        query: request.query,
        fragment: request.fragment,
        request: request.request
    });
}
module.exports = class UnsafeCachePlugin {
    /**
	 * @param {string | ResolveStepHook} source source
	 * @param {(request: ResolveRequest) => boolean} filterPredicate filterPredicate
	 * @param {Cache} cache cache
	 * @param {boolean} withContext withContext
	 * @param {string | ResolveStepHook} target target
	 */ constructor(source, filterPredicate, cache, withContext, target){
        this.source = source;
        this.filterPredicate = filterPredicate;
        this.withContext = withContext;
        this.cache = cache;
        this.target = target;
    }
    /**
	 * @param {Resolver} resolver the resolver
	 * @returns {void}
	 */ apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("UnsafeCachePlugin", (request, resolveContext, callback)=>{
            if (!this.filterPredicate(request)) return callback();
            const isYield = typeof resolveContext.yield === "function";
            const cacheId = getCacheId(isYield ? "yield" : "default", request, this.withContext);
            const cacheEntry = this.cache[cacheId];
            if (cacheEntry) {
                if (isYield) {
                    const yield_ = resolveContext.yield;
                    if (Array.isArray(cacheEntry)) {
                        for (const result of cacheEntry)yield_(result);
                    } else {
                        yield_(cacheEntry);
                    }
                    return callback(null, null);
                }
                return callback(null, cacheEntry);
            }
            /** @type {ResolveContextYield | undefined} */ let yieldFn;
            /** @type {ResolveContextYield | undefined} */ let yield_;
            /** @type {ResolveRequest[]} */ const yieldResult = [];
            if (isYield) {
                yieldFn = resolveContext.yield;
                yield_ = (result)=>{
                    yieldResult.push(result);
                };
            }
            resolver.doResolve(target, request, null, yield_ ? {
                ...resolveContext,
                yield: yield_
            } : resolveContext, (err, result)=>{
                if (err) return callback(err);
                if (isYield) {
                    if (result) yieldResult.push(result);
                    for (const result of yieldResult){
                        /** @type {ResolveContextYield} */ yieldFn(result);
                    }
                    this.cache[cacheId] = yieldResult;
                    return callback(null, null);
                }
                if (result) return callback(null, this.cache[cacheId] = result);
                callback();
            });
        });
    }
};
}}),
"[project]/node_modules/enhanced-resolve/lib/UseFilePlugin.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ /** @typedef {import("./Resolver")} Resolver */ /** @typedef {import("./Resolver").ResolveRequest} ResolveRequest */ /** @typedef {import("./Resolver").ResolveStepHook} ResolveStepHook */ module.exports = class UseFilePlugin {
    /**
	 * @param {string | ResolveStepHook} source source
	 * @param {string} filename filename
	 * @param {string | ResolveStepHook} target target
	 */ constructor(source, filename, target){
        this.source = source;
        this.filename = filename;
        this.target = target;
    }
    /**
	 * @param {Resolver} resolver the resolver
	 * @returns {void}
	 */ apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("UseFilePlugin", (request, resolveContext, callback)=>{
            const filePath = resolver.join(request.path, this.filename);
            /** @type {ResolveRequest} */ const obj = {
                ...request,
                path: filePath,
                relativePath: request.relativePath && resolver.join(request.relativePath, this.filename)
            };
            resolver.doResolve(target, obj, `using path: ${filePath}`, resolveContext, callback);
        });
    }
};
}}),
"[project]/node_modules/enhanced-resolve/lib/ResolverFactory.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ // eslint-disable-next-line n/prefer-global/process
const { versions } = __turbopack_context__.r("[externals]/process [external] (process, cjs)");
const AliasFieldPlugin = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/AliasFieldPlugin.js [postcss] (ecmascript)");
const AliasPlugin = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/AliasPlugin.js [postcss] (ecmascript)");
const AppendPlugin = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/AppendPlugin.js [postcss] (ecmascript)");
const ConditionalPlugin = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/ConditionalPlugin.js [postcss] (ecmascript)");
const DescriptionFilePlugin = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/DescriptionFilePlugin.js [postcss] (ecmascript)");
const DirectoryExistsPlugin = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/DirectoryExistsPlugin.js [postcss] (ecmascript)");
const ExportsFieldPlugin = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/ExportsFieldPlugin.js [postcss] (ecmascript)");
const ExtensionAliasPlugin = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/ExtensionAliasPlugin.js [postcss] (ecmascript)");
const FileExistsPlugin = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/FileExistsPlugin.js [postcss] (ecmascript)");
const ImportsFieldPlugin = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/ImportsFieldPlugin.js [postcss] (ecmascript)");
const JoinRequestPartPlugin = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/JoinRequestPartPlugin.js [postcss] (ecmascript)");
const JoinRequestPlugin = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/JoinRequestPlugin.js [postcss] (ecmascript)");
const MainFieldPlugin = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/MainFieldPlugin.js [postcss] (ecmascript)");
const ModulesInHierarchicalDirectoriesPlugin = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/ModulesInHierarchicalDirectoriesPlugin.js [postcss] (ecmascript)");
const ModulesInRootPlugin = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/ModulesInRootPlugin.js [postcss] (ecmascript)");
const NextPlugin = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/NextPlugin.js [postcss] (ecmascript)");
const ParsePlugin = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/ParsePlugin.js [postcss] (ecmascript)");
const PnpPlugin = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/PnpPlugin.js [postcss] (ecmascript)");
const Resolver = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/Resolver.js [postcss] (ecmascript)");
const RestrictionsPlugin = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/RestrictionsPlugin.js [postcss] (ecmascript)");
const ResultPlugin = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/ResultPlugin.js [postcss] (ecmascript)");
const RootsPlugin = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/RootsPlugin.js [postcss] (ecmascript)");
const SelfReferencePlugin = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/SelfReferencePlugin.js [postcss] (ecmascript)");
const SymlinkPlugin = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/SymlinkPlugin.js [postcss] (ecmascript)");
const SyncAsyncFileSystemDecorator = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/SyncAsyncFileSystemDecorator.js [postcss] (ecmascript)");
const TryNextPlugin = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/TryNextPlugin.js [postcss] (ecmascript)");
const UnsafeCachePlugin = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/UnsafeCachePlugin.js [postcss] (ecmascript)");
const UseFilePlugin = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/UseFilePlugin.js [postcss] (ecmascript)");
const { PathType, getType } = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/util/path.js [postcss] (ecmascript)");
/** @typedef {import("./AliasPlugin").AliasOption} AliasOptionEntry */ /** @typedef {import("./ExtensionAliasPlugin").ExtensionAliasOption} ExtensionAliasOption */ /** @typedef {import("./PnpPlugin").PnpApiImpl} PnpApi */ /** @typedef {import("./Resolver").EnsuredHooks} EnsuredHooks */ /** @typedef {import("./Resolver").FileSystem} FileSystem */ /** @typedef {import("./Resolver").KnownHooks} KnownHooks */ /** @typedef {import("./Resolver").ResolveRequest} ResolveRequest */ /** @typedef {import("./Resolver").SyncFileSystem} SyncFileSystem */ /** @typedef {import("./UnsafeCachePlugin").Cache} Cache */ /** @typedef {string | string[] | false} AliasOptionNewRequest */ /** @typedef {{ [k: string]: AliasOptionNewRequest }} AliasOptions */ /** @typedef {{ [k: string]: string|string[] }} ExtensionAliasOptions */ /** @typedef {false | 0 | "" | null | undefined} Falsy */ /** @typedef {{apply: (resolver: Resolver) => void} | ((this: Resolver, resolver: Resolver) => void) | Falsy} Plugin */ /**
 * @typedef {object} UserResolveOptions
 * @property {(AliasOptions | AliasOptionEntry[])=} alias A list of module alias configurations or an object which maps key to value
 * @property {(AliasOptions | AliasOptionEntry[])=} fallback A list of module alias configurations or an object which maps key to value, applied only after modules option
 * @property {ExtensionAliasOptions=} extensionAlias An object which maps extension to extension aliases
 * @property {(string | string[])[]=} aliasFields A list of alias fields in description files
 * @property {((predicate: ResolveRequest) => boolean)=} cachePredicate A function which decides whether a request should be cached or not. An object is passed with at least `path` and `request` properties.
 * @property {boolean=} cacheWithContext Whether or not the unsafeCache should include request context as part of the cache key.
 * @property {string[]=} descriptionFiles A list of description files to read from
 * @property {string[]=} conditionNames A list of exports field condition names.
 * @property {boolean=} enforceExtension Enforce that a extension from extensions must be used
 * @property {(string | string[])[]=} exportsFields A list of exports fields in description files
 * @property {(string | string[])[]=} importsFields A list of imports fields in description files
 * @property {string[]=} extensions A list of extensions which should be tried for files
 * @property {FileSystem} fileSystem The file system which should be used
 * @property {(Cache | boolean)=} unsafeCache Use this cache object to unsafely cache the successful requests
 * @property {boolean=} symlinks Resolve symlinks to their symlinked location
 * @property {Resolver=} resolver A prepared Resolver to which the plugins are attached
 * @property {string[] | string=} modules A list of directories to resolve modules from, can be absolute path or folder name
 * @property {(string | string[] | {name: string | string[], forceRelative: boolean})[]=} mainFields A list of main fields in description files
 * @property {string[]=} mainFiles A list of main files in directories
 * @property {Plugin[]=} plugins A list of additional resolve plugins which should be applied
 * @property {PnpApi | null=} pnpApi A PnP API that should be used - null is "never", undefined is "auto"
 * @property {string[]=} roots A list of root paths
 * @property {boolean=} fullySpecified The request is already fully specified and no extensions or directories are resolved for it
 * @property {boolean=} resolveToContext Resolve to a context instead of a file
 * @property {(string|RegExp)[]=} restrictions A list of resolve restrictions
 * @property {boolean=} useSyncFileSystemCalls Use only the sync constraints of the file system calls
 * @property {boolean=} preferRelative Prefer to resolve module requests as relative requests before falling back to modules
 * @property {boolean=} preferAbsolute Prefer to resolve server-relative urls as absolute paths before falling back to resolve in roots
 */ /**
 * @typedef {object} ResolveOptions
 * @property {AliasOptionEntry[]} alias alias
 * @property {AliasOptionEntry[]} fallback fallback
 * @property {Set<string | string[]>} aliasFields alias fields
 * @property {ExtensionAliasOption[]} extensionAlias extension alias
 * @property {(predicate: ResolveRequest) => boolean} cachePredicate cache predicate
 * @property {boolean} cacheWithContext cache with context
 * @property {Set<string>} conditionNames A list of exports field condition names.
 * @property {string[]} descriptionFiles description files
 * @property {boolean} enforceExtension enforce extension
 * @property {Set<string | string[]>} exportsFields exports fields
 * @property {Set<string | string[]>} importsFields imports fields
 * @property {Set<string>} extensions extensions
 * @property {FileSystem} fileSystem fileSystem
 * @property {Cache | false} unsafeCache unsafe cache
 * @property {boolean} symlinks symlinks
 * @property {Resolver=} resolver resolver
 * @property {Array<string | string[]>} modules modules
 * @property {{ name: string[], forceRelative: boolean }[]} mainFields main fields
 * @property {Set<string>} mainFiles main files
 * @property {Plugin[]} plugins plugins
 * @property {PnpApi | null} pnpApi pnp API
 * @property {Set<string>} roots roots
 * @property {boolean} fullySpecified fully specified
 * @property {boolean} resolveToContext resolve to context
 * @property {Set<string | RegExp>} restrictions restrictions
 * @property {boolean} preferRelative prefer relative
 * @property {boolean} preferAbsolute prefer absolute
 */ /**
 * @param {PnpApi | null=} option option
 * @returns {PnpApi | null} processed option
 */ function processPnpApiOption(option) {
    if (option === undefined && /** @type {NodeJS.ProcessVersions & {pnp: string}} */ versions.pnp) {
        const _findPnpApi = // @ts-expect-error maybe nothing
        __turbopack_context__.r("[externals]/module [external] (module, cjs)").findPnpApi;
        if (_findPnpApi) {
            return {
                resolveToUnqualified (request, issuer, opts) {
                    const pnpapi = _findPnpApi(issuer);
                    if (!pnpapi) {
                        // Issuer isn't managed by PnP
                        return null;
                    }
                    return pnpapi.resolveToUnqualified(request, issuer, opts);
                }
            };
        }
    }
    return option || null;
}
/**
 * @param {AliasOptions | AliasOptionEntry[] | undefined} alias alias
 * @returns {AliasOptionEntry[]} normalized aliases
 */ function normalizeAlias(alias) {
    return typeof alias === "object" && !Array.isArray(alias) && alias !== null ? Object.keys(alias).map((key)=>{
        /** @type {AliasOptionEntry} */ const obj = {
            name: key,
            onlyModule: false,
            alias: alias[key]
        };
        if (/\$$/.test(key)) {
            obj.onlyModule = true;
            obj.name = key.slice(0, -1);
        }
        return obj;
    }) : /** @type {Array<AliasOptionEntry>} */ alias || [];
}
/**
 * Merging filtered elements
 * @param {string[]} array source array
 * @param {(item: string) => boolean} filter predicate
 * @returns {Array<string | string[]>} merge result
 */ function mergeFilteredToArray(array, filter) {
    /** @type {Array<string | string[]>} */ const result = [];
    const set = new Set(array);
    for (const item of set){
        if (filter(item)) {
            const lastElement = result.length > 0 ? result[result.length - 1] : undefined;
            if (Array.isArray(lastElement)) {
                lastElement.push(item);
            } else {
                result.push([
                    item
                ]);
            }
        } else {
            result.push(item);
        }
    }
    return result;
}
/**
 * @param {UserResolveOptions} options input options
 * @returns {ResolveOptions} output options
 */ function createOptions(options) {
    const mainFieldsSet = new Set(options.mainFields || [
        "main"
    ]);
    /** @type {ResolveOptions["mainFields"]} */ const mainFields = [];
    for (const item of mainFieldsSet){
        if (typeof item === "string") {
            mainFields.push({
                name: [
                    item
                ],
                forceRelative: true
            });
        } else if (Array.isArray(item)) {
            mainFields.push({
                name: item,
                forceRelative: true
            });
        } else {
            mainFields.push({
                name: Array.isArray(item.name) ? item.name : [
                    item.name
                ],
                forceRelative: item.forceRelative
            });
        }
    }
    return {
        alias: normalizeAlias(options.alias),
        fallback: normalizeAlias(options.fallback),
        aliasFields: new Set(options.aliasFields),
        cachePredicate: options.cachePredicate || function trueFn() {
            return true;
        },
        cacheWithContext: typeof options.cacheWithContext !== "undefined" ? options.cacheWithContext : true,
        exportsFields: new Set(options.exportsFields || [
            "exports"
        ]),
        importsFields: new Set(options.importsFields || [
            "imports"
        ]),
        conditionNames: new Set(options.conditionNames),
        descriptionFiles: [
            ...new Set(options.descriptionFiles || [
                "package.json"
            ])
        ],
        enforceExtension: options.enforceExtension === undefined ? Boolean(options.extensions && options.extensions.includes("")) : options.enforceExtension,
        extensions: new Set(options.extensions || [
            ".js",
            ".json",
            ".node"
        ]),
        extensionAlias: options.extensionAlias ? Object.keys(options.extensionAlias).map((k)=>({
                extension: k,
                alias: /** @type {ExtensionAliasOptions} */ options.extensionAlias[k]
            })) : [],
        fileSystem: options.useSyncFileSystemCalls ? new SyncAsyncFileSystemDecorator(options.fileSystem) : options.fileSystem,
        unsafeCache: options.unsafeCache && typeof options.unsafeCache !== "object" ? {} : options.unsafeCache || false,
        symlinks: typeof options.symlinks !== "undefined" ? options.symlinks : true,
        resolver: options.resolver,
        modules: mergeFilteredToArray(Array.isArray(options.modules) ? options.modules : options.modules ? [
            options.modules
        ] : [
            "node_modules"
        ], (item)=>{
            const type = getType(item);
            return type === PathType.Normal || type === PathType.Relative;
        }),
        mainFields,
        mainFiles: new Set(options.mainFiles || [
            "index"
        ]),
        plugins: options.plugins || [],
        pnpApi: processPnpApiOption(options.pnpApi),
        roots: new Set(options.roots || undefined),
        fullySpecified: options.fullySpecified || false,
        resolveToContext: options.resolveToContext || false,
        preferRelative: options.preferRelative || false,
        preferAbsolute: options.preferAbsolute || false,
        restrictions: new Set(options.restrictions)
    };
}
/**
 * @param {UserResolveOptions} options resolve options
 * @returns {Resolver} created resolver
 */ module.exports.createResolver = function createResolver(options) {
    const normalizedOptions = createOptions(options);
    const { alias, fallback, aliasFields, cachePredicate, cacheWithContext, conditionNames, descriptionFiles, enforceExtension, exportsFields, extensionAlias, importsFields, extensions, fileSystem, fullySpecified, mainFields, mainFiles, modules, plugins: userPlugins, pnpApi, resolveToContext, preferRelative, preferAbsolute, symlinks, unsafeCache, resolver: customResolver, restrictions, roots } = normalizedOptions;
    const plugins = [
        ...userPlugins
    ];
    const resolver = customResolver || new Resolver(fileSystem, normalizedOptions);
    // // pipeline ////
    resolver.ensureHook("resolve");
    resolver.ensureHook("internalResolve");
    resolver.ensureHook("newInternalResolve");
    resolver.ensureHook("parsedResolve");
    resolver.ensureHook("describedResolve");
    resolver.ensureHook("rawResolve");
    resolver.ensureHook("normalResolve");
    resolver.ensureHook("internal");
    resolver.ensureHook("rawModule");
    resolver.ensureHook("alternateRawModule");
    resolver.ensureHook("module");
    resolver.ensureHook("resolveAsModule");
    resolver.ensureHook("undescribedResolveInPackage");
    resolver.ensureHook("resolveInPackage");
    resolver.ensureHook("resolveInExistingDirectory");
    resolver.ensureHook("relative");
    resolver.ensureHook("describedRelative");
    resolver.ensureHook("directory");
    resolver.ensureHook("undescribedExistingDirectory");
    resolver.ensureHook("existingDirectory");
    resolver.ensureHook("undescribedRawFile");
    resolver.ensureHook("rawFile");
    resolver.ensureHook("file");
    resolver.ensureHook("finalFile");
    resolver.ensureHook("existingFile");
    resolver.ensureHook("resolved");
    // TODO remove in next major
    // cspell:word Interal
    // Backward-compat
    // @ts-expect-error
    resolver.hooks.newInteralResolve = resolver.hooks.newInternalResolve;
    // resolve
    for (const { source, resolveOptions } of [
        {
            source: "resolve",
            resolveOptions: {
                fullySpecified
            }
        },
        {
            source: "internal-resolve",
            resolveOptions: {
                fullySpecified: false
            }
        }
    ]){
        if (unsafeCache) {
            plugins.push(new UnsafeCachePlugin(source, cachePredicate, unsafeCache, cacheWithContext, `new-${source}`));
            plugins.push(new ParsePlugin(`new-${source}`, resolveOptions, "parsed-resolve"));
        } else {
            plugins.push(new ParsePlugin(source, resolveOptions, "parsed-resolve"));
        }
    }
    // parsed-resolve
    plugins.push(new DescriptionFilePlugin("parsed-resolve", descriptionFiles, false, "described-resolve"));
    plugins.push(new NextPlugin("after-parsed-resolve", "described-resolve"));
    // described-resolve
    plugins.push(new NextPlugin("described-resolve", "raw-resolve"));
    if (fallback.length > 0) {
        plugins.push(new AliasPlugin("described-resolve", fallback, "internal-resolve"));
    }
    // raw-resolve
    if (alias.length > 0) {
        plugins.push(new AliasPlugin("raw-resolve", alias, "internal-resolve"));
    }
    for (const item of aliasFields){
        plugins.push(new AliasFieldPlugin("raw-resolve", item, "internal-resolve"));
    }
    for (const item of extensionAlias){
        plugins.push(new ExtensionAliasPlugin("raw-resolve", item, "normal-resolve"));
    }
    plugins.push(new NextPlugin("raw-resolve", "normal-resolve"));
    // normal-resolve
    if (preferRelative) {
        plugins.push(new JoinRequestPlugin("after-normal-resolve", "relative"));
    }
    plugins.push(new ConditionalPlugin("after-normal-resolve", {
        module: true
    }, "resolve as module", false, "raw-module"));
    plugins.push(new ConditionalPlugin("after-normal-resolve", {
        internal: true
    }, "resolve as internal import", false, "internal"));
    if (preferAbsolute) {
        plugins.push(new JoinRequestPlugin("after-normal-resolve", "relative"));
    }
    if (roots.size > 0) {
        plugins.push(new RootsPlugin("after-normal-resolve", roots, "relative"));
    }
    if (!preferRelative && !preferAbsolute) {
        plugins.push(new JoinRequestPlugin("after-normal-resolve", "relative"));
    }
    // internal
    for (const importsField of importsFields){
        plugins.push(new ImportsFieldPlugin("internal", conditionNames, importsField, "relative", "internal-resolve"));
    }
    // raw-module
    for (const exportsField of exportsFields){
        plugins.push(new SelfReferencePlugin("raw-module", exportsField, "resolve-as-module"));
    }
    for (const item of modules){
        if (Array.isArray(item)) {
            if (item.includes("node_modules") && pnpApi) {
                plugins.push(new ModulesInHierarchicalDirectoriesPlugin("raw-module", item.filter((i)=>i !== "node_modules"), "module"));
                plugins.push(new PnpPlugin("raw-module", pnpApi, "undescribed-resolve-in-package", "alternate-raw-module"));
                plugins.push(new ModulesInHierarchicalDirectoriesPlugin("alternate-raw-module", [
                    "node_modules"
                ], "module"));
            } else {
                plugins.push(new ModulesInHierarchicalDirectoriesPlugin("raw-module", item, "module"));
            }
        } else {
            plugins.push(new ModulesInRootPlugin("raw-module", item, "module"));
        }
    }
    // module
    plugins.push(new JoinRequestPartPlugin("module", "resolve-as-module"));
    // resolve-as-module
    if (!resolveToContext) {
        plugins.push(new ConditionalPlugin("resolve-as-module", {
            directory: false,
            request: "."
        }, "single file module", true, "undescribed-raw-file"));
    }
    plugins.push(new DirectoryExistsPlugin("resolve-as-module", "undescribed-resolve-in-package"));
    // undescribed-resolve-in-package
    plugins.push(new DescriptionFilePlugin("undescribed-resolve-in-package", descriptionFiles, false, "resolve-in-package"));
    plugins.push(new NextPlugin("after-undescribed-resolve-in-package", "resolve-in-package"));
    // resolve-in-package
    for (const exportsField of exportsFields){
        plugins.push(new ExportsFieldPlugin("resolve-in-package", conditionNames, exportsField, "relative"));
    }
    plugins.push(new NextPlugin("resolve-in-package", "resolve-in-existing-directory"));
    // resolve-in-existing-directory
    plugins.push(new JoinRequestPlugin("resolve-in-existing-directory", "relative"));
    // relative
    plugins.push(new DescriptionFilePlugin("relative", descriptionFiles, true, "described-relative"));
    plugins.push(new NextPlugin("after-relative", "described-relative"));
    // described-relative
    if (resolveToContext) {
        plugins.push(new NextPlugin("described-relative", "directory"));
    } else {
        plugins.push(new ConditionalPlugin("described-relative", {
            directory: false
        }, null, true, "raw-file"));
        plugins.push(new ConditionalPlugin("described-relative", {
            fullySpecified: false
        }, "as directory", true, "directory"));
    }
    // directory
    plugins.push(new DirectoryExistsPlugin("directory", "undescribed-existing-directory"));
    if (resolveToContext) {
        // undescribed-existing-directory
        plugins.push(new NextPlugin("undescribed-existing-directory", "resolved"));
    } else {
        // undescribed-existing-directory
        plugins.push(new DescriptionFilePlugin("undescribed-existing-directory", descriptionFiles, false, "existing-directory"));
        for (const item of mainFiles){
            plugins.push(new UseFilePlugin("undescribed-existing-directory", item, "undescribed-raw-file"));
        }
        // described-existing-directory
        for (const item of mainFields){
            plugins.push(new MainFieldPlugin("existing-directory", item, "resolve-in-existing-directory"));
        }
        for (const item of mainFiles){
            plugins.push(new UseFilePlugin("existing-directory", item, "undescribed-raw-file"));
        }
        // undescribed-raw-file
        plugins.push(new DescriptionFilePlugin("undescribed-raw-file", descriptionFiles, true, "raw-file"));
        plugins.push(new NextPlugin("after-undescribed-raw-file", "raw-file"));
        // raw-file
        plugins.push(new ConditionalPlugin("raw-file", {
            fullySpecified: true
        }, null, false, "file"));
        if (!enforceExtension) {
            plugins.push(new TryNextPlugin("raw-file", "no extension", "file"));
        }
        for (const item of extensions){
            plugins.push(new AppendPlugin("raw-file", item, "file"));
        }
        // file
        if (alias.length > 0) {
            plugins.push(new AliasPlugin("file", alias, "internal-resolve"));
        }
        for (const item of aliasFields){
            plugins.push(new AliasFieldPlugin("file", item, "internal-resolve"));
        }
        plugins.push(new NextPlugin("file", "final-file"));
        // final-file
        plugins.push(new FileExistsPlugin("final-file", "existing-file"));
        // existing-file
        if (symlinks) {
            plugins.push(new SymlinkPlugin("existing-file", "existing-file"));
        }
        plugins.push(new NextPlugin("existing-file", "resolved"));
    }
    const { resolved } = resolver.hooks;
    // resolved
    if (restrictions.size > 0) {
        plugins.push(new RestrictionsPlugin(resolved, restrictions));
    }
    plugins.push(new ResultPlugin(resolved));
    // // RESOLVER ////
    for (const plugin of plugins){
        if (typeof plugin === "function") {
            /** @type {(this: Resolver, resolver: Resolver) => void} */ plugin.call(resolver, resolver);
        } else if (plugin) {
            plugin.apply(resolver);
        }
    }
    return resolver;
};
}}),
"[project]/node_modules/enhanced-resolve/lib/index.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const memoize = __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/util/memoize.js [postcss] (ecmascript)");
/** @typedef {import("./CachedInputFileSystem").BaseFileSystem} BaseFileSystem */ /** @typedef {import("./PnpPlugin").PnpApiImpl} PnpApi */ /** @typedef {import("./Resolver")} Resolver */ /** @typedef {import("./Resolver").FileSystem} FileSystem */ /** @typedef {import("./Resolver").ResolveCallback} ResolveCallback */ /** @typedef {import("./Resolver").ResolveContext} ResolveContext */ /** @typedef {import("./Resolver").ResolveRequest} ResolveRequest */ /** @typedef {import("./Resolver").SyncFileSystem} SyncFileSystem */ /** @typedef {import("./ResolverFactory").Plugin} Plugin */ /** @typedef {import("./ResolverFactory").UserResolveOptions} ResolveOptions */ /**
 * @typedef {{
 * (context: object, path: string, request: string, resolveContext: ResolveContext, callback: ResolveCallback): void;
 * (context: object, path: string, request: string, callback: ResolveCallback): void;
 * (path: string, request: string, resolveContext: ResolveContext, callback: ResolveCallback): void;
 * (path: string, request: string, callback: ResolveCallback): void;
 * }} ResolveFunctionAsync
 */ /**
 * @typedef {{
 * (context: object, path: string, request: string): string | false;
 * (path: string, request: string): string | false;
 * }} ResolveFunction
 */ const getCachedFileSystem = memoize(()=>__turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/CachedInputFileSystem.js [postcss] (ecmascript)"));
const getNodeFileSystem = memoize(()=>{
    const fs = __turbopack_context__.r("[project]/node_modules/graceful-fs/graceful-fs.js [postcss] (ecmascript)");
    const CachedInputFileSystem = getCachedFileSystem();
    return new CachedInputFileSystem(fs, 4000);
});
const getNodeContext = memoize(()=>({
        environments: [
            "node+es3+es5+process+native"
        ]
    }));
const getResolverFactory = memoize(()=>__turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/ResolverFactory.js [postcss] (ecmascript)"));
const getAsyncResolver = memoize(()=>getResolverFactory().createResolver({
        conditionNames: [
            "node"
        ],
        extensions: [
            ".js",
            ".json",
            ".node"
        ],
        fileSystem: getNodeFileSystem()
    }));
/**
 * @type {ResolveFunctionAsync}
 */ const resolve = /**
	 * @param {object | string} context context
	 * @param {string} path path
	 * @param {string | ResolveContext | ResolveCallback} request request
	 * @param {ResolveContext | ResolveCallback=} resolveContext resolve context
	 * @param {ResolveCallback=} callback callback
	 */ (context, path, request, resolveContext, callback)=>{
    if (typeof context === "string") {
        callback = resolveContext;
        resolveContext = request;
        request = path;
        path = context;
        context = getNodeContext();
    }
    if (typeof callback !== "function") {
        callback = resolveContext;
    }
    getAsyncResolver().resolve(context, path, request, resolveContext, callback);
};
const getSyncResolver = memoize(()=>getResolverFactory().createResolver({
        conditionNames: [
            "node"
        ],
        extensions: [
            ".js",
            ".json",
            ".node"
        ],
        useSyncFileSystemCalls: true,
        fileSystem: getNodeFileSystem()
    }));
/**
 * @type {ResolveFunction}
 */ const resolveSync = /**
	 * @param {object|string} context context
	 * @param {string} path path
	 * @param {string=} request request
	 * @returns {string | false} result
	 */ (context, path, request)=>{
    if (typeof context === "string") {
        request = path;
        path = context;
        context = getNodeContext();
    }
    return getSyncResolver().resolveSync(context, path, request);
};
/** @typedef {Omit<ResolveOptions, "fileSystem"> & Partial<Pick<ResolveOptions, "fileSystem">>} ResolveOptionsOptionalFS */ /**
 * @param {ResolveOptionsOptionalFS} options Resolver options
 * @returns {ResolveFunctionAsync} Resolver function
 */ function create(options) {
    const resolver = getResolverFactory().createResolver({
        fileSystem: getNodeFileSystem(),
        ...options
    });
    /**
	 * @param {object|string} context Custom context
	 * @param {string} path Base path
	 * @param {string|ResolveContext|ResolveCallback} request String to resolve
	 * @param {ResolveContext|ResolveCallback=} resolveContext Resolve context
	 * @param {ResolveCallback=} callback Result callback
	 */ return function create(context, path, request, resolveContext, callback) {
        if (typeof context === "string") {
            callback = resolveContext;
            resolveContext = request;
            request = path;
            path = context;
            context = getNodeContext();
        }
        if (typeof callback !== "function") {
            callback = resolveContext;
        }
        resolver.resolve(context, path, request, resolveContext, callback);
    };
}
/**
 * @param {ResolveOptionsOptionalFS} options Resolver options
 * @returns {ResolveFunction} Resolver function
 */ function createSync(options) {
    const resolver = getResolverFactory().createResolver({
        useSyncFileSystemCalls: true,
        fileSystem: getNodeFileSystem(),
        ...options
    });
    /**
	 * @param {object | string} context custom context
	 * @param {string} path base path
	 * @param {string=} request request to resolve
	 * @returns {string | false} Resolved path or false
	 */ return function createSync(context, path, request) {
        if (typeof context === "string") {
            request = path;
            path = context;
            context = getNodeContext();
        }
        return resolver.resolveSync(context, path, request);
    };
}
/**
 * @template A
 * @template B
 * @param {A} obj input a
 * @param {B} exports input b
 * @returns {A & B} merged
 */ const mergeExports = (obj, exports)=>{
    const descriptors = Object.getOwnPropertyDescriptors(exports);
    Object.defineProperties(obj, descriptors);
    return Object.freeze(obj);
};
module.exports = mergeExports(resolve, {
    get sync () {
        return resolveSync;
    },
    create: mergeExports(create, {
        get sync () {
            return createSync;
        }
    }),
    get ResolverFactory () {
        return getResolverFactory();
    },
    get CachedInputFileSystem () {
        return getCachedFileSystem();
    },
    get CloneBasenamePlugin () {
        return __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/CloneBasenamePlugin.js [postcss] (ecmascript)");
    },
    get LogInfoPlugin () {
        return __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/LogInfoPlugin.js [postcss] (ecmascript)");
    },
    get forEachBail () {
        return __turbopack_context__.r("[project]/node_modules/enhanced-resolve/lib/forEachBail.js [postcss] (ecmascript)");
    }
});
}}),

};

//# sourceMappingURL=node_modules_enhanced-resolve_lib_0af5f30c._.js.map