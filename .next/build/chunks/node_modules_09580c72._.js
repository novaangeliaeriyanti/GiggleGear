module.exports = {

"[project]/node_modules/picocolors/picocolors.js [postcss] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
let p = process || {}, argv = p.argv || [], env = p.env || {};
let isColorSupported = !(!!env.NO_COLOR || argv.includes("--no-color")) && (!!env.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env.TERM !== "dumb" || !!env.CI);
let formatter = (open, close, replace = open)=>(input)=>{
        let string = "" + input, index = string.indexOf(close, open.length);
        return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
    };
let replaceClose = (string, close, replace, index)=>{
    let result = "", cursor = 0;
    do {
        result += string.substring(cursor, index) + replace;
        cursor = index + close.length;
        index = string.indexOf(close, cursor);
    }while (~index)
    return result + string.substring(cursor);
};
let createColors = (enabled = isColorSupported)=>{
    let f = enabled ? formatter : ()=>String;
    return {
        isColorSupported: enabled,
        reset: f("\x1b[0m", "\x1b[0m"),
        bold: f("\x1b[1m", "\x1b[22m", "\x1b[22m\x1b[1m"),
        dim: f("\x1b[2m", "\x1b[22m", "\x1b[22m\x1b[2m"),
        italic: f("\x1b[3m", "\x1b[23m"),
        underline: f("\x1b[4m", "\x1b[24m"),
        inverse: f("\x1b[7m", "\x1b[27m"),
        hidden: f("\x1b[8m", "\x1b[28m"),
        strikethrough: f("\x1b[9m", "\x1b[29m"),
        black: f("\x1b[30m", "\x1b[39m"),
        red: f("\x1b[31m", "\x1b[39m"),
        green: f("\x1b[32m", "\x1b[39m"),
        yellow: f("\x1b[33m", "\x1b[39m"),
        blue: f("\x1b[34m", "\x1b[39m"),
        magenta: f("\x1b[35m", "\x1b[39m"),
        cyan: f("\x1b[36m", "\x1b[39m"),
        white: f("\x1b[37m", "\x1b[39m"),
        gray: f("\x1b[90m", "\x1b[39m"),
        bgBlack: f("\x1b[40m", "\x1b[49m"),
        bgRed: f("\x1b[41m", "\x1b[49m"),
        bgGreen: f("\x1b[42m", "\x1b[49m"),
        bgYellow: f("\x1b[43m", "\x1b[49m"),
        bgBlue: f("\x1b[44m", "\x1b[49m"),
        bgMagenta: f("\x1b[45m", "\x1b[49m"),
        bgCyan: f("\x1b[46m", "\x1b[49m"),
        bgWhite: f("\x1b[47m", "\x1b[49m"),
        blackBright: f("\x1b[90m", "\x1b[39m"),
        redBright: f("\x1b[91m", "\x1b[39m"),
        greenBright: f("\x1b[92m", "\x1b[39m"),
        yellowBright: f("\x1b[93m", "\x1b[39m"),
        blueBright: f("\x1b[94m", "\x1b[39m"),
        magentaBright: f("\x1b[95m", "\x1b[39m"),
        cyanBright: f("\x1b[96m", "\x1b[39m"),
        whiteBright: f("\x1b[97m", "\x1b[39m"),
        bgBlackBright: f("\x1b[100m", "\x1b[49m"),
        bgRedBright: f("\x1b[101m", "\x1b[49m"),
        bgGreenBright: f("\x1b[102m", "\x1b[49m"),
        bgYellowBright: f("\x1b[103m", "\x1b[49m"),
        bgBlueBright: f("\x1b[104m", "\x1b[49m"),
        bgMagentaBright: f("\x1b[105m", "\x1b[49m"),
        bgCyanBright: f("\x1b[106m", "\x1b[49m"),
        bgWhiteBright: f("\x1b[107m", "\x1b[49m")
    };
};
module.exports = createColors();
module.exports.createColors = createColors;
}}),
"[project]/node_modules/nanoid/non-secure/index.cjs [postcss] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
// This alphabet uses `A-Za-z0-9_-` symbols.
// The order of characters is optimized for better gzip and brotli compression.
// References to the same file (works both for gzip and brotli):
// `'use`, `andom`, and `rict'`
// References to the brotli default dictionary:
// `-26T`, `1983`, `40px`, `75px`, `bush`, `jack`, `mind`, `very`, and `wolf`
let urlAlphabet = 'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';
let customAlphabet = (alphabet, defaultSize = 21)=>{
    return (size = defaultSize)=>{
        let id = '';
        // A compact alternative for `for (var i = 0; i < step; i++)`.
        let i = size | 0;
        while(i--){
            // `| 0` is more compact and faster than `Math.floor()`.
            id += alphabet[Math.random() * alphabet.length | 0];
        }
        return id;
    };
};
let nanoid = (size = 21)=>{
    let id = '';
    // A compact alternative for `for (var i = 0; i < step; i++)`.
    let i = size | 0;
    while(i--){
        // `| 0` is more compact and faster than `Math.floor()`.
        id += urlAlphabet[Math.random() * 64 | 0];
    }
    return id;
};
module.exports = {
    nanoid,
    customAlphabet
};
}}),
"[project]/node_modules/source-map-js/lib/base64.js [postcss] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */ exports.encode = function(number) {
    if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
    }
    throw new TypeError("Must be between 0 and 63: " + number);
};
/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */ exports.decode = function(charCode) {
    var bigA = 65; // 'A'
    var bigZ = 90; // 'Z'
    var littleA = 97; // 'a'
    var littleZ = 122; // 'z'
    var zero = 48; // '0'
    var nine = 57; // '9'
    var plus = 43; // '+'
    var slash = 47; // '/'
    var littleOffset = 26;
    var numberOffset = 52;
    // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
    if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
    }
    // 26 - 51: abcdefghijklmnopqrstuvwxyz
    if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
    }
    // 52 - 61: 0123456789
    if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
    }
    // 62: +
    if (charCode == plus) {
        return 62;
    }
    // 63: /
    if (charCode == slash) {
        return 63;
    }
    // Invalid base64 digit.
    return -1;
};
}}),
"[project]/node_modules/source-map-js/lib/base64-vlq.js [postcss] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */ var base64 = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/base64.js [postcss] (ecmascript)");
// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011
var VLQ_BASE_SHIFT = 5;
// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;
// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;
/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */ function toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
}
/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */ function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
}
/**
 * Returns the base 64 VLQ encoded value.
 */ exports.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned(aValue);
    do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
            // There are still more digits in this value, so we must make sure the
            // continuation bit is marked.
            digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
    }while (vlq > 0)
    return encoded;
};
/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */ exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;
    do {
        if (aIndex >= strLen) {
            throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
            throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
    }while (continuation)
    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
};
}}),
"[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ /**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */ function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
        return aArgs[aName];
    } else if (arguments.length === 3) {
        return aDefaultValue;
    } else {
        throw new Error('"' + aName + '" is a required argument.');
    }
}
exports.getArg = getArg;
var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;
function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
        return null;
    }
    return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
    };
}
exports.urlParse = urlParse;
function urlGenerate(aParsedUrl) {
    var url = '';
    if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ':';
    }
    url += '//';
    if (aParsedUrl.auth) {
        url += aParsedUrl.auth + '@';
    }
    if (aParsedUrl.host) {
        url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
    }
    if (aParsedUrl.path) {
        url += aParsedUrl.path;
    }
    return url;
}
exports.urlGenerate = urlGenerate;
var MAX_CACHED_INPUTS = 32;
/**
 * Takes some function `f(input) -> result` and returns a memoized version of
 * `f`.
 *
 * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The
 * memoization is a dumb-simple, linear least-recently-used cache.
 */ function lruMemoize(f) {
    var cache = [];
    return function(input) {
        for(var i = 0; i < cache.length; i++){
            if (cache[i].input === input) {
                var temp = cache[0];
                cache[0] = cache[i];
                cache[i] = temp;
                return cache[0].result;
            }
        }
        var result = f(input);
        cache.unshift({
            input,
            result
        });
        if (cache.length > MAX_CACHED_INPUTS) {
            cache.pop();
        }
        return result;
    };
}
/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */ var normalize = lruMemoize(function normalize(aPath) {
    var path = aPath;
    var url = urlParse(aPath);
    if (url) {
        if (!url.path) {
            return aPath;
        }
        path = url.path;
    }
    var isAbsolute = exports.isAbsolute(path);
    // Split the path into parts between `/` characters. This is much faster than
    // using `.split(/\/+/g)`.
    var parts = [];
    var start = 0;
    var i = 0;
    while(true){
        start = i;
        i = path.indexOf("/", start);
        if (i === -1) {
            parts.push(path.slice(start));
            break;
        } else {
            parts.push(path.slice(start, i));
            while(i < path.length && path[i] === "/"){
                i++;
            }
        }
    }
    for(var part, up = 0, i = parts.length - 1; i >= 0; i--){
        part = parts[i];
        if (part === '.') {
            parts.splice(i, 1);
        } else if (part === '..') {
            up++;
        } else if (up > 0) {
            if (part === '') {
                // The first part is blank if the path is absolute. Trying to go
                // above the root is a no-op. Therefore we can remove all '..' parts
                // directly after the root.
                parts.splice(i + 1, up);
                up = 0;
            } else {
                parts.splice(i, 2);
                up--;
            }
        }
    }
    path = parts.join('/');
    if (path === '') {
        path = isAbsolute ? '/' : '.';
    }
    if (url) {
        url.path = path;
        return urlGenerate(url);
    }
    return path;
});
exports.normalize = normalize;
/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */ function join(aRoot, aPath) {
    if (aRoot === "") {
        aRoot = ".";
    }
    if (aPath === "") {
        aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
        aRoot = aRootUrl.path || '/';
    }
    // `join(foo, '//www.example.org')`
    if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
            aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
    }
    if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
    }
    // `join('http://', 'www.example.com')`
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
    }
    var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
    if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
    }
    return joined;
}
exports.join = join;
exports.isAbsolute = function(aPath) {
    return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
};
/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */ function relative(aRoot, aPath) {
    if (aRoot === "") {
        aRoot = ".";
    }
    aRoot = aRoot.replace(/\/$/, '');
    // It is possible for the path to be above the root. In this case, simply
    // checking whether the root is a prefix of the path won't work. Instead, we
    // need to remove components from the root one by one, until either we find
    // a prefix that fits, or we run out of components to remove.
    var level = 0;
    while(aPath.indexOf(aRoot + '/') !== 0){
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
            return aPath;
        }
        // If the only part of the root that is left is the scheme (i.e. http://,
        // file:///, etc.), one or more slashes (/), or simply nothing at all, we
        // have exhausted all components, so the path is not relative to the root.
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
            return aPath;
        }
        ++level;
    }
    // Make sure we add a "../" for each component we removed from the root.
    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;
var supportsNullProto = function() {
    var obj = Object.create(null);
    return !('__proto__' in obj);
}();
function identity(s) {
    return s;
}
/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */ function toSetString(aStr) {
    if (isProtoString(aStr)) {
        return '$' + aStr;
    }
    return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;
function fromSetString(aStr) {
    if (isProtoString(aStr)) {
        return aStr.slice(1);
    }
    return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;
function isProtoString(s) {
    if (!s) {
        return false;
    }
    var length = s.length;
    if (length < 9 /* "__proto__".length */ ) {
        return false;
    }
    if (s.charCodeAt(length - 1) !== 95 /* '_' */  || s.charCodeAt(length - 2) !== 95 /* '_' */  || s.charCodeAt(length - 3) !== 111 /* 'o' */  || s.charCodeAt(length - 4) !== 116 /* 't' */  || s.charCodeAt(length - 5) !== 111 /* 'o' */  || s.charCodeAt(length - 6) !== 114 /* 'r' */  || s.charCodeAt(length - 7) !== 112 /* 'p' */  || s.charCodeAt(length - 8) !== 95 /* '_' */  || s.charCodeAt(length - 9) !== 95 /* '_' */ ) {
        return false;
    }
    for(var i = length - 10; i >= 0; i--){
        if (s.charCodeAt(i) !== 36 /* '$' */ ) {
            return false;
        }
    }
    return true;
}
/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */ function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
        return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositions = compareByOriginalPositions;
function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
    var cmp;
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
        return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;
/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */ function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
        return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
        return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;
function strcmp(aStr1, aStr2) {
    if (aStr1 === aStr2) {
        return 0;
    }
    if (aStr1 === null) {
        return 1; // aStr2 !== null
    }
    if (aStr2 === null) {
        return -1; // aStr1 !== null
    }
    if (aStr1 > aStr2) {
        return 1;
    }
    return -1;
}
/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */ function compareByGeneratedPositionsInflated(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
        return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
        return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */ function parseSourceMapInput(str) {
    return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
}
exports.parseSourceMapInput = parseSourceMapInput;
/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */ function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
    sourceURL = sourceURL || '';
    if (sourceRoot) {
        // This follows what Chrome does.
        if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
            sourceRoot += '/';
        }
        // The spec says:
        //   Line 4: An optional source root, useful for relocating source
        //   files on a server or removing repeated values in the
        //   “sources” entry.  This value is prepended to the individual
        //   entries in the “source” field.
        sourceURL = sourceRoot + sourceURL;
    }
    // Historically, SourceMapConsumer did not take the sourceMapURL as
    // a parameter.  This mode is still somewhat supported, which is why
    // this code block is conditional.  However, it's preferable to pass
    // the source map URL to SourceMapConsumer, so that this function
    // can implement the source URL resolution algorithm as outlined in
    // the spec.  This block is basically the equivalent of:
    //    new URL(sourceURL, sourceMapURL).toString()
    // ... except it avoids using URL, which wasn't available in the
    // older releases of node still supported by this library.
    //
    // The spec says:
    //   If the sources are not absolute URLs after prepending of the
    //   “sourceRoot”, the sources are resolved relative to the
    //   SourceMap (like resolving script src in a html document).
    if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
            throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
            // Strip the last path component, but keep the "/".
            var index = parsed.path.lastIndexOf('/');
            if (index >= 0) {
                parsed.path = parsed.path.substring(0, index + 1);
            }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
    }
    return normalize(sourceURL);
}
exports.computeSourceURL = computeSourceURL;
}}),
"[project]/node_modules/source-map-js/lib/array-set.js [postcss] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ var util = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)");
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";
/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */ function ArraySet() {
    this._array = [];
    this._set = hasNativeMap ? new Map() : Object.create(null);
}
/**
 * Static method for creating ArraySet instances from an existing array.
 */ ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for(var i = 0, len = aArray.length; i < len; i++){
        set.add(aArray[i], aAllowDuplicates);
    }
    return set;
};
/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */ ArraySet.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};
/**
 * Add the given string to this set.
 *
 * @param String aStr
 */ ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
    }
    if (!isDuplicate) {
        if (hasNativeMap) {
            this._set.set(aStr, idx);
        } else {
            this._set[sStr] = idx;
        }
    }
};
/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */ ArraySet.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
        return this._set.has(aStr);
    } else {
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
    }
};
/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */ ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
            return idx;
        }
    } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr)) {
            return this._set[sStr];
        }
    }
    throw new Error('"' + aStr + '" is not in the set.');
};
/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */ ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
    }
    throw new Error('No element indexed by ' + aIdx);
};
/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */ ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
};
exports.ArraySet = ArraySet;
}}),
"[project]/node_modules/source-map-js/lib/mapping-list.js [postcss] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ var util = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)");
/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */ function generatedPositionAfter(mappingA, mappingB) {
    // Optimized for most common case
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}
/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */ function MappingList() {
    this._array = [];
    this._sorted = true;
    // Serves as infimum
    this._last = {
        generatedLine: -1,
        generatedColumn: 0
    };
}
/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */ MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
};
/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */ MappingList.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
    } else {
        this._sorted = false;
        this._array.push(aMapping);
    }
};
/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */ MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
    }
    return this._array;
};
exports.MappingList = MappingList;
}}),
"[project]/node_modules/source-map-js/lib/source-map-generator.js [postcss] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ var base64VLQ = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/base64-vlq.js [postcss] (ecmascript)");
var util = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)");
var ArraySet = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/array-set.js [postcss] (ecmascript)").ArraySet;
var MappingList = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/mapping-list.js [postcss] (ecmascript)").MappingList;
/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */ function SourceMapGenerator(aArgs) {
    if (!aArgs) {
        aArgs = {};
    }
    this._file = util.getArg(aArgs, 'file', null);
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
    this._ignoreInvalidMapping = util.getArg(aArgs, 'ignoreInvalidMapping', false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
}
SourceMapGenerator.prototype._version = 3;
/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */ SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer, generatorOps) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator(Object.assign(generatorOps || {}, {
        file: aSourceMapConsumer.file,
        sourceRoot: sourceRoot
    }));
    aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
            generated: {
                line: mapping.generatedLine,
                column: mapping.generatedColumn
            }
        };
        if (mapping.source != null) {
            newMapping.source = mapping.source;
            if (sourceRoot != null) {
                newMapping.source = util.relative(sourceRoot, newMapping.source);
            }
            newMapping.original = {
                line: mapping.originalLine,
                column: mapping.originalColumn
            };
            if (mapping.name != null) {
                newMapping.name = mapping.name;
            }
        }
        generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
            sourceRelative = util.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
            generator._sources.add(sourceRelative);
        }
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
            generator.setSourceContent(sourceFile, content);
        }
    });
    return generator;
};
/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */ SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);
    if (!this._skipValidation) {
        if (this._validateMapping(generated, original, source, name) === false) {
            return;
        }
    }
    if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
            this._sources.add(source);
        }
    }
    if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
            this._names.add(name);
        }
    }
    this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source,
        name: name
    });
};
/**
 * Set the source content for a source file.
 */ SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
    }
    if (aSourceContent != null) {
        // Add the source content to the _sourcesContents map.
        // Create a new _sourcesContents map if the property is null.
        if (!this._sourcesContents) {
            this._sourcesContents = Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
        // Remove the source file from the _sourcesContents map.
        // If the _sourcesContents map is empty, set the property to null.
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
            this._sourcesContents = null;
        }
    }
};
/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */ SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
            throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
        }
        sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();
    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
            // Check if it can be mapped by the source map, then update the mapping.
            var original = aSourceMapConsumer.originalPositionFor({
                line: mapping.originalLine,
                column: mapping.originalColumn
            });
            if (original.source != null) {
                // Copy mapping
                mapping.source = original.source;
                if (aSourceMapPath != null) {
                    mapping.source = util.join(aSourceMapPath, mapping.source);
                }
                if (sourceRoot != null) {
                    mapping.source = util.relative(sourceRoot, mapping.source);
                }
                mapping.originalLine = original.line;
                mapping.originalColumn = original.column;
                if (original.name != null) {
                    mapping.name = original.name;
                }
            }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
            newSources.add(source);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
            newNames.add(name);
        }
    }, this);
    this._sources = newSources;
    this._names = newNames;
    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
            if (aSourceMapPath != null) {
                sourceFile = util.join(aSourceMapPath, sourceFile);
            }
            if (sourceRoot != null) {
                sourceFile = util.relative(sourceRoot, sourceFile);
            }
            this.setSourceContent(sourceFile, content);
        }
    }, this);
};
/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */ SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
        var message = 'original.line and original.column are not numbers -- you probably meant to omit ' + 'the original mapping entirely and only map the generated position. If so, pass ' + 'null for the original mapping instead of an object with empty or null values.';
        if (this._ignoreInvalidMapping) {
            if (typeof console !== 'undefined' && console.warn) {
                console.warn(message);
            }
            return false;
        } else {
            throw new Error(message);
        }
    }
    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        // Case 1.
        return;
    } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        // Cases 2 and 3.
        return;
    } else {
        var message = 'Invalid mapping: ' + JSON.stringify({
            generated: aGenerated,
            source: aSource,
            original: aOriginal,
            name: aName
        });
        if (this._ignoreInvalidMapping) {
            if (typeof console !== 'undefined' && console.warn) {
                console.warn(message);
            }
            return false;
        } else {
            throw new Error(message);
        }
    }
};
/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */ SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;
    var mappings = this._mappings.toArray();
    for(var i = 0, len = mappings.length; i < len; i++){
        mapping = mappings[i];
        next = '';
        if (mapping.generatedLine !== previousGeneratedLine) {
            previousGeneratedColumn = 0;
            while(mapping.generatedLine !== previousGeneratedLine){
                next += ';';
                previousGeneratedLine++;
            }
        } else {
            if (i > 0) {
                if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
                    continue;
                }
                next += ',';
            }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
            sourceIdx = this._sources.indexOf(mapping.source);
            next += base64VLQ.encode(sourceIdx - previousSource);
            previousSource = sourceIdx;
            // lines are stored 0-based in SourceMap spec version 3
            next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
            previousOriginalLine = mapping.originalLine - 1;
            next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
            previousOriginalColumn = mapping.originalColumn;
            if (mapping.name != null) {
                nameIdx = this._names.indexOf(mapping.name);
                next += base64VLQ.encode(nameIdx - previousName);
                previousName = nameIdx;
            }
        }
        result += next;
    }
    return result;
};
SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function(source) {
        if (!this._sourcesContents) {
            return null;
        }
        if (aSourceRoot != null) {
            source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }, this);
};
/**
 * Externalize the source map.
 */ SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
    };
    if (this._file != null) {
        map.file = this._file;
    }
    if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }
    return map;
};
/**
 * Render the source map being generated to a string.
 */ SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
};
exports.SourceMapGenerator = SourceMapGenerator;
}}),
"[project]/node_modules/source-map-js/lib/binary-search.js [postcss] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;
/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */ function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
    // This function terminates when one of the following is true:
    //
    //   1. We find the exact element we are looking for.
    //
    //   2. We did not find the exact element, but we can return the index of
    //      the next-closest element.
    //
    //   3. We did not find the exact element, and there is no next-closest
    //      element than the one we are searching for, so we return -1.
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
        // Found the element we are looking for.
        return mid;
    } else if (cmp > 0) {
        // Our needle is greater than aHaystack[mid].
        if (aHigh - mid > 1) {
            // The element is in the upper half.
            return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        // The exact needle element was not found in this haystack. Determine if
        // we are in termination case (3) or (2) and return the appropriate thing.
        if (aBias == exports.LEAST_UPPER_BOUND) {
            return aHigh < aHaystack.length ? aHigh : -1;
        } else {
            return mid;
        }
    } else {
        // Our needle is less than aHaystack[mid].
        if (mid - aLow > 1) {
            // The element is in the lower half.
            return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
        // we are in termination case (3) or (2) and return the appropriate thing.
        if (aBias == exports.LEAST_UPPER_BOUND) {
            return mid;
        } else {
            return aLow < 0 ? -1 : aLow;
        }
    }
}
/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */ exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
    if (aHaystack.length === 0) {
        return -1;
    }
    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
    if (index < 0) {
        return -1;
    }
    // We have found either the exact element, or the next-closest element than
    // the one we are searching for. However, there may be more than one such
    // element. Make sure we always return the smallest of these.
    while(index - 1 >= 0){
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
            break;
        }
        --index;
    }
    return index;
};
}}),
"[project]/node_modules/source-map-js/lib/quick-sort.js [postcss] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ // It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.
function SortTemplate(comparator) {
    /**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */ function swap(ary, x, y) {
        var temp = ary[x];
        ary[x] = ary[y];
        ary[y] = temp;
    }
    /**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */ function randomIntInRange(low, high) {
        return Math.round(low + Math.random() * (high - low));
    }
    /**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */ function doQuickSort(ary, comparator, p, r) {
        // If our lower bound is less than our upper bound, we (1) partition the
        // array into two pieces and (2) recurse on each half. If it is not, this is
        // the empty array and our base case.
        if (p < r) {
            // (1) Partitioning.
            //
            // The partitioning chooses a pivot between `p` and `r` and moves all
            // elements that are less than or equal to the pivot to the before it, and
            // all the elements that are greater than it after it. The effect is that
            // once partition is done, the pivot is in the exact place it will be when
            // the array is put in sorted order, and it will not need to be moved
            // again. This runs in O(n) time.
            // Always choose a random pivot so that an input array which is reverse
            // sorted does not cause O(n^2) running time.
            var pivotIndex = randomIntInRange(p, r);
            var i = p - 1;
            swap(ary, pivotIndex, r);
            var pivot = ary[r];
            // Immediately after `j` is incremented in this loop, the following hold
            // true:
            //
            //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
            //
            //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
            for(var j = p; j < r; j++){
                if (comparator(ary[j], pivot, false) <= 0) {
                    i += 1;
                    swap(ary, i, j);
                }
            }
            swap(ary, i + 1, j);
            var q = i + 1;
            // (2) Recurse on each half.
            doQuickSort(ary, comparator, p, q - 1);
            doQuickSort(ary, comparator, q + 1, r);
        }
    }
    return doQuickSort;
}
function cloneSort(comparator) {
    let template = SortTemplate.toString();
    let templateFn = new Function(`return ${template}`)();
    return templateFn(comparator);
}
/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */ let sortCache = new WeakMap();
exports.quickSort = function(ary, comparator, start = 0) {
    let doQuickSort = sortCache.get(comparator);
    if (doQuickSort === void 0) {
        doQuickSort = cloneSort(comparator);
        sortCache.set(comparator, doQuickSort);
    }
    doQuickSort(ary, comparator, start, ary.length - 1);
};
}}),
"[project]/node_modules/source-map-js/lib/source-map-consumer.js [postcss] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ var util = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)");
var binarySearch = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/binary-search.js [postcss] (ecmascript)");
var ArraySet = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/array-set.js [postcss] (ecmascript)").ArraySet;
var base64VLQ = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/base64-vlq.js [postcss] (ecmascript)");
var quickSort = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/quick-sort.js [postcss] (ecmascript)").quickSort;
function SourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
        sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}
SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
};
/**
 * The version of the source mapping spec that we are consuming.
 */ SourceMapConsumer.prototype._version = 3;
// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.
SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    configurable: true,
    enumerable: true,
    get: function() {
        if (!this.__generatedMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappings;
    }
});
SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    configurable: true,
    enumerable: true,
    get: function() {
        if (!this.__originalMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappings;
    }
});
SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
};
/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */ SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
};
SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;
SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;
/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */ SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    var mappings;
    switch(order){
        case SourceMapConsumer.GENERATED_ORDER:
            mappings = this._generatedMappings;
            break;
        case SourceMapConsumer.ORIGINAL_ORDER:
            mappings = this._originalMappings;
            break;
        default:
            throw new Error("Unknown order of iteration.");
    }
    var sourceRoot = this.sourceRoot;
    var boundCallback = aCallback.bind(context);
    var names = this._names;
    var sources = this._sources;
    var sourceMapURL = this._sourceMapURL;
    for(var i = 0, n = mappings.length; i < n; i++){
        var mapping = mappings[i];
        var source = mapping.source === null ? null : sources.at(mapping.source);
        if (source !== null) {
            source = util.computeSourceURL(sourceRoot, source, sourceMapURL);
        }
        boundCallback({
            source: source,
            generatedLine: mapping.generatedLine,
            generatedColumn: mapping.generatedColumn,
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: mapping.name === null ? null : names.at(mapping.name)
        });
    }
};
/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *    The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *    line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *    The column number is 0-based.
 */ SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');
    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: line,
        originalColumn: util.getArg(aArgs, 'column', 0)
    };
    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
        return [];
    }
    var mappings = [];
    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (aArgs.column === undefined) {
            var originalLine = mapping.originalLine;
            // Iterate until either we run out of mappings, or we run into
            // a mapping for a different line than the one we found. Since
            // mappings are sorted, this is guaranteed to find all mappings for
            // the line we found.
            while(mapping && mapping.originalLine === originalLine){
                mappings.push({
                    line: util.getArg(mapping, 'generatedLine', null),
                    column: util.getArg(mapping, 'generatedColumn', null),
                    lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
                });
                mapping = this._originalMappings[++index];
            }
        } else {
            var originalColumn = mapping.originalColumn;
            // Iterate until either we run out of mappings, or we run into
            // a mapping for a different line than the one we were searching for.
            // Since mappings are sorted, this is guaranteed to find all mappings for
            // the line we are searching for.
            while(mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn){
                mappings.push({
                    line: util.getArg(mapping, 'generatedLine', null),
                    column: util.getArg(mapping, 'generatedColumn', null),
                    lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
                });
                mapping = this._originalMappings[++index];
            }
        }
    }
    return mappings;
};
exports.SourceMapConsumer = SourceMapConsumer;
/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */ function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
        sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources');
    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.
    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null);
    // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.
    if (version != this._version) {
        throw new Error('Unsupported version: ' + version);
    }
    if (sourceRoot) {
        sourceRoot = util.normalize(sourceRoot);
    }
    sources = sources.map(String)// Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)// Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function(source) {
        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
    });
    // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.
    this._names = ArraySet.fromArray(names.map(String), true);
    this._sources = ArraySet.fromArray(sources, true);
    this._absoluteSources = this._sources.toArray().map(function(s) {
        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
    });
    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this._sourceMapURL = aSourceMapURL;
    this.file = file;
}
BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
/**
 * Utility function to find the index of a source.  Returns -1 if not
 * found.
 */ BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
    }
    if (this._sources.has(relativeSource)) {
        return this._sources.indexOf(relativeSource);
    }
    // Maybe aSource is an absolute URL as returned by |sources|.  In
    // this case we can't simply undo the transform.
    var i;
    for(i = 0; i < this._absoluteSources.length; ++i){
        if (this._absoluteSources[i] == aSource) {
            return i;
        }
    }
    return -1;
};
/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @param String aSourceMapURL
 *        The URL at which the source map can be found (optional)
 * @returns BasicSourceMapConsumer
 */ BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);
    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function(s) {
        return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });
    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.
    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];
    for(var i = 0, length = generatedMappings.length; i < length; i++){
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping;
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
            destMapping.source = sources.indexOf(srcMapping.source);
            destMapping.originalLine = srcMapping.originalLine;
            destMapping.originalColumn = srcMapping.originalColumn;
            if (srcMapping.name) {
                destMapping.name = names.indexOf(srcMapping.name);
            }
            destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
    }
    quickSort(smc.__originalMappings, util.compareByOriginalPositions);
    return smc;
};
/**
 * The version of the source mapping spec that we are consuming.
 */ BasicSourceMapConsumer.prototype._version = 3;
/**
 * The list of original sources.
 */ Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
    get: function() {
        return this._absoluteSources.slice();
    }
});
/**
 * Provide the JIT with a nice shape / hidden class.
 */ function Mapping() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
}
/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */ const compareGenerated = util.compareByGeneratedPositionsDeflatedNoLine;
function sortGenerated(array, start) {
    let l = array.length;
    let n = array.length - start;
    if (n <= 1) {
        return;
    } else if (n == 2) {
        let a = array[start];
        let b = array[start + 1];
        if (compareGenerated(a, b) > 0) {
            array[start] = b;
            array[start + 1] = a;
        }
    } else if (n < 20) {
        for(let i = start; i < l; i++){
            for(let j = i; j > start; j--){
                let a = array[j - 1];
                let b = array[j];
                if (compareGenerated(a, b) <= 0) {
                    break;
                }
                array[j - 1] = b;
                array[j] = a;
            }
        }
    } else {
        quickSort(array, compareGenerated, start);
    }
}
BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;
    let subarrayStart = 0;
    while(index < length){
        if (aStr.charAt(index) === ';') {
            generatedLine++;
            index++;
            previousGeneratedColumn = 0;
            sortGenerated(generatedMappings, subarrayStart);
            subarrayStart = generatedMappings.length;
        } else if (aStr.charAt(index) === ',') {
            index++;
        } else {
            mapping = new Mapping();
            mapping.generatedLine = generatedLine;
            for(end = index; end < length; end++){
                if (this._charIsMappingSeparator(aStr, end)) {
                    break;
                }
            }
            str = aStr.slice(index, end);
            segment = [];
            while(index < end){
                base64VLQ.decode(aStr, index, temp);
                value = temp.value;
                index = temp.rest;
                segment.push(value);
            }
            if (segment.length === 2) {
                throw new Error('Found a source, but no line and column');
            }
            if (segment.length === 3) {
                throw new Error('Found a source and line, but no column');
            }
            // Generated column.
            mapping.generatedColumn = previousGeneratedColumn + segment[0];
            previousGeneratedColumn = mapping.generatedColumn;
            if (segment.length > 1) {
                // Original source.
                mapping.source = previousSource + segment[1];
                previousSource += segment[1];
                // Original line.
                mapping.originalLine = previousOriginalLine + segment[2];
                previousOriginalLine = mapping.originalLine;
                // Lines are stored 0-based
                mapping.originalLine += 1;
                // Original column.
                mapping.originalColumn = previousOriginalColumn + segment[3];
                previousOriginalColumn = mapping.originalColumn;
                if (segment.length > 4) {
                    // Original name.
                    mapping.name = previousName + segment[4];
                    previousName += segment[4];
                }
            }
            generatedMappings.push(mapping);
            if (typeof mapping.originalLine === 'number') {
                let currentSource = mapping.source;
                while(originalMappings.length <= currentSource){
                    originalMappings.push(null);
                }
                if (originalMappings[currentSource] === null) {
                    originalMappings[currentSource] = [];
                }
                originalMappings[currentSource].push(mapping);
            }
        }
    }
    sortGenerated(generatedMappings, subarrayStart);
    this.__generatedMappings = generatedMappings;
    for(var i = 0; i < originalMappings.length; i++){
        if (originalMappings[i] != null) {
            quickSort(originalMappings[i], util.compareByOriginalPositionsNoSource);
        }
    }
    this.__originalMappings = [].concat(...originalMappings);
};
/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */ BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.
    if (aNeedle[aLineName] <= 0) {
        throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
        throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
    }
    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
};
/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */ BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
    for(var index = 0; index < this._generatedMappings.length; ++index){
        var mapping = this._generatedMappings[index];
        // Mappings do not contain a field for the last generated columnt. We
        // can come up with an optimistic estimate, however, by assuming that
        // mappings are contiguous (i.e. given two consecutive mappings, the
        // first mapping ends where the second one starts).
        if (index + 1 < this._generatedMappings.length) {
            var nextMapping = this._generatedMappings[index + 1];
            if (mapping.generatedLine === nextMapping.generatedLine) {
                mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
                continue;
            }
        }
        // The last mapping for each line spans the entire line.
        mapping.lastGeneratedColumn = Infinity;
    }
};
/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */ BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
    };
    var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
        var mapping = this._generatedMappings[index];
        if (mapping.generatedLine === needle.generatedLine) {
            var source = util.getArg(mapping, 'source', null);
            if (source !== null) {
                source = this._sources.at(source);
                source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
            }
            var name = util.getArg(mapping, 'name', null);
            if (name !== null) {
                name = this._names.at(name);
            }
            return {
                source: source,
                line: util.getArg(mapping, 'originalLine', null),
                column: util.getArg(mapping, 'originalColumn', null),
                name: name
            };
        }
    }
    return {
        source: null,
        line: null,
        column: null,
        name: null
    };
};
/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */ BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
        return false;
    }
    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
    });
};
/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */ BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
        return null;
    }
    var index = this._findSourceIndex(aSource);
    if (index >= 0) {
        return this.sourcesContent[index];
    }
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
    }
    var url;
    if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
        // many users. We can help them out when they expect file:// URIs to
        // behave like it would if they were running a local HTTP server. See
        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
            return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
            return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
        }
    }
    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
        return null;
    } else {
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
};
/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */ BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    source = this._findSourceIndex(source);
    if (source < 0) {
        return {
            line: null,
            column: null,
            lastColumn: null
        };
    }
    var needle = {
        source: source,
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: util.getArg(aArgs, 'column')
    };
    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (mapping.source === needle.source) {
            return {
                line: util.getArg(mapping, 'generatedLine', null),
                column: util.getArg(mapping, 'generatedColumn', null),
                lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
            };
        }
    }
    return {
        line: null,
        column: null,
        lastColumn: null
    };
};
exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */ function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
        sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    var version = util.getArg(sourceMap, 'version');
    var sections = util.getArg(sourceMap, 'sections');
    if (version != this._version) {
        throw new Error('Unsupported version: ' + version);
    }
    this._sources = new ArraySet();
    this._names = new ArraySet();
    var lastOffset = {
        line: -1,
        column: 0
    };
    this._sections = sections.map(function(s) {
        if (s.url) {
            // The url field will require support for asynchronicity.
            // See https://github.com/mozilla/source-map/issues/16
            throw new Error('Support for url field in sections not implemented.');
        }
        var offset = util.getArg(s, 'offset');
        var offsetLine = util.getArg(offset, 'line');
        var offsetColumn = util.getArg(offset, 'column');
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
            throw new Error('Section offsets must be ordered and non-overlapping.');
        }
        lastOffset = offset;
        return {
            generatedOffset: {
                // The offset fields are 0-based, but we use 1-based indices when
                // encoding/decoding from VLQ.
                generatedLine: offsetLine + 1,
                generatedColumn: offsetColumn + 1
            },
            consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
        };
    });
}
IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
/**
 * The version of the source mapping spec that we are consuming.
 */ IndexedSourceMapConsumer.prototype._version = 3;
/**
 * The list of original sources.
 */ Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
    get: function() {
        var sources = [];
        for(var i = 0; i < this._sections.length; i++){
            for(var j = 0; j < this._sections[i].consumer.sources.length; j++){
                sources.push(this._sections[i].consumer.sources[j]);
            }
        }
        return sources;
    }
});
/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */ IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
    };
    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections, function(needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
            return cmp;
        }
        return needle.generatedColumn - section.generatedOffset.generatedColumn;
    });
    var section = this._sections[sectionIndex];
    if (!section) {
        return {
            source: null,
            line: null,
            column: null,
            name: null
        };
    }
    return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
    });
};
/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */ IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function(s) {
        return s.consumer.hasContentsOfAllSources();
    });
};
/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */ IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for(var i = 0; i < this._sections.length; i++){
        var section = this._sections[i];
        var content = section.consumer.sourceContentFor(aSource, true);
        if (content || content === '') {
            return content;
        }
    }
    if (nullOnMissing) {
        return null;
    } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
};
/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based. 
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */ IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for(var i = 0; i < this._sections.length; i++){
        var section = this._sections[i];
        // Only consider this section if the requested source is in the list of
        // sources of the consumer.
        if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
            continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
            var ret = {
                line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
                column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
            };
            return ret;
        }
    }
    return {
        line: null,
        column: null
    };
};
/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */ IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for(var i = 0; i < this._sections.length; i++){
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for(var j = 0; j < sectionMappings.length; j++){
            var mapping = sectionMappings[j];
            var source = section.consumer._sources.at(mapping.source);
            if (source !== null) {
                source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
            }
            this._sources.add(source);
            source = this._sources.indexOf(source);
            var name = null;
            if (mapping.name) {
                name = section.consumer._names.at(mapping.name);
                this._names.add(name);
                name = this._names.indexOf(name);
            }
            // The mappings coming from the consumer for the section have
            // generated positions relative to the start of the section, so we
            // need to offset them to be relative to the start of the concatenated
            // generated file.
            var adjustedMapping = {
                source: source,
                generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
                generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
                originalLine: mapping.originalLine,
                originalColumn: mapping.originalColumn,
                name: name
            };
            this.__generatedMappings.push(adjustedMapping);
            if (typeof adjustedMapping.originalLine === 'number') {
                this.__originalMappings.push(adjustedMapping);
            }
        }
    }
    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
};
exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
}}),
"[project]/node_modules/source-map-js/lib/source-node.js [postcss] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
/* -*- Mode: js; js-indent-level: 2; -*- */ /*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ var SourceMapGenerator = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/source-map-generator.js [postcss] (ecmascript)").SourceMapGenerator;
var util = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/util.js [postcss] (ecmascript)");
// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;
// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;
// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";
/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */ function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null) this.add(aChunks);
}
/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */ SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();
    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are accessed by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
        var lineContents = getNextLine();
        // The last line of a file might not have a newline.
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        //TURBOPACK unreachable
        ;
        function getNextLine() {
            return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
        }
    };
    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;
    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;
    aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null) {
            // We add the code from "lastMapping" to "mapping":
            // First check if there is a new line in between.
            if (lastGeneratedLine < mapping.generatedLine) {
                // Associate first line with "lastMapping"
                addMappingWithCode(lastMapping, shiftNextLine());
                lastGeneratedLine++;
                lastGeneratedColumn = 0;
            // The remaining code is added without mapping
            } else {
                // There is no new line in between.
                // Associate the code between "lastGeneratedColumn" and
                // "mapping.generatedColumn" with "lastMapping"
                var nextLine = remainingLines[remainingLinesIndex] || '';
                var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
                remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
                lastGeneratedColumn = mapping.generatedColumn;
                addMappingWithCode(lastMapping, code);
                // No more remaining code, continue
                lastMapping = mapping;
                return;
            }
        }
        // We add the generated code until the first mapping
        // to the SourceNode without any mapping.
        // Each line is added as separate string.
        while(lastGeneratedLine < mapping.generatedLine){
            node.add(shiftNextLine());
            lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
            var nextLine = remainingLines[remainingLinesIndex] || '';
            node.add(nextLine.substr(0, mapping.generatedColumn));
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
            // Associate the remaining code in the current line with "lastMapping"
            addMappingWithCode(lastMapping, shiftNextLine());
        }
        // and add the remaining lines without any mapping
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }
    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
            if (aRelativePath != null) {
                sourceFile = util.join(aRelativePath, sourceFile);
            }
            node.setSourceContent(sourceFile, content);
        }
    });
    return node;
    //TURBOPACK unreachable
    ;
    function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === undefined) {
            node.add(code);
        } else {
            var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
            node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
        }
    }
};
/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */ SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk) {
            this.add(chunk);
        }, this);
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
            this.children.push(aChunk);
        }
    } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
};
/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */ SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
        for(var i = aChunk.length - 1; i >= 0; i--){
            this.prepend(aChunk[i]);
        }
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
    } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
};
/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */ SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for(var i = 0, len = this.children.length; i < len; i++){
        chunk = this.children[i];
        if (chunk[isSourceNode]) {
            chunk.walk(aFn);
        } else {
            if (chunk !== '') {
                aFn(chunk, {
                    source: this.source,
                    line: this.line,
                    column: this.column,
                    name: this.name
                });
            }
        }
    }
};
/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */ SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
        newChildren = [];
        for(i = 0; i < len - 1; i++){
            newChildren.push(this.children[i]);
            newChildren.push(aSep);
        }
        newChildren.push(this.children[i]);
        this.children = newChildren;
    }
    return this;
};
/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */ SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
    } else if (typeof lastChild === 'string') {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    } else {
        this.children.push(''.replace(aPattern, aReplacement));
    }
    return this;
};
/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */ SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
};
/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */ SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
    for(var i = 0, len = this.children.length; i < len; i++){
        if (this.children[i][isSourceNode]) {
            this.children[i].walkSourceContents(aFn);
        }
    }
    var sources = Object.keys(this.sourceContents);
    for(var i = 0, len = sources.length; i < len; i++){
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
};
/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */ SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function(chunk) {
        str += chunk;
    });
    return str;
};
/**
 * Returns the string representation of this source node along with a source
 * map.
 */ SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
        code: "",
        line: 1,
        column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function(chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
            if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
                map.addMapping({
                    source: original.source,
                    original: {
                        line: original.line,
                        column: original.column
                    },
                    generated: {
                        line: generated.line,
                        column: generated.column
                    },
                    name: original.name
                });
            }
            lastOriginalSource = original.source;
            lastOriginalLine = original.line;
            lastOriginalColumn = original.column;
            lastOriginalName = original.name;
            sourceMappingActive = true;
        } else if (sourceMappingActive) {
            map.addMapping({
                generated: {
                    line: generated.line,
                    column: generated.column
                }
            });
            lastOriginalSource = null;
            sourceMappingActive = false;
        }
        for(var idx = 0, length = chunk.length; idx < length; idx++){
            if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
                generated.line++;
                generated.column = 0;
                // Mappings end at eol
                if (idx + 1 === length) {
                    lastOriginalSource = null;
                    sourceMappingActive = false;
                } else if (sourceMappingActive) {
                    map.addMapping({
                        source: original.source,
                        original: {
                            line: original.line,
                            column: original.column
                        },
                        generated: {
                            line: generated.line,
                            column: generated.column
                        },
                        name: original.name
                    });
                }
            } else {
                generated.column++;
            }
        }
    });
    this.walkSourceContents(function(sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
    });
    return {
        code: generated.code,
        map: map
    };
};
exports.SourceNode = SourceNode;
}}),
"[project]/node_modules/source-map-js/source-map.js [postcss] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */ exports.SourceMapGenerator = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/source-map-generator.js [postcss] (ecmascript)").SourceMapGenerator;
exports.SourceMapConsumer = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/source-map-consumer.js [postcss] (ecmascript)").SourceMapConsumer;
exports.SourceNode = __turbopack_context__.r("[project]/node_modules/source-map-js/lib/source-node.js [postcss] (ecmascript)").SourceNode;
}}),
"[project]/node_modules/@alloc/quick-lru/index.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
class QuickLRU {
    constructor(options = {}){
        if (!(options.maxSize && options.maxSize > 0)) {
            throw new TypeError('`maxSize` must be a number greater than 0');
        }
        if (typeof options.maxAge === 'number' && options.maxAge === 0) {
            throw new TypeError('`maxAge` must be a number greater than 0');
        }
        this.maxSize = options.maxSize;
        this.maxAge = options.maxAge || Infinity;
        this.onEviction = options.onEviction;
        this.cache = new Map();
        this.oldCache = new Map();
        this._size = 0;
    }
    _emitEvictions(cache) {
        if (typeof this.onEviction !== 'function') {
            return;
        }
        for (const [key, item] of cache){
            this.onEviction(key, item.value);
        }
    }
    _deleteIfExpired(key, item) {
        if (typeof item.expiry === 'number' && item.expiry <= Date.now()) {
            if (typeof this.onEviction === 'function') {
                this.onEviction(key, item.value);
            }
            return this.delete(key);
        }
        return false;
    }
    _getOrDeleteIfExpired(key, item) {
        const deleted = this._deleteIfExpired(key, item);
        if (deleted === false) {
            return item.value;
        }
    }
    _getItemValue(key, item) {
        return item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;
    }
    _peek(key, cache) {
        const item = cache.get(key);
        return this._getItemValue(key, item);
    }
    _set(key, value) {
        this.cache.set(key, value);
        this._size++;
        if (this._size >= this.maxSize) {
            this._size = 0;
            this._emitEvictions(this.oldCache);
            this.oldCache = this.cache;
            this.cache = new Map();
        }
    }
    _moveToRecent(key, item) {
        this.oldCache.delete(key);
        this._set(key, item);
    }
    *_entriesAscending() {
        for (const item of this.oldCache){
            const [key, value] = item;
            if (!this.cache.has(key)) {
                const deleted = this._deleteIfExpired(key, value);
                if (deleted === false) {
                    yield item;
                }
            }
        }
        for (const item of this.cache){
            const [key, value] = item;
            const deleted = this._deleteIfExpired(key, value);
            if (deleted === false) {
                yield item;
            }
        }
    }
    get(key) {
        if (this.cache.has(key)) {
            const item = this.cache.get(key);
            return this._getItemValue(key, item);
        }
        if (this.oldCache.has(key)) {
            const item = this.oldCache.get(key);
            if (this._deleteIfExpired(key, item) === false) {
                this._moveToRecent(key, item);
                return item.value;
            }
        }
    }
    set(key, value, { maxAge = this.maxAge === Infinity ? undefined : Date.now() + this.maxAge } = {}) {
        if (this.cache.has(key)) {
            this.cache.set(key, {
                value,
                maxAge
            });
        } else {
            this._set(key, {
                value,
                expiry: maxAge
            });
        }
    }
    has(key) {
        if (this.cache.has(key)) {
            return !this._deleteIfExpired(key, this.cache.get(key));
        }
        if (this.oldCache.has(key)) {
            return !this._deleteIfExpired(key, this.oldCache.get(key));
        }
        return false;
    }
    peek(key) {
        if (this.cache.has(key)) {
            return this._peek(key, this.cache);
        }
        if (this.oldCache.has(key)) {
            return this._peek(key, this.oldCache);
        }
    }
    delete(key) {
        const deleted = this.cache.delete(key);
        if (deleted) {
            this._size--;
        }
        return this.oldCache.delete(key) || deleted;
    }
    clear() {
        this.cache.clear();
        this.oldCache.clear();
        this._size = 0;
    }
    resize(newSize) {
        if (!(newSize && newSize > 0)) {
            throw new TypeError('`maxSize` must be a number greater than 0');
        }
        const items = [
            ...this._entriesAscending()
        ];
        const removeCount = items.length - newSize;
        if (removeCount < 0) {
            this.cache = new Map(items);
            this.oldCache = new Map();
            this._size = items.length;
        } else {
            if (removeCount > 0) {
                this._emitEvictions(items.slice(0, removeCount));
            }
            this.oldCache = new Map(items.slice(removeCount));
            this.cache = new Map();
            this._size = 0;
        }
        this.maxSize = newSize;
    }
    *keys() {
        for (const [key] of this){
            yield key;
        }
    }
    *values() {
        for (const [, value] of this){
            yield value;
        }
    }
    *[Symbol.iterator]() {
        for (const item of this.cache){
            const [key, value] = item;
            const deleted = this._deleteIfExpired(key, value);
            if (deleted === false) {
                yield [
                    key,
                    value.value
                ];
            }
        }
        for (const item of this.oldCache){
            const [key, value] = item;
            if (!this.cache.has(key)) {
                const deleted = this._deleteIfExpired(key, value);
                if (deleted === false) {
                    yield [
                        key,
                        value.value
                    ];
                }
            }
        }
    }
    *entriesDescending() {
        let items = [
            ...this.cache
        ];
        for(let i = items.length - 1; i >= 0; --i){
            const item = items[i];
            const [key, value] = item;
            const deleted = this._deleteIfExpired(key, value);
            if (deleted === false) {
                yield [
                    key,
                    value.value
                ];
            }
        }
        items = [
            ...this.oldCache
        ];
        for(let i = items.length - 1; i >= 0; --i){
            const item = items[i];
            const [key, value] = item;
            if (!this.cache.has(key)) {
                const deleted = this._deleteIfExpired(key, value);
                if (deleted === false) {
                    yield [
                        key,
                        value.value
                    ];
                }
            }
        }
    }
    *entriesAscending() {
        for (const [key, value] of this._entriesAscending()){
            yield [
                key,
                value.value
            ];
        }
    }
    get size() {
        if (!this._size) {
            return this.oldCache.size;
        }
        let oldCacheSize = 0;
        for (const key of this.oldCache.keys()){
            if (!this.cache.has(key)) {
                oldCacheSize++;
            }
        }
        return Math.min(this._size + oldCacheSize, this.maxSize);
    }
}
module.exports = QuickLRU;
}}),
"[project]/node_modules/graceful-fs/polyfills.js [postcss] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
var constants = __turbopack_context__.r("[externals]/constants [external] (constants, cjs)");
var origCwd = process.cwd;
var cwd = null;
var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
process.cwd = function() {
    if (!cwd) cwd = origCwd.call(process);
    return cwd;
};
try {
    process.cwd();
} catch (er) {}
// This check is needed until node.js 12 is required
if (typeof process.chdir === 'function') {
    var chdir = process.chdir;
    process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
    };
    if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
}
module.exports = patch;
function patch(fs) {
    // (re-)implement some things that are known busted or missing.
    // lchmod, broken prior to 0.6.2
    // back-port the fix here.
    if (constants.hasOwnProperty('O_SYMLINK') && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs);
    }
    // lutimes implementation, or no-op
    if (!fs.lutimes) {
        patchLutimes(fs);
    }
    // https://github.com/isaacs/node-graceful-fs/issues/4
    // Chown should not fail on einval or eperm if non-root.
    // It should not fail on enosys ever, as this just indicates
    // that a fs doesn't support the intended operation.
    fs.chown = chownFix(fs.chown);
    fs.fchown = chownFix(fs.fchown);
    fs.lchown = chownFix(fs.lchown);
    fs.chmod = chmodFix(fs.chmod);
    fs.fchmod = chmodFix(fs.fchmod);
    fs.lchmod = chmodFix(fs.lchmod);
    fs.chownSync = chownFixSync(fs.chownSync);
    fs.fchownSync = chownFixSync(fs.fchownSync);
    fs.lchownSync = chownFixSync(fs.lchownSync);
    fs.chmodSync = chmodFixSync(fs.chmodSync);
    fs.fchmodSync = chmodFixSync(fs.fchmodSync);
    fs.lchmodSync = chmodFixSync(fs.lchmodSync);
    fs.stat = statFix(fs.stat);
    fs.fstat = statFix(fs.fstat);
    fs.lstat = statFix(fs.lstat);
    fs.statSync = statFixSync(fs.statSync);
    fs.fstatSync = statFixSync(fs.fstatSync);
    fs.lstatSync = statFixSync(fs.lstatSync);
    // if lchmod/lchown do not exist, then make them no-ops
    if (fs.chmod && !fs.lchmod) {
        fs.lchmod = function(path, mode, cb) {
            if (cb) process.nextTick(cb);
        };
        fs.lchmodSync = function() {};
    }
    if (fs.chown && !fs.lchown) {
        fs.lchown = function(path, uid, gid, cb) {
            if (cb) process.nextTick(cb);
        };
        fs.lchownSync = function() {};
    }
    // on Windows, A/V software can lock the directory, causing this
    // to fail with an EACCES or EPERM if the directory contains newly
    // created files.  Try again on failure, for up to 60 seconds.
    // Set the timeout this long because some Windows Anti-Virus, such as Parity
    // bit9, may lock files for up to a minute, causing npm package install
    // failures. Also, take care to yield the scheduler. Windows scheduling gives
    // CPU to a busy looping process, which can cause the program causing the lock
    // contention to be starved of CPU by node, so the contention doesn't resolve.
    if (platform === "win32") {
        fs.rename = typeof fs.rename !== 'function' ? fs.rename : function(fs$rename) {
            function rename(from, to, cb) {
                var start = Date.now();
                var backoff = 0;
                fs$rename(from, to, function CB(er) {
                    if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 60000) {
                        setTimeout(function() {
                            fs.stat(to, function(stater, st) {
                                if (stater && stater.code === "ENOENT") fs$rename(from, to, CB);
                                else cb(er);
                            });
                        }, backoff);
                        if (backoff < 100) backoff += 10;
                        return;
                    }
                    if (cb) cb(er);
                });
            }
            if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename);
            return rename;
        }(fs.rename);
    }
    // if read() returns EAGAIN, then just try it again.
    fs.read = typeof fs.read !== 'function' ? fs.read : function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
            var callback;
            if (callback_ && typeof callback_ === 'function') {
                var eagCounter = 0;
                callback = function(er, _, __) {
                    if (er && er.code === 'EAGAIN' && eagCounter < 10) {
                        eagCounter++;
                        return fs$read.call(fs, fd, buffer, offset, length, position, callback);
                    }
                    callback_.apply(this, arguments);
                };
            }
            return fs$read.call(fs, fd, buffer, offset, length, position, callback);
        }
        // This ensures `util.promisify` works as it does for native `fs.read`.
        if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
        return read;
    }(fs.read);
    fs.readSync = typeof fs.readSync !== 'function' ? fs.readSync : function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
            var eagCounter = 0;
            while(true){
                try {
                    return fs$readSync.call(fs, fd, buffer, offset, length, position);
                } catch (er) {
                    if (er.code === 'EAGAIN' && eagCounter < 10) {
                        eagCounter++;
                        continue;
                    }
                    throw er;
                }
            }
        };
    }(fs.readSync);
    function patchLchmod(fs) {
        fs.lchmod = function(path, mode, callback) {
            fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
                if (err) {
                    if (callback) callback(err);
                    return;
                }
                // prefer to return the chmod error, if one occurs,
                // but still try to close, and report closing errors if they occur.
                fs.fchmod(fd, mode, function(err) {
                    fs.close(fd, function(err2) {
                        if (callback) callback(err || err2);
                    });
                });
            });
        };
        fs.lchmodSync = function(path, mode) {
            var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);
            // prefer to return the chmod error, if one occurs,
            // but still try to close, and report closing errors if they occur.
            var threw = true;
            var ret;
            try {
                ret = fs.fchmodSync(fd, mode);
                threw = false;
            } finally{
                if (threw) {
                    try {
                        fs.closeSync(fd);
                    } catch (er) {}
                } else {
                    fs.closeSync(fd);
                }
            }
            return ret;
        };
    }
    function patchLutimes(fs) {
        if (constants.hasOwnProperty("O_SYMLINK") && fs.futimes) {
            fs.lutimes = function(path, at, mt, cb) {
                fs.open(path, constants.O_SYMLINK, function(er, fd) {
                    if (er) {
                        if (cb) cb(er);
                        return;
                    }
                    fs.futimes(fd, at, mt, function(er) {
                        fs.close(fd, function(er2) {
                            if (cb) cb(er || er2);
                        });
                    });
                });
            };
            fs.lutimesSync = function(path, at, mt) {
                var fd = fs.openSync(path, constants.O_SYMLINK);
                var ret;
                var threw = true;
                try {
                    ret = fs.futimesSync(fd, at, mt);
                    threw = false;
                } finally{
                    if (threw) {
                        try {
                            fs.closeSync(fd);
                        } catch (er) {}
                    } else {
                        fs.closeSync(fd);
                    }
                }
                return ret;
            };
        } else if (fs.futimes) {
            fs.lutimes = function(_a, _b, _c, cb) {
                if (cb) process.nextTick(cb);
            };
            fs.lutimesSync = function() {};
        }
    }
    function chmodFix(orig) {
        if (!orig) return orig;
        return function(target, mode, cb) {
            return orig.call(fs, target, mode, function(er) {
                if (chownErOk(er)) er = null;
                if (cb) cb.apply(this, arguments);
            });
        };
    }
    function chmodFixSync(orig) {
        if (!orig) return orig;
        return function(target, mode) {
            try {
                return orig.call(fs, target, mode);
            } catch (er) {
                if (!chownErOk(er)) throw er;
            }
        };
    }
    function chownFix(orig) {
        if (!orig) return orig;
        return function(target, uid, gid, cb) {
            return orig.call(fs, target, uid, gid, function(er) {
                if (chownErOk(er)) er = null;
                if (cb) cb.apply(this, arguments);
            });
        };
    }
    function chownFixSync(orig) {
        if (!orig) return orig;
        return function(target, uid, gid) {
            try {
                return orig.call(fs, target, uid, gid);
            } catch (er) {
                if (!chownErOk(er)) throw er;
            }
        };
    }
    function statFix(orig) {
        if (!orig) return orig;
        // Older versions of Node erroneously returned signed integers for
        // uid + gid.
        return function(target, options, cb) {
            if (typeof options === 'function') {
                cb = options;
                options = null;
            }
            function callback(er, stats) {
                if (stats) {
                    if (stats.uid < 0) stats.uid += 0x100000000;
                    if (stats.gid < 0) stats.gid += 0x100000000;
                }
                if (cb) cb.apply(this, arguments);
            }
            return options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
        };
    }
    function statFixSync(orig) {
        if (!orig) return orig;
        // Older versions of Node erroneously returned signed integers for
        // uid + gid.
        return function(target, options) {
            var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
            if (stats) {
                if (stats.uid < 0) stats.uid += 0x100000000;
                if (stats.gid < 0) stats.gid += 0x100000000;
            }
            return stats;
        };
    }
    // ENOSYS means that the fs doesn't support the op. Just ignore
    // that, because it doesn't matter.
    //
    // if there's no getuid, or if getuid() is something other
    // than 0, and the error is EINVAL or EPERM, then just ignore
    // it.
    //
    // This specific case is a silent failure in cp, install, tar,
    // and most other unix tools that manage permissions.
    //
    // When running as root, or if other types of errors are
    // encountered, then it's strict.
    function chownErOk(er) {
        if (!er) return true;
        if (er.code === "ENOSYS") return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
            if (er.code === "EINVAL" || er.code === "EPERM") return true;
        }
        return false;
    }
}
}}),
"[project]/node_modules/graceful-fs/legacy-streams.js [postcss] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
var Stream = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Stream;
module.exports = legacy;
function legacy(fs) {
    return {
        ReadStream: ReadStream,
        WriteStream: WriteStream
    };
    //TURBOPACK unreachable
    ;
    function ReadStream(path, options) {
        if (!(this instanceof ReadStream)) return new ReadStream(path, options);
        Stream.call(this);
        var self = this;
        this.path = path;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = 'r';
        this.mode = 438; /*=0666*/ 
        this.bufferSize = 64 * 1024;
        options = options || {};
        // Mixin options into this
        var keys = Object.keys(options);
        for(var index = 0, length = keys.length; index < length; index++){
            var key = keys[index];
            this[key] = options[key];
        }
        if (this.encoding) this.setEncoding(this.encoding);
        if (this.start !== undefined) {
            if ('number' !== typeof this.start) {
                throw TypeError('start must be a Number');
            }
            if (this.end === undefined) {
                this.end = Infinity;
            } else if ('number' !== typeof this.end) {
                throw TypeError('end must be a Number');
            }
            if (this.start > this.end) {
                throw new Error('start must be <= end');
            }
            this.pos = this.start;
        }
        if (this.fd !== null) {
            process.nextTick(function() {
                self._read();
            });
            return;
        }
        fs.open(this.path, this.flags, this.mode, function(err, fd) {
            if (err) {
                self.emit('error', err);
                self.readable = false;
                return;
            }
            self.fd = fd;
            self.emit('open', fd);
            self._read();
        });
    }
    function WriteStream(path, options) {
        if (!(this instanceof WriteStream)) return new WriteStream(path, options);
        Stream.call(this);
        this.path = path;
        this.fd = null;
        this.writable = true;
        this.flags = 'w';
        this.encoding = 'binary';
        this.mode = 438; /*=0666*/ 
        this.bytesWritten = 0;
        options = options || {};
        // Mixin options into this
        var keys = Object.keys(options);
        for(var index = 0, length = keys.length; index < length; index++){
            var key = keys[index];
            this[key] = options[key];
        }
        if (this.start !== undefined) {
            if ('number' !== typeof this.start) {
                throw TypeError('start must be a Number');
            }
            if (this.start < 0) {
                throw new Error('start must be >= zero');
            }
            this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
            this._open = fs.open;
            this._queue.push([
                this._open,
                this.path,
                this.flags,
                this.mode,
                undefined
            ]);
            this.flush();
        }
    }
}
}}),
"[project]/node_modules/graceful-fs/clone.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
module.exports = clone;
var getPrototypeOf = Object.getPrototypeOf || function(obj) {
    return obj.__proto__;
};
function clone(obj) {
    if (obj === null || typeof obj !== 'object') return obj;
    if (obj instanceof Object) var copy = {
        __proto__: getPrototypeOf(obj)
    };
    else var copy = Object.create(null);
    Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
    });
    return copy;
}
}}),
"[project]/node_modules/graceful-fs/graceful-fs.js [postcss] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
var fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
var polyfills = __turbopack_context__.r("[project]/node_modules/graceful-fs/polyfills.js [postcss] (ecmascript)");
var legacy = __turbopack_context__.r("[project]/node_modules/graceful-fs/legacy-streams.js [postcss] (ecmascript)");
var clone = __turbopack_context__.r("[project]/node_modules/graceful-fs/clone.js [postcss] (ecmascript)");
var util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
/* istanbul ignore next - node 0.x polyfill */ var gracefulQueue;
var previousSymbol;
/* istanbul ignore else - node 0.x polyfill */ if (typeof Symbol === 'function' && typeof Symbol.for === 'function') {
    gracefulQueue = Symbol.for('graceful-fs.queue');
    // This is used in testing by future versions
    previousSymbol = Symbol.for('graceful-fs.previous');
} else {
    gracefulQueue = '___graceful-fs.queue';
    previousSymbol = '___graceful-fs.previous';
}
function noop() {}
function publishQueue(context, queue) {
    Object.defineProperty(context, gracefulQueue, {
        get: function() {
            return queue;
        }
    });
}
var debug = noop;
if (util.debuglog) debug = util.debuglog('gfs4');
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) debug = function() {
    var m = util.format.apply(util, arguments);
    m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ');
    console.error(m);
};
// Once time initialization
if (!fs[gracefulQueue]) {
    // This queue can be shared by multiple loaded instances
    var queue = ("TURBOPACK ident replacement", globalThis)[gracefulQueue] || [];
    publishQueue(fs, queue);
    // Patch fs.close/closeSync to shared queue version, because we need
    // to retry() whenever a close happens *anywhere* in the program.
    // This is essential when multiple graceful-fs instances are
    // in play at the same time.
    fs.close = function(fs$close) {
        function close(fd, cb) {
            return fs$close.call(fs, fd, function(err) {
                // This function uses the graceful-fs shared queue
                if (!err) {
                    resetQueue();
                }
                if (typeof cb === 'function') cb.apply(this, arguments);
            });
        }
        Object.defineProperty(close, previousSymbol, {
            value: fs$close
        });
        return close;
    }(fs.close);
    fs.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
            // This function uses the graceful-fs shared queue
            fs$closeSync.apply(fs, arguments);
            resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
            value: fs$closeSync
        });
        return closeSync;
    }(fs.closeSync);
    if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
        process.on('exit', function() {
            debug(fs[gracefulQueue]);
            __turbopack_context__.r("[externals]/assert [external] (assert, cjs)").equal(fs[gracefulQueue].length, 0);
        });
    }
}
if (!("TURBOPACK ident replacement", globalThis)[gracefulQueue]) {
    publishQueue(("TURBOPACK ident replacement", globalThis), fs[gracefulQueue]);
}
module.exports = patch(clone(fs));
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
    module.exports = patch(fs);
    fs.__patched = true;
}
function patch(fs) {
    // Everything that references the open() function needs to be in here
    polyfills(fs);
    fs.gracefulify = patch;
    fs.createReadStream = createReadStream;
    fs.createWriteStream = createWriteStream;
    var fs$readFile = fs.readFile;
    fs.readFile = readFile;
    function readFile(path, options, cb) {
        if (typeof options === 'function') cb = options, options = null;
        return go$readFile(path, options, cb);
        //TURBOPACK unreachable
        ;
        function go$readFile(path, options, cb, startTime) {
            return fs$readFile(path, options, function(err) {
                if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                    go$readFile,
                    [
                        path,
                        options,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (typeof cb === 'function') cb.apply(this, arguments);
                }
            });
        }
    }
    var fs$writeFile = fs.writeFile;
    fs.writeFile = writeFile;
    function writeFile(path, data, options, cb) {
        if (typeof options === 'function') cb = options, options = null;
        return go$writeFile(path, data, options, cb);
        //TURBOPACK unreachable
        ;
        function go$writeFile(path, data, options, cb, startTime) {
            return fs$writeFile(path, data, options, function(err) {
                if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                    go$writeFile,
                    [
                        path,
                        data,
                        options,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (typeof cb === 'function') cb.apply(this, arguments);
                }
            });
        }
    }
    var fs$appendFile = fs.appendFile;
    if (fs$appendFile) fs.appendFile = appendFile;
    function appendFile(path, data, options, cb) {
        if (typeof options === 'function') cb = options, options = null;
        return go$appendFile(path, data, options, cb);
        //TURBOPACK unreachable
        ;
        function go$appendFile(path, data, options, cb, startTime) {
            return fs$appendFile(path, data, options, function(err) {
                if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                    go$appendFile,
                    [
                        path,
                        data,
                        options,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (typeof cb === 'function') cb.apply(this, arguments);
                }
            });
        }
    }
    var fs$copyFile = fs.copyFile;
    if (fs$copyFile) fs.copyFile = copyFile;
    function copyFile(src, dest, flags, cb) {
        if (typeof flags === 'function') {
            cb = flags;
            flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        //TURBOPACK unreachable
        ;
        function go$copyFile(src, dest, flags, cb, startTime) {
            return fs$copyFile(src, dest, flags, function(err) {
                if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                    go$copyFile,
                    [
                        src,
                        dest,
                        flags,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (typeof cb === 'function') cb.apply(this, arguments);
                }
            });
        }
    }
    var fs$readdir = fs.readdir;
    fs.readdir = readdir;
    var noReaddirOptionVersions = /^v[0-5]\./;
    function readdir(path, options, cb) {
        if (typeof options === 'function') cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir(path, options, cb, startTime) {
            return fs$readdir(path, fs$readdirCallback(path, options, cb, startTime));
        } : function go$readdir(path, options, cb, startTime) {
            return fs$readdir(path, options, fs$readdirCallback(path, options, cb, startTime));
        };
        return go$readdir(path, options, cb);
        //TURBOPACK unreachable
        ;
        function fs$readdirCallback(path, options, cb, startTime) {
            return function(err, files) {
                if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                    go$readdir,
                    [
                        path,
                        options,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (files && files.sort) files.sort();
                    if (typeof cb === 'function') cb.call(this, err, files);
                }
            };
        }
    }
    if (process.version.substr(0, 4) === 'v0.8') {
        var legStreams = legacy(fs);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
    }
    var fs$ReadStream = fs.ReadStream;
    if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
    }
    var fs$WriteStream = fs.WriteStream;
    if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
    }
    Object.defineProperty(fs, 'ReadStream', {
        get: function() {
            return ReadStream;
        },
        set: function(val) {
            ReadStream = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(fs, 'WriteStream', {
        get: function() {
            return WriteStream;
        },
        set: function(val) {
            WriteStream = val;
        },
        enumerable: true,
        configurable: true
    });
    // legacy names
    var FileReadStream = ReadStream;
    Object.defineProperty(fs, 'FileReadStream', {
        get: function() {
            return FileReadStream;
        },
        set: function(val) {
            FileReadStream = val;
        },
        enumerable: true,
        configurable: true
    });
    var FileWriteStream = WriteStream;
    Object.defineProperty(fs, 'FileWriteStream', {
        get: function() {
            return FileWriteStream;
        },
        set: function(val) {
            FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
    });
    function ReadStream(path, options) {
        if (this instanceof ReadStream) return fs$ReadStream.apply(this, arguments), this;
        else return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
    }
    function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
            if (err) {
                if (that.autoClose) that.destroy();
                that.emit('error', err);
            } else {
                that.fd = fd;
                that.emit('open', fd);
                that.read();
            }
        });
    }
    function WriteStream(path, options) {
        if (this instanceof WriteStream) return fs$WriteStream.apply(this, arguments), this;
        else return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
    }
    function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
            if (err) {
                that.destroy();
                that.emit('error', err);
            } else {
                that.fd = fd;
                that.emit('open', fd);
            }
        });
    }
    function createReadStream(path, options) {
        return new fs.ReadStream(path, options);
    }
    function createWriteStream(path, options) {
        return new fs.WriteStream(path, options);
    }
    var fs$open = fs.open;
    fs.open = open;
    function open(path, flags, mode, cb) {
        if (typeof mode === 'function') cb = mode, mode = null;
        return go$open(path, flags, mode, cb);
        //TURBOPACK unreachable
        ;
        function go$open(path, flags, mode, cb, startTime) {
            return fs$open(path, flags, mode, function(err, fd) {
                if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                    go$open,
                    [
                        path,
                        flags,
                        mode,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (typeof cb === 'function') cb.apply(this, arguments);
                }
            });
        }
    }
    return fs;
}
function enqueue(elem) {
    debug('ENQUEUE', elem[0].name, elem[1]);
    fs[gracefulQueue].push(elem);
    retry();
}
// keep track of the timeout between retry() calls
var retryTimer;
// reset the startTime and lastTime to now
// this resets the start of the 60 second overall timeout as well as the
// delay between attempts so that we'll retry these jobs sooner
function resetQueue() {
    var now = Date.now();
    for(var i = 0; i < fs[gracefulQueue].length; ++i){
        // entries that are only a length of 2 are from an older version, don't
        // bother modifying those since they'll be retried anyway.
        if (fs[gracefulQueue][i].length > 2) {
            fs[gracefulQueue][i][3] = now; // startTime
            fs[gracefulQueue][i][4] = now; // lastTime
        }
    }
    // call retry to make sure we're actively processing the queue
    retry();
}
function retry() {
    // clear the timer and remove it to help prevent unintended concurrency
    clearTimeout(retryTimer);
    retryTimer = undefined;
    if (fs[gracefulQueue].length === 0) return;
    var elem = fs[gracefulQueue].shift();
    var fn = elem[0];
    var args = elem[1];
    // these items may be unset if they were added by an older graceful-fs
    var err = elem[2];
    var startTime = elem[3];
    var lastTime = elem[4];
    // if we don't have a startTime we have no way of knowing if we've waited
    // long enough, so go ahead and retry this item now
    if (startTime === undefined) {
        debug('RETRY', fn.name, args);
        fn.apply(null, args);
    } else if (Date.now() - startTime >= 60000) {
        // it's been more than 60 seconds total, bail now
        debug('TIMEOUT', fn.name, args);
        var cb = args.pop();
        if (typeof cb === 'function') cb.call(null, err);
    } else {
        // the amount of time between the last attempt and right now
        var sinceAttempt = Date.now() - lastTime;
        // the amount of time between when we first tried, and when we last tried
        // rounded up to at least 1
        var sinceStart = Math.max(lastTime - startTime, 1);
        // backoff. wait longer than the total time we've been retrying, but only
        // up to a maximum of 100ms
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        // it's been long enough since the last retry, do it again
        if (sinceAttempt >= desiredDelay) {
            debug('RETRY', fn.name, args);
            fn.apply(null, args.concat([
                startTime
            ]));
        } else {
            // if we can't do this job yet, push it to the end of the queue
            // and let the next iteration check again
            fs[gracefulQueue].push(elem);
        }
    }
    // schedule our next run if one isn't already scheduled
    if (retryTimer === undefined) {
        retryTimer = setTimeout(retry, 0);
    }
}
}}),
"[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const deprecateContext = util.deprecate(()=>{}, "Hook.context is deprecated and will be removed");
const CALL_DELEGATE = function(...args) {
    this.call = this._createCall("sync");
    return this.call(...args);
};
const CALL_ASYNC_DELEGATE = function(...args) {
    this.callAsync = this._createCall("async");
    return this.callAsync(...args);
};
const PROMISE_DELEGATE = function(...args) {
    this.promise = this._createCall("promise");
    return this.promise(...args);
};
class Hook {
    constructor(args = [], name = undefined){
        this._args = args;
        this.name = name;
        this.taps = [];
        this.interceptors = [];
        this._call = CALL_DELEGATE;
        this.call = CALL_DELEGATE;
        this._callAsync = CALL_ASYNC_DELEGATE;
        this.callAsync = CALL_ASYNC_DELEGATE;
        this._promise = PROMISE_DELEGATE;
        this.promise = PROMISE_DELEGATE;
        this._x = undefined;
        this.compile = this.compile;
        this.tap = this.tap;
        this.tapAsync = this.tapAsync;
        this.tapPromise = this.tapPromise;
    }
    compile(options) {
        throw new Error("Abstract: should be overridden");
    }
    _createCall(type) {
        return this.compile({
            taps: this.taps,
            interceptors: this.interceptors,
            args: this._args,
            type: type
        });
    }
    _tap(type, options, fn) {
        if (typeof options === "string") {
            options = {
                name: options.trim()
            };
        } else if (typeof options !== "object" || options === null) {
            throw new Error("Invalid tap options");
        }
        if (typeof options.name !== "string" || options.name === "") {
            throw new Error("Missing name for tap");
        }
        if (typeof options.context !== "undefined") {
            deprecateContext();
        }
        options = Object.assign({
            type,
            fn
        }, options);
        options = this._runRegisterInterceptors(options);
        this._insert(options);
    }
    tap(options, fn) {
        this._tap("sync", options, fn);
    }
    tapAsync(options, fn) {
        this._tap("async", options, fn);
    }
    tapPromise(options, fn) {
        this._tap("promise", options, fn);
    }
    _runRegisterInterceptors(options) {
        for (const interceptor of this.interceptors){
            if (interceptor.register) {
                const newOptions = interceptor.register(options);
                if (newOptions !== undefined) {
                    options = newOptions;
                }
            }
        }
        return options;
    }
    withOptions(options) {
        const mergeOptions = (opt)=>Object.assign({}, options, typeof opt === "string" ? {
                name: opt
            } : opt);
        return {
            name: this.name,
            tap: (opt, fn)=>this.tap(mergeOptions(opt), fn),
            tapAsync: (opt, fn)=>this.tapAsync(mergeOptions(opt), fn),
            tapPromise: (opt, fn)=>this.tapPromise(mergeOptions(opt), fn),
            intercept: (interceptor)=>this.intercept(interceptor),
            isUsed: ()=>this.isUsed(),
            withOptions: (opt)=>this.withOptions(mergeOptions(opt))
        };
    }
    isUsed() {
        return this.taps.length > 0 || this.interceptors.length > 0;
    }
    intercept(interceptor) {
        this._resetCompilation();
        this.interceptors.push(Object.assign({}, interceptor));
        if (interceptor.register) {
            for(let i = 0; i < this.taps.length; i++){
                this.taps[i] = interceptor.register(this.taps[i]);
            }
        }
    }
    _resetCompilation() {
        this.call = this._call;
        this.callAsync = this._callAsync;
        this.promise = this._promise;
    }
    _insert(item) {
        this._resetCompilation();
        let before;
        if (typeof item.before === "string") {
            before = new Set([
                item.before
            ]);
        } else if (Array.isArray(item.before)) {
            before = new Set(item.before);
        }
        let stage = 0;
        if (typeof item.stage === "number") {
            stage = item.stage;
        }
        let i = this.taps.length;
        while(i > 0){
            i--;
            const x = this.taps[i];
            this.taps[i + 1] = x;
            const xStage = x.stage || 0;
            if (before) {
                if (before.has(x.name)) {
                    before.delete(x.name);
                    continue;
                }
                if (before.size > 0) {
                    continue;
                }
            }
            if (xStage > stage) {
                continue;
            }
            i++;
            break;
        }
        this.taps[i] = item;
    }
}
Object.setPrototypeOf(Hook.prototype, null);
module.exports = Hook;
}}),
"[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ class HookCodeFactory {
    constructor(config){
        this.config = config;
        this.options = undefined;
        this._args = undefined;
    }
    create(options) {
        this.init(options);
        let fn;
        switch(this.options.type){
            case "sync":
                fn = new Function(this.args(), '"use strict";\n' + this.header() + this.contentWithInterceptors({
                    onError: (err)=>`throw ${err};\n`,
                    onResult: (result)=>`return ${result};\n`,
                    resultReturns: true,
                    onDone: ()=>"",
                    rethrowIfPossible: true
                }));
                break;
            case "async":
                fn = new Function(this.args({
                    after: "_callback"
                }), '"use strict";\n' + this.header() + this.contentWithInterceptors({
                    onError: (err)=>`_callback(${err});\n`,
                    onResult: (result)=>`_callback(null, ${result});\n`,
                    onDone: ()=>"_callback();\n"
                }));
                break;
            case "promise":
                let errorHelperUsed = false;
                const content = this.contentWithInterceptors({
                    onError: (err)=>{
                        errorHelperUsed = true;
                        return `_error(${err});\n`;
                    },
                    onResult: (result)=>`_resolve(${result});\n`,
                    onDone: ()=>"_resolve();\n"
                });
                let code = "";
                code += '"use strict";\n';
                code += this.header();
                code += "return new Promise((function(_resolve, _reject) {\n";
                if (errorHelperUsed) {
                    code += "var _sync = true;\n";
                    code += "function _error(_err) {\n";
                    code += "if(_sync)\n";
                    code += "_resolve(Promise.resolve().then((function() { throw _err; })));\n";
                    code += "else\n";
                    code += "_reject(_err);\n";
                    code += "};\n";
                }
                code += content;
                if (errorHelperUsed) {
                    code += "_sync = false;\n";
                }
                code += "}));\n";
                fn = new Function(this.args(), code);
                break;
        }
        this.deinit();
        return fn;
    }
    setup(instance, options) {
        instance._x = options.taps.map((t)=>t.fn);
    }
    /**
	 * @param {{ type: "sync" | "promise" | "async", taps: Array<Tap>, interceptors: Array<Interceptor> }} options
	 */ init(options) {
        this.options = options;
        this._args = options.args.slice();
    }
    deinit() {
        this.options = undefined;
        this._args = undefined;
    }
    contentWithInterceptors(options) {
        if (this.options.interceptors.length > 0) {
            const onError = options.onError;
            const onResult = options.onResult;
            const onDone = options.onDone;
            let code = "";
            for(let i = 0; i < this.options.interceptors.length; i++){
                const interceptor = this.options.interceptors[i];
                if (interceptor.call) {
                    code += `${this.getInterceptor(i)}.call(${this.args({
                        before: interceptor.context ? "_context" : undefined
                    })});\n`;
                }
            }
            code += this.content(Object.assign(options, {
                onError: onError && ((err)=>{
                    let code = "";
                    for(let i = 0; i < this.options.interceptors.length; i++){
                        const interceptor = this.options.interceptors[i];
                        if (interceptor.error) {
                            code += `${this.getInterceptor(i)}.error(${err});\n`;
                        }
                    }
                    code += onError(err);
                    return code;
                }),
                onResult: onResult && ((result)=>{
                    let code = "";
                    for(let i = 0; i < this.options.interceptors.length; i++){
                        const interceptor = this.options.interceptors[i];
                        if (interceptor.result) {
                            code += `${this.getInterceptor(i)}.result(${result});\n`;
                        }
                    }
                    code += onResult(result);
                    return code;
                }),
                onDone: onDone && (()=>{
                    let code = "";
                    for(let i = 0; i < this.options.interceptors.length; i++){
                        const interceptor = this.options.interceptors[i];
                        if (interceptor.done) {
                            code += `${this.getInterceptor(i)}.done();\n`;
                        }
                    }
                    code += onDone();
                    return code;
                })
            }));
            return code;
        } else {
            return this.content(options);
        }
    }
    header() {
        let code = "";
        if (this.needContext()) {
            code += "var _context = {};\n";
        } else {
            code += "var _context;\n";
        }
        code += "var _x = this._x;\n";
        if (this.options.interceptors.length > 0) {
            code += "var _taps = this.taps;\n";
            code += "var _interceptors = this.interceptors;\n";
        }
        return code;
    }
    needContext() {
        for (const tap of this.options.taps)if (tap.context) return true;
        return false;
    }
    callTap(tapIndex, { onError, onResult, onDone, rethrowIfPossible }) {
        let code = "";
        let hasTapCached = false;
        for(let i = 0; i < this.options.interceptors.length; i++){
            const interceptor = this.options.interceptors[i];
            if (interceptor.tap) {
                if (!hasTapCached) {
                    code += `var _tap${tapIndex} = ${this.getTap(tapIndex)};\n`;
                    hasTapCached = true;
                }
                code += `${this.getInterceptor(i)}.tap(${interceptor.context ? "_context, " : ""}_tap${tapIndex});\n`;
            }
        }
        code += `var _fn${tapIndex} = ${this.getTapFn(tapIndex)};\n`;
        const tap = this.options.taps[tapIndex];
        switch(tap.type){
            case "sync":
                if (!rethrowIfPossible) {
                    code += `var _hasError${tapIndex} = false;\n`;
                    code += "try {\n";
                }
                if (onResult) {
                    code += `var _result${tapIndex} = _fn${tapIndex}(${this.args({
                        before: tap.context ? "_context" : undefined
                    })});\n`;
                } else {
                    code += `_fn${tapIndex}(${this.args({
                        before: tap.context ? "_context" : undefined
                    })});\n`;
                }
                if (!rethrowIfPossible) {
                    code += "} catch(_err) {\n";
                    code += `_hasError${tapIndex} = true;\n`;
                    code += onError("_err");
                    code += "}\n";
                    code += `if(!_hasError${tapIndex}) {\n`;
                }
                if (onResult) {
                    code += onResult(`_result${tapIndex}`);
                }
                if (onDone) {
                    code += onDone();
                }
                if (!rethrowIfPossible) {
                    code += "}\n";
                }
                break;
            case "async":
                let cbCode = "";
                if (onResult) cbCode += `(function(_err${tapIndex}, _result${tapIndex}) {\n`;
                else cbCode += `(function(_err${tapIndex}) {\n`;
                cbCode += `if(_err${tapIndex}) {\n`;
                cbCode += onError(`_err${tapIndex}`);
                cbCode += "} else {\n";
                if (onResult) {
                    cbCode += onResult(`_result${tapIndex}`);
                }
                if (onDone) {
                    cbCode += onDone();
                }
                cbCode += "}\n";
                cbCode += "})";
                code += `_fn${tapIndex}(${this.args({
                    before: tap.context ? "_context" : undefined,
                    after: cbCode
                })});\n`;
                break;
            case "promise":
                code += `var _hasResult${tapIndex} = false;\n`;
                code += `var _promise${tapIndex} = _fn${tapIndex}(${this.args({
                    before: tap.context ? "_context" : undefined
                })});\n`;
                code += `if (!_promise${tapIndex} || !_promise${tapIndex}.then)\n`;
                code += `  throw new Error('Tap function (tapPromise) did not return promise (returned ' + _promise${tapIndex} + ')');\n`;
                code += `_promise${tapIndex}.then((function(_result${tapIndex}) {\n`;
                code += `_hasResult${tapIndex} = true;\n`;
                if (onResult) {
                    code += onResult(`_result${tapIndex}`);
                }
                if (onDone) {
                    code += onDone();
                }
                code += `}), function(_err${tapIndex}) {\n`;
                code += `if(_hasResult${tapIndex}) throw _err${tapIndex};\n`;
                code += onError(`_err${tapIndex}`);
                code += "});\n";
                break;
        }
        return code;
    }
    callTapsSeries({ onError, onResult, resultReturns, onDone, doneReturns, rethrowIfPossible }) {
        if (this.options.taps.length === 0) return onDone();
        const firstAsync = this.options.taps.findIndex((t)=>t.type !== "sync");
        const somethingReturns = resultReturns || doneReturns;
        let code = "";
        let current = onDone;
        let unrollCounter = 0;
        for(let j = this.options.taps.length - 1; j >= 0; j--){
            const i = j;
            const unroll = current !== onDone && (this.options.taps[i].type !== "sync" || unrollCounter++ > 20);
            if (unroll) {
                unrollCounter = 0;
                code += `function _next${i}() {\n`;
                code += current();
                code += `}\n`;
                current = ()=>`${somethingReturns ? "return " : ""}_next${i}();\n`;
            }
            const done = current;
            const doneBreak = (skipDone)=>{
                if (skipDone) return "";
                return onDone();
            };
            const content = this.callTap(i, {
                onError: (error)=>onError(i, error, done, doneBreak),
                onResult: onResult && ((result)=>{
                    return onResult(i, result, done, doneBreak);
                }),
                onDone: !onResult && done,
                rethrowIfPossible: rethrowIfPossible && (firstAsync < 0 || i < firstAsync)
            });
            current = ()=>content;
        }
        code += current();
        return code;
    }
    callTapsLooping({ onError, onDone, rethrowIfPossible }) {
        if (this.options.taps.length === 0) return onDone();
        const syncOnly = this.options.taps.every((t)=>t.type === "sync");
        let code = "";
        if (!syncOnly) {
            code += "var _looper = (function() {\n";
            code += "var _loopAsync = false;\n";
        }
        code += "var _loop;\n";
        code += "do {\n";
        code += "_loop = false;\n";
        for(let i = 0; i < this.options.interceptors.length; i++){
            const interceptor = this.options.interceptors[i];
            if (interceptor.loop) {
                code += `${this.getInterceptor(i)}.loop(${this.args({
                    before: interceptor.context ? "_context" : undefined
                })});\n`;
            }
        }
        code += this.callTapsSeries({
            onError,
            onResult: (i, result, next, doneBreak)=>{
                let code = "";
                code += `if(${result} !== undefined) {\n`;
                code += "_loop = true;\n";
                if (!syncOnly) code += "if(_loopAsync) _looper();\n";
                code += doneBreak(true);
                code += `} else {\n`;
                code += next();
                code += `}\n`;
                return code;
            },
            onDone: onDone && (()=>{
                let code = "";
                code += "if(!_loop) {\n";
                code += onDone();
                code += "}\n";
                return code;
            }),
            rethrowIfPossible: rethrowIfPossible && syncOnly
        });
        code += "} while(_loop);\n";
        if (!syncOnly) {
            code += "_loopAsync = true;\n";
            code += "});\n";
            code += "_looper();\n";
        }
        return code;
    }
    callTapsParallel({ onError, onResult, onDone, rethrowIfPossible, onTap = (i, run)=>run() }) {
        if (this.options.taps.length <= 1) {
            return this.callTapsSeries({
                onError,
                onResult,
                onDone,
                rethrowIfPossible
            });
        }
        let code = "";
        code += "do {\n";
        code += `var _counter = ${this.options.taps.length};\n`;
        if (onDone) {
            code += "var _done = (function() {\n";
            code += onDone();
            code += "});\n";
        }
        for(let i = 0; i < this.options.taps.length; i++){
            const done = ()=>{
                if (onDone) return "if(--_counter === 0) _done();\n";
                else return "--_counter;";
            };
            const doneBreak = (skipDone)=>{
                if (skipDone || !onDone) return "_counter = 0;\n";
                else return "_counter = 0;\n_done();\n";
            };
            code += "if(_counter <= 0) break;\n";
            code += onTap(i, ()=>this.callTap(i, {
                    onError: (error)=>{
                        let code = "";
                        code += "if(_counter > 0) {\n";
                        code += onError(i, error, done, doneBreak);
                        code += "}\n";
                        return code;
                    },
                    onResult: onResult && ((result)=>{
                        let code = "";
                        code += "if(_counter > 0) {\n";
                        code += onResult(i, result, done, doneBreak);
                        code += "}\n";
                        return code;
                    }),
                    onDone: !onResult && (()=>{
                        return done();
                    }),
                    rethrowIfPossible
                }), done, doneBreak);
        }
        code += "} while(false);\n";
        return code;
    }
    args({ before, after } = {}) {
        let allArgs = this._args;
        if (before) allArgs = [
            before
        ].concat(allArgs);
        if (after) allArgs = allArgs.concat(after);
        if (allArgs.length === 0) {
            return "";
        } else {
            return allArgs.join(", ");
        }
    }
    getTapFn(idx) {
        return `_x[${idx}]`;
    }
    getTap(idx) {
        return `_taps[${idx}]`;
    }
    getInterceptor(idx) {
        return `_interceptors[${idx}]`;
    }
}
module.exports = HookCodeFactory;
}}),
"[project]/node_modules/tapable/lib/SyncHook.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class SyncHookCodeFactory extends HookCodeFactory {
    content({ onError, onDone, rethrowIfPossible }) {
        return this.callTapsSeries({
            onError: (i, err)=>onError(err),
            onDone,
            rethrowIfPossible
        });
    }
}
const factory = new SyncHookCodeFactory();
const TAP_ASYNC = ()=>{
    throw new Error("tapAsync is not supported on a SyncHook");
};
const TAP_PROMISE = ()=>{
    throw new Error("tapPromise is not supported on a SyncHook");
};
const COMPILE = function(options) {
    factory.setup(this, options);
    return factory.create(options);
};
function SyncHook(args = [], name = undefined) {
    const hook = new Hook(args, name);
    hook.constructor = SyncHook;
    hook.tapAsync = TAP_ASYNC;
    hook.tapPromise = TAP_PROMISE;
    hook.compile = COMPILE;
    return hook;
}
SyncHook.prototype = null;
module.exports = SyncHook;
}}),
"[project]/node_modules/tapable/lib/SyncBailHook.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class SyncBailHookCodeFactory extends HookCodeFactory {
    content({ onError, onResult, resultReturns, onDone, rethrowIfPossible }) {
        return this.callTapsSeries({
            onError: (i, err)=>onError(err),
            onResult: (i, result, next)=>`if(${result} !== undefined) {\n${onResult(result)};\n} else {\n${next()}}\n`,
            resultReturns,
            onDone,
            rethrowIfPossible
        });
    }
}
const factory = new SyncBailHookCodeFactory();
const TAP_ASYNC = ()=>{
    throw new Error("tapAsync is not supported on a SyncBailHook");
};
const TAP_PROMISE = ()=>{
    throw new Error("tapPromise is not supported on a SyncBailHook");
};
const COMPILE = function(options) {
    factory.setup(this, options);
    return factory.create(options);
};
function SyncBailHook(args = [], name = undefined) {
    const hook = new Hook(args, name);
    hook.constructor = SyncBailHook;
    hook.tapAsync = TAP_ASYNC;
    hook.tapPromise = TAP_PROMISE;
    hook.compile = COMPILE;
    return hook;
}
SyncBailHook.prototype = null;
module.exports = SyncBailHook;
}}),
"[project]/node_modules/tapable/lib/SyncWaterfallHook.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class SyncWaterfallHookCodeFactory extends HookCodeFactory {
    content({ onError, onResult, resultReturns, rethrowIfPossible }) {
        return this.callTapsSeries({
            onError: (i, err)=>onError(err),
            onResult: (i, result, next)=>{
                let code = "";
                code += `if(${result} !== undefined) {\n`;
                code += `${this._args[0]} = ${result};\n`;
                code += `}\n`;
                code += next();
                return code;
            },
            onDone: ()=>onResult(this._args[0]),
            doneReturns: resultReturns,
            rethrowIfPossible
        });
    }
}
const factory = new SyncWaterfallHookCodeFactory();
const TAP_ASYNC = ()=>{
    throw new Error("tapAsync is not supported on a SyncWaterfallHook");
};
const TAP_PROMISE = ()=>{
    throw new Error("tapPromise is not supported on a SyncWaterfallHook");
};
const COMPILE = function(options) {
    factory.setup(this, options);
    return factory.create(options);
};
function SyncWaterfallHook(args = [], name = undefined) {
    if (args.length < 1) throw new Error("Waterfall hooks must have at least one argument");
    const hook = new Hook(args, name);
    hook.constructor = SyncWaterfallHook;
    hook.tapAsync = TAP_ASYNC;
    hook.tapPromise = TAP_PROMISE;
    hook.compile = COMPILE;
    return hook;
}
SyncWaterfallHook.prototype = null;
module.exports = SyncWaterfallHook;
}}),
"[project]/node_modules/tapable/lib/SyncLoopHook.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class SyncLoopHookCodeFactory extends HookCodeFactory {
    content({ onError, onDone, rethrowIfPossible }) {
        return this.callTapsLooping({
            onError: (i, err)=>onError(err),
            onDone,
            rethrowIfPossible
        });
    }
}
const factory = new SyncLoopHookCodeFactory();
const TAP_ASYNC = ()=>{
    throw new Error("tapAsync is not supported on a SyncLoopHook");
};
const TAP_PROMISE = ()=>{
    throw new Error("tapPromise is not supported on a SyncLoopHook");
};
const COMPILE = function(options) {
    factory.setup(this, options);
    return factory.create(options);
};
function SyncLoopHook(args = [], name = undefined) {
    const hook = new Hook(args, name);
    hook.constructor = SyncLoopHook;
    hook.tapAsync = TAP_ASYNC;
    hook.tapPromise = TAP_PROMISE;
    hook.compile = COMPILE;
    return hook;
}
SyncLoopHook.prototype = null;
module.exports = SyncLoopHook;
}}),
"[project]/node_modules/tapable/lib/AsyncParallelHook.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class AsyncParallelHookCodeFactory extends HookCodeFactory {
    content({ onError, onDone }) {
        return this.callTapsParallel({
            onError: (i, err, done, doneBreak)=>onError(err) + doneBreak(true),
            onDone
        });
    }
}
const factory = new AsyncParallelHookCodeFactory();
const COMPILE = function(options) {
    factory.setup(this, options);
    return factory.create(options);
};
function AsyncParallelHook(args = [], name = undefined) {
    const hook = new Hook(args, name);
    hook.constructor = AsyncParallelHook;
    hook.compile = COMPILE;
    hook._call = undefined;
    hook.call = undefined;
    return hook;
}
AsyncParallelHook.prototype = null;
module.exports = AsyncParallelHook;
}}),
"[project]/node_modules/tapable/lib/AsyncParallelBailHook.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class AsyncParallelBailHookCodeFactory extends HookCodeFactory {
    content({ onError, onResult, onDone }) {
        let code = "";
        code += `var _results = new Array(${this.options.taps.length});\n`;
        code += "var _checkDone = function() {\n";
        code += "for(var i = 0; i < _results.length; i++) {\n";
        code += "var item = _results[i];\n";
        code += "if(item === undefined) return false;\n";
        code += "if(item.result !== undefined) {\n";
        code += onResult("item.result");
        code += "return true;\n";
        code += "}\n";
        code += "if(item.error) {\n";
        code += onError("item.error");
        code += "return true;\n";
        code += "}\n";
        code += "}\n";
        code += "return false;\n";
        code += "}\n";
        code += this.callTapsParallel({
            onError: (i, err, done, doneBreak)=>{
                let code = "";
                code += `if(${i} < _results.length && ((_results.length = ${i + 1}), (_results[${i}] = { error: ${err} }), _checkDone())) {\n`;
                code += doneBreak(true);
                code += "} else {\n";
                code += done();
                code += "}\n";
                return code;
            },
            onResult: (i, result, done, doneBreak)=>{
                let code = "";
                code += `if(${i} < _results.length && (${result} !== undefined && (_results.length = ${i + 1}), (_results[${i}] = { result: ${result} }), _checkDone())) {\n`;
                code += doneBreak(true);
                code += "} else {\n";
                code += done();
                code += "}\n";
                return code;
            },
            onTap: (i, run, done, doneBreak)=>{
                let code = "";
                if (i > 0) {
                    code += `if(${i} >= _results.length) {\n`;
                    code += done();
                    code += "} else {\n";
                }
                code += run();
                if (i > 0) code += "}\n";
                return code;
            },
            onDone
        });
        return code;
    }
}
const factory = new AsyncParallelBailHookCodeFactory();
const COMPILE = function(options) {
    factory.setup(this, options);
    return factory.create(options);
};
function AsyncParallelBailHook(args = [], name = undefined) {
    const hook = new Hook(args, name);
    hook.constructor = AsyncParallelBailHook;
    hook.compile = COMPILE;
    hook._call = undefined;
    hook.call = undefined;
    return hook;
}
AsyncParallelBailHook.prototype = null;
module.exports = AsyncParallelBailHook;
}}),
"[project]/node_modules/tapable/lib/AsyncSeriesHook.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class AsyncSeriesHookCodeFactory extends HookCodeFactory {
    content({ onError, onDone }) {
        return this.callTapsSeries({
            onError: (i, err, next, doneBreak)=>onError(err) + doneBreak(true),
            onDone
        });
    }
}
const factory = new AsyncSeriesHookCodeFactory();
const COMPILE = function(options) {
    factory.setup(this, options);
    return factory.create(options);
};
function AsyncSeriesHook(args = [], name = undefined) {
    const hook = new Hook(args, name);
    hook.constructor = AsyncSeriesHook;
    hook.compile = COMPILE;
    hook._call = undefined;
    hook.call = undefined;
    return hook;
}
AsyncSeriesHook.prototype = null;
module.exports = AsyncSeriesHook;
}}),
"[project]/node_modules/tapable/lib/AsyncSeriesBailHook.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class AsyncSeriesBailHookCodeFactory extends HookCodeFactory {
    content({ onError, onResult, resultReturns, onDone }) {
        return this.callTapsSeries({
            onError: (i, err, next, doneBreak)=>onError(err) + doneBreak(true),
            onResult: (i, result, next)=>`if(${result} !== undefined) {\n${onResult(result)}\n} else {\n${next()}}\n`,
            resultReturns,
            onDone
        });
    }
}
const factory = new AsyncSeriesBailHookCodeFactory();
const COMPILE = function(options) {
    factory.setup(this, options);
    return factory.create(options);
};
function AsyncSeriesBailHook(args = [], name = undefined) {
    const hook = new Hook(args, name);
    hook.constructor = AsyncSeriesBailHook;
    hook.compile = COMPILE;
    hook._call = undefined;
    hook.call = undefined;
    return hook;
}
AsyncSeriesBailHook.prototype = null;
module.exports = AsyncSeriesBailHook;
}}),
"[project]/node_modules/tapable/lib/AsyncSeriesLoopHook.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class AsyncSeriesLoopHookCodeFactory extends HookCodeFactory {
    content({ onError, onDone }) {
        return this.callTapsLooping({
            onError: (i, err, next, doneBreak)=>onError(err) + doneBreak(true),
            onDone
        });
    }
}
const factory = new AsyncSeriesLoopHookCodeFactory();
const COMPILE = function(options) {
    factory.setup(this, options);
    return factory.create(options);
};
function AsyncSeriesLoopHook(args = [], name = undefined) {
    const hook = new Hook(args, name);
    hook.constructor = AsyncSeriesLoopHook;
    hook.compile = COMPILE;
    hook._call = undefined;
    hook.call = undefined;
    return hook;
}
AsyncSeriesLoopHook.prototype = null;
module.exports = AsyncSeriesLoopHook;
}}),
"[project]/node_modules/tapable/lib/AsyncSeriesWaterfallHook.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
const HookCodeFactory = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookCodeFactory.js [postcss] (ecmascript)");
class AsyncSeriesWaterfallHookCodeFactory extends HookCodeFactory {
    content({ onError, onResult, onDone }) {
        return this.callTapsSeries({
            onError: (i, err, next, doneBreak)=>onError(err) + doneBreak(true),
            onResult: (i, result, next)=>{
                let code = "";
                code += `if(${result} !== undefined) {\n`;
                code += `${this._args[0]} = ${result};\n`;
                code += `}\n`;
                code += next();
                return code;
            },
            onDone: ()=>onResult(this._args[0])
        });
    }
}
const factory = new AsyncSeriesWaterfallHookCodeFactory();
const COMPILE = function(options) {
    factory.setup(this, options);
    return factory.create(options);
};
function AsyncSeriesWaterfallHook(args = [], name = undefined) {
    if (args.length < 1) throw new Error("Waterfall hooks must have at least one argument");
    const hook = new Hook(args, name);
    hook.constructor = AsyncSeriesWaterfallHook;
    hook.compile = COMPILE;
    hook._call = undefined;
    hook.call = undefined;
    return hook;
}
AsyncSeriesWaterfallHook.prototype = null;
module.exports = AsyncSeriesWaterfallHook;
}}),
"[project]/node_modules/tapable/lib/HookMap.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const defaultFactory = (key, hook)=>hook;
class HookMap {
    constructor(factory, name = undefined){
        this._map = new Map();
        this.name = name;
        this._factory = factory;
        this._interceptors = [];
    }
    get(key) {
        return this._map.get(key);
    }
    for(key) {
        const hook = this.get(key);
        if (hook !== undefined) {
            return hook;
        }
        let newHook = this._factory(key);
        const interceptors = this._interceptors;
        for(let i = 0; i < interceptors.length; i++){
            newHook = interceptors[i].factory(key, newHook);
        }
        this._map.set(key, newHook);
        return newHook;
    }
    intercept(interceptor) {
        this._interceptors.push(Object.assign({
            factory: defaultFactory
        }, interceptor));
    }
}
HookMap.prototype.tap = util.deprecate(function(key, options, fn) {
    return this.for(key).tap(options, fn);
}, "HookMap#tap(key,…) is deprecated. Use HookMap#for(key).tap(…) instead.");
HookMap.prototype.tapAsync = util.deprecate(function(key, options, fn) {
    return this.for(key).tapAsync(options, fn);
}, "HookMap#tapAsync(key,…) is deprecated. Use HookMap#for(key).tapAsync(…) instead.");
HookMap.prototype.tapPromise = util.deprecate(function(key, options, fn) {
    return this.for(key).tapPromise(options, fn);
}, "HookMap#tapPromise(key,…) is deprecated. Use HookMap#for(key).tapPromise(…) instead.");
module.exports = HookMap;
}}),
"[project]/node_modules/tapable/lib/MultiHook.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ const Hook = __turbopack_context__.r("[project]/node_modules/tapable/lib/Hook.js [postcss] (ecmascript)");
class MultiHook {
    constructor(hooks, name = undefined){
        this.hooks = hooks;
        this.name = name;
    }
    tap(options, fn) {
        for (const hook of this.hooks){
            hook.tap(options, fn);
        }
    }
    tapAsync(options, fn) {
        for (const hook of this.hooks){
            hook.tapAsync(options, fn);
        }
    }
    tapPromise(options, fn) {
        for (const hook of this.hooks){
            hook.tapPromise(options, fn);
        }
    }
    isUsed() {
        for (const hook of this.hooks){
            if (hook.isUsed()) return true;
        }
        return false;
    }
    intercept(interceptor) {
        for (const hook of this.hooks){
            hook.intercept(interceptor);
        }
    }
    withOptions(options) {
        return new MultiHook(this.hooks.map((h)=>h.withOptions(options)), this.name);
    }
}
module.exports = MultiHook;
}}),
"[project]/node_modules/tapable/lib/index.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/ exports.__esModule = true;
exports.SyncHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/SyncHook.js [postcss] (ecmascript)");
exports.SyncBailHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/SyncBailHook.js [postcss] (ecmascript)");
exports.SyncWaterfallHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/SyncWaterfallHook.js [postcss] (ecmascript)");
exports.SyncLoopHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/SyncLoopHook.js [postcss] (ecmascript)");
exports.AsyncParallelHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/AsyncParallelHook.js [postcss] (ecmascript)");
exports.AsyncParallelBailHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/AsyncParallelBailHook.js [postcss] (ecmascript)");
exports.AsyncSeriesHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/AsyncSeriesHook.js [postcss] (ecmascript)");
exports.AsyncSeriesBailHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/AsyncSeriesBailHook.js [postcss] (ecmascript)");
exports.AsyncSeriesLoopHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/AsyncSeriesLoopHook.js [postcss] (ecmascript)");
exports.AsyncSeriesWaterfallHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/AsyncSeriesWaterfallHook.js [postcss] (ecmascript)");
exports.HookMap = __turbopack_context__.r("[project]/node_modules/tapable/lib/HookMap.js [postcss] (ecmascript)");
exports.MultiHook = __turbopack_context__.r("[project]/node_modules/tapable/lib/MultiHook.js [postcss] (ecmascript)");
}}),
"[project]/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/vlq.ts
__turbopack_context__.s({
    "decode": ()=>decode,
    "decodeGeneratedRanges": ()=>decodeGeneratedRanges,
    "decodeOriginalScopes": ()=>decodeOriginalScopes,
    "encode": ()=>encode,
    "encodeGeneratedRanges": ()=>encodeGeneratedRanges,
    "encodeOriginalScopes": ()=>encodeOriginalScopes
});
var comma = ",".charCodeAt(0);
var semicolon = ";".charCodeAt(0);
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var intToChar = new Uint8Array(64);
var charToInt = new Uint8Array(128);
for(let i = 0; i < chars.length; i++){
    const c = chars.charCodeAt(i);
    intToChar[i] = c;
    charToInt[c] = i;
}
function decodeInteger(reader, relative) {
    let value = 0;
    let shift = 0;
    let integer = 0;
    do {
        const c = reader.next();
        integer = charToInt[c];
        value |= (integer & 31) << shift;
        shift += 5;
    }while (integer & 32)
    const shouldNegate = value & 1;
    value >>>= 1;
    if (shouldNegate) {
        value = -2147483648 | -value;
    }
    return relative + value;
}
function encodeInteger(builder, num, relative) {
    let delta = num - relative;
    delta = delta < 0 ? -delta << 1 | 1 : delta << 1;
    do {
        let clamped = delta & 31;
        delta >>>= 5;
        if (delta > 0) clamped |= 32;
        builder.write(intToChar[clamped]);
    }while (delta > 0)
    return num;
}
function hasMoreVlq(reader, max) {
    if (reader.pos >= max) return false;
    return reader.peek() !== comma;
}
// src/strings.ts
var bufLength = 1024 * 16;
var td = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? {
    decode (buf) {
        const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
        return out.toString();
    }
} : {
    decode (buf) {
        let out = "";
        for(let i = 0; i < buf.length; i++){
            out += String.fromCharCode(buf[i]);
        }
        return out;
    }
};
var StringWriter = class {
    constructor(){
        this.pos = 0;
        this.out = "";
        this.buffer = new Uint8Array(bufLength);
    }
    write(v) {
        const { buffer } = this;
        buffer[this.pos++] = v;
        if (this.pos === bufLength) {
            this.out += td.decode(buffer);
            this.pos = 0;
        }
    }
    flush() {
        const { buffer, out, pos } = this;
        return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;
    }
};
var StringReader = class {
    constructor(buffer){
        this.pos = 0;
        this.buffer = buffer;
    }
    next() {
        return this.buffer.charCodeAt(this.pos++);
    }
    peek() {
        return this.buffer.charCodeAt(this.pos);
    }
    indexOf(char) {
        const { buffer, pos } = this;
        const idx = buffer.indexOf(char, pos);
        return idx === -1 ? buffer.length : idx;
    }
};
// src/scopes.ts
var EMPTY = [];
function decodeOriginalScopes(input) {
    const { length } = input;
    const reader = new StringReader(input);
    const scopes = [];
    const stack = [];
    let line = 0;
    for(; reader.pos < length; reader.pos++){
        line = decodeInteger(reader, line);
        const column = decodeInteger(reader, 0);
        if (!hasMoreVlq(reader, length)) {
            const last = stack.pop();
            last[2] = line;
            last[3] = column;
            continue;
        }
        const kind = decodeInteger(reader, 0);
        const fields = decodeInteger(reader, 0);
        const hasName = fields & 1;
        const scope = hasName ? [
            line,
            column,
            0,
            0,
            kind,
            decodeInteger(reader, 0)
        ] : [
            line,
            column,
            0,
            0,
            kind
        ];
        let vars = EMPTY;
        if (hasMoreVlq(reader, length)) {
            vars = [];
            do {
                const varsIndex = decodeInteger(reader, 0);
                vars.push(varsIndex);
            }while (hasMoreVlq(reader, length))
        }
        scope.vars = vars;
        scopes.push(scope);
        stack.push(scope);
    }
    return scopes;
}
function encodeOriginalScopes(scopes) {
    const writer = new StringWriter();
    for(let i = 0; i < scopes.length;){
        i = _encodeOriginalScopes(scopes, i, writer, [
            0
        ]);
    }
    return writer.flush();
}
function _encodeOriginalScopes(scopes, index, writer, state) {
    const scope = scopes[index];
    const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;
    if (index > 0) writer.write(comma);
    state[0] = encodeInteger(writer, startLine, state[0]);
    encodeInteger(writer, startColumn, 0);
    encodeInteger(writer, kind, 0);
    const fields = scope.length === 6 ? 1 : 0;
    encodeInteger(writer, fields, 0);
    if (scope.length === 6) encodeInteger(writer, scope[5], 0);
    for (const v of vars){
        encodeInteger(writer, v, 0);
    }
    for(index++; index < scopes.length;){
        const next = scopes[index];
        const { 0: l, 1: c } = next;
        if (l > endLine || l === endLine && c >= endColumn) {
            break;
        }
        index = _encodeOriginalScopes(scopes, index, writer, state);
    }
    writer.write(comma);
    state[0] = encodeInteger(writer, endLine, state[0]);
    encodeInteger(writer, endColumn, 0);
    return index;
}
function decodeGeneratedRanges(input) {
    const { length } = input;
    const reader = new StringReader(input);
    const ranges = [];
    const stack = [];
    let genLine = 0;
    let definitionSourcesIndex = 0;
    let definitionScopeIndex = 0;
    let callsiteSourcesIndex = 0;
    let callsiteLine = 0;
    let callsiteColumn = 0;
    let bindingLine = 0;
    let bindingColumn = 0;
    do {
        const semi = reader.indexOf(";");
        let genColumn = 0;
        for(; reader.pos < semi; reader.pos++){
            genColumn = decodeInteger(reader, genColumn);
            if (!hasMoreVlq(reader, semi)) {
                const last = stack.pop();
                last[2] = genLine;
                last[3] = genColumn;
                continue;
            }
            const fields = decodeInteger(reader, 0);
            const hasDefinition = fields & 1;
            const hasCallsite = fields & 2;
            const hasScope = fields & 4;
            let callsite = null;
            let bindings = EMPTY;
            let range;
            if (hasDefinition) {
                const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);
                definitionScopeIndex = decodeInteger(reader, definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0);
                definitionSourcesIndex = defSourcesIndex;
                range = [
                    genLine,
                    genColumn,
                    0,
                    0,
                    defSourcesIndex,
                    definitionScopeIndex
                ];
            } else {
                range = [
                    genLine,
                    genColumn,
                    0,
                    0
                ];
            }
            range.isScope = !!hasScope;
            if (hasCallsite) {
                const prevCsi = callsiteSourcesIndex;
                const prevLine = callsiteLine;
                callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);
                const sameSource = prevCsi === callsiteSourcesIndex;
                callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);
                callsiteColumn = decodeInteger(reader, sameSource && prevLine === callsiteLine ? callsiteColumn : 0);
                callsite = [
                    callsiteSourcesIndex,
                    callsiteLine,
                    callsiteColumn
                ];
            }
            range.callsite = callsite;
            if (hasMoreVlq(reader, semi)) {
                bindings = [];
                do {
                    bindingLine = genLine;
                    bindingColumn = genColumn;
                    const expressionsCount = decodeInteger(reader, 0);
                    let expressionRanges;
                    if (expressionsCount < -1) {
                        expressionRanges = [
                            [
                                decodeInteger(reader, 0)
                            ]
                        ];
                        for(let i = -1; i > expressionsCount; i--){
                            const prevBl = bindingLine;
                            bindingLine = decodeInteger(reader, bindingLine);
                            bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);
                            const expression = decodeInteger(reader, 0);
                            expressionRanges.push([
                                expression,
                                bindingLine,
                                bindingColumn
                            ]);
                        }
                    } else {
                        expressionRanges = [
                            [
                                expressionsCount
                            ]
                        ];
                    }
                    bindings.push(expressionRanges);
                }while (hasMoreVlq(reader, semi))
            }
            range.bindings = bindings;
            ranges.push(range);
            stack.push(range);
        }
        genLine++;
        reader.pos = semi + 1;
    }while (reader.pos < length)
    return ranges;
}
function encodeGeneratedRanges(ranges) {
    if (ranges.length === 0) return "";
    const writer = new StringWriter();
    for(let i = 0; i < ranges.length;){
        i = _encodeGeneratedRanges(ranges, i, writer, [
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]);
    }
    return writer.flush();
}
function _encodeGeneratedRanges(ranges, index, writer, state) {
    const range = ranges[index];
    const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, isScope, callsite, bindings } = range;
    if (state[0] < startLine) {
        catchupLine(writer, state[0], startLine);
        state[0] = startLine;
        state[1] = 0;
    } else if (index > 0) {
        writer.write(comma);
    }
    state[1] = encodeInteger(writer, range[1], state[1]);
    const fields = (range.length === 6 ? 1 : 0) | (callsite ? 2 : 0) | (isScope ? 4 : 0);
    encodeInteger(writer, fields, 0);
    if (range.length === 6) {
        const { 4: sourcesIndex, 5: scopesIndex } = range;
        if (sourcesIndex !== state[2]) {
            state[3] = 0;
        }
        state[2] = encodeInteger(writer, sourcesIndex, state[2]);
        state[3] = encodeInteger(writer, scopesIndex, state[3]);
    }
    if (callsite) {
        const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite;
        if (sourcesIndex !== state[4]) {
            state[5] = 0;
            state[6] = 0;
        } else if (callLine !== state[5]) {
            state[6] = 0;
        }
        state[4] = encodeInteger(writer, sourcesIndex, state[4]);
        state[5] = encodeInteger(writer, callLine, state[5]);
        state[6] = encodeInteger(writer, callColumn, state[6]);
    }
    if (bindings) {
        for (const binding of bindings){
            if (binding.length > 1) encodeInteger(writer, -binding.length, 0);
            const expression = binding[0][0];
            encodeInteger(writer, expression, 0);
            let bindingStartLine = startLine;
            let bindingStartColumn = startColumn;
            for(let i = 1; i < binding.length; i++){
                const expRange = binding[i];
                bindingStartLine = encodeInteger(writer, expRange[1], bindingStartLine);
                bindingStartColumn = encodeInteger(writer, expRange[2], bindingStartColumn);
                encodeInteger(writer, expRange[0], 0);
            }
        }
    }
    for(index++; index < ranges.length;){
        const next = ranges[index];
        const { 0: l, 1: c } = next;
        if (l > endLine || l === endLine && c >= endColumn) {
            break;
        }
        index = _encodeGeneratedRanges(ranges, index, writer, state);
    }
    if (state[0] < endLine) {
        catchupLine(writer, state[0], endLine);
        state[0] = endLine;
        state[1] = 0;
    } else {
        writer.write(comma);
    }
    state[1] = encodeInteger(writer, endColumn, state[1]);
    return index;
}
function catchupLine(writer, lastLine, line) {
    do {
        writer.write(semicolon);
    }while (++lastLine < line)
}
// src/sourcemap-codec.ts
function decode(mappings) {
    const { length } = mappings;
    const reader = new StringReader(mappings);
    const decoded = [];
    let genColumn = 0;
    let sourcesIndex = 0;
    let sourceLine = 0;
    let sourceColumn = 0;
    let namesIndex = 0;
    do {
        const semi = reader.indexOf(";");
        const line = [];
        let sorted = true;
        let lastCol = 0;
        genColumn = 0;
        while(reader.pos < semi){
            let seg;
            genColumn = decodeInteger(reader, genColumn);
            if (genColumn < lastCol) sorted = false;
            lastCol = genColumn;
            if (hasMoreVlq(reader, semi)) {
                sourcesIndex = decodeInteger(reader, sourcesIndex);
                sourceLine = decodeInteger(reader, sourceLine);
                sourceColumn = decodeInteger(reader, sourceColumn);
                if (hasMoreVlq(reader, semi)) {
                    namesIndex = decodeInteger(reader, namesIndex);
                    seg = [
                        genColumn,
                        sourcesIndex,
                        sourceLine,
                        sourceColumn,
                        namesIndex
                    ];
                } else {
                    seg = [
                        genColumn,
                        sourcesIndex,
                        sourceLine,
                        sourceColumn
                    ];
                }
            } else {
                seg = [
                    genColumn
                ];
            }
            line.push(seg);
            reader.pos++;
        }
        if (!sorted) sort(line);
        decoded.push(line);
        reader.pos = semi + 1;
    }while (reader.pos <= length)
    return decoded;
}
function sort(line) {
    line.sort(sortComparator);
}
function sortComparator(a, b) {
    return a[0] - b[0];
}
function encode(decoded) {
    const writer = new StringWriter();
    let sourcesIndex = 0;
    let sourceLine = 0;
    let sourceColumn = 0;
    let namesIndex = 0;
    for(let i = 0; i < decoded.length; i++){
        const line = decoded[i];
        if (i > 0) writer.write(semicolon);
        if (line.length === 0) continue;
        let genColumn = 0;
        for(let j = 0; j < line.length; j++){
            const segment = line[j];
            if (j > 0) writer.write(comma);
            genColumn = encodeInteger(writer, segment[0], genColumn);
            if (segment.length === 1) continue;
            sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
            sourceLine = encodeInteger(writer, segment[2], sourceLine);
            sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
            if (segment.length === 4) continue;
            namesIndex = encodeInteger(writer, segment[4], namesIndex);
        }
    }
    return writer.flush();
}
;
 //# sourceMappingURL=sourcemap-codec.mjs.map
}),
"[project]/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.mjs [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// Matches the scheme of a URL, eg "http://"
__turbopack_context__.s({
    "default": ()=>resolve
});
const schemeRegex = /^[\w+.-]+:\/\//;
/**
 * Matches the parts of a URL:
 * 1. Scheme, including ":", guaranteed.
 * 2. User/password, including "@", optional.
 * 3. Host, guaranteed.
 * 4. Port, including ":", optional.
 * 5. Path, including "/", optional.
 * 6. Query, including "?", optional.
 * 7. Hash, including "#", optional.
 */ const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
/**
 * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start
 * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).
 *
 * 1. Host, optional.
 * 2. Path, which may include "/", guaranteed.
 * 3. Query, including "?", optional.
 * 4. Hash, including "#", optional.
 */ const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
function isAbsoluteUrl(input) {
    return schemeRegex.test(input);
}
function isSchemeRelativeUrl(input) {
    return input.startsWith('//');
}
function isAbsolutePath(input) {
    return input.startsWith('/');
}
function isFileUrl(input) {
    return input.startsWith('file:');
}
function isRelative(input) {
    return /^[.?#]/.test(input);
}
function parseAbsoluteUrl(input) {
    const match = urlRegex.exec(input);
    return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');
}
function parseFileUrl(input) {
    const match = fileRegex.exec(input);
    const path = match[2];
    return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');
}
function makeUrl(scheme, user, host, port, path, query, hash) {
    return {
        scheme,
        user,
        host,
        port,
        path,
        query,
        hash,
        type: 7 /* Absolute */ 
    };
}
function parseUrl(input) {
    if (isSchemeRelativeUrl(input)) {
        const url = parseAbsoluteUrl('http:' + input);
        url.scheme = '';
        url.type = 6 /* SchemeRelative */ ;
        return url;
    }
    if (isAbsolutePath(input)) {
        const url = parseAbsoluteUrl('http://foo.com' + input);
        url.scheme = '';
        url.host = '';
        url.type = 5 /* AbsolutePath */ ;
        return url;
    }
    if (isFileUrl(input)) return parseFileUrl(input);
    if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);
    const url = parseAbsoluteUrl('http://foo.com/' + input);
    url.scheme = '';
    url.host = '';
    url.type = input ? input.startsWith('?') ? 3 /* Query */  : input.startsWith('#') ? 2 /* Hash */  : 4 /* RelativePath */  : 1 /* Empty */ ;
    return url;
}
function stripPathFilename(path) {
    // If a path ends with a parent directory "..", then it's a relative path with excess parent
    // paths. It's not a file, so we can't strip it.
    if (path.endsWith('/..')) return path;
    const index = path.lastIndexOf('/');
    return path.slice(0, index + 1);
}
function mergePaths(url, base) {
    normalizePath(base, base.type);
    // If the path is just a "/", then it was an empty path to begin with (remember, we're a relative
    // path).
    if (url.path === '/') {
        url.path = base.path;
    } else {
        // Resolution happens relative to the base path's directory, not the file.
        url.path = stripPathFilename(base.path) + url.path;
    }
}
/**
 * The path can have empty directories "//", unneeded parents "foo/..", or current directory
 * "foo/.". We need to normalize to a standard representation.
 */ function normalizePath(url, type) {
    const rel = type <= 4 /* RelativePath */ ;
    const pieces = url.path.split('/');
    // We need to preserve the first piece always, so that we output a leading slash. The item at
    // pieces[0] is an empty string.
    let pointer = 1;
    // Positive is the number of real directories we've output, used for popping a parent directory.
    // Eg, "foo/bar/.." will have a positive 2, and we can decrement to be left with just "foo".
    let positive = 0;
    // We need to keep a trailing slash if we encounter an empty directory (eg, splitting "foo/" will
    // generate `["foo", ""]` pieces). And, if we pop a parent directory. But once we encounter a
    // real directory, we won't need to append, unless the other conditions happen again.
    let addTrailingSlash = false;
    for(let i = 1; i < pieces.length; i++){
        const piece = pieces[i];
        // An empty directory, could be a trailing slash, or just a double "//" in the path.
        if (!piece) {
            addTrailingSlash = true;
            continue;
        }
        // If we encounter a real directory, then we don't need to append anymore.
        addTrailingSlash = false;
        // A current directory, which we can always drop.
        if (piece === '.') continue;
        // A parent directory, we need to see if there are any real directories we can pop. Else, we
        // have an excess of parents, and we'll need to keep the "..".
        if (piece === '..') {
            if (positive) {
                addTrailingSlash = true;
                positive--;
                pointer--;
            } else if (rel) {
                // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute
                // URL, protocol relative URL, or an absolute path, we don't need to keep excess.
                pieces[pointer++] = piece;
            }
            continue;
        }
        // We've encountered a real directory. Move it to the next insertion pointer, which accounts for
        // any popped or dropped directories.
        pieces[pointer++] = piece;
        positive++;
    }
    let path = '';
    for(let i = 1; i < pointer; i++){
        path += '/' + pieces[i];
    }
    if (!path || addTrailingSlash && !path.endsWith('/..')) {
        path += '/';
    }
    url.path = path;
}
/**
 * Attempts to resolve `input` URL/path relative to `base`.
 */ function resolve(input, base) {
    if (!input && !base) return '';
    const url = parseUrl(input);
    let inputType = url.type;
    if (base && inputType !== 7 /* Absolute */ ) {
        const baseUrl = parseUrl(base);
        const baseType = baseUrl.type;
        switch(inputType){
            case 1 /* Empty */ :
                url.hash = baseUrl.hash;
            // fall through
            case 2 /* Hash */ :
                url.query = baseUrl.query;
            // fall through
            case 3 /* Query */ :
            case 4 /* RelativePath */ :
                mergePaths(url, baseUrl);
            // fall through
            case 5 /* AbsolutePath */ :
                // The host, user, and port are joined, you can't copy one without the others.
                url.user = baseUrl.user;
                url.host = baseUrl.host;
                url.port = baseUrl.port;
            // fall through
            case 6 /* SchemeRelative */ :
                // The input doesn't have a schema at least, so we need to copy at least that over.
                url.scheme = baseUrl.scheme;
        }
        if (baseType > inputType) inputType = baseType;
    }
    normalizePath(url, inputType);
    const queryHash = url.query + url.hash;
    switch(inputType){
        // This is impossible, because of the empty checks at the start of the function.
        // case UrlType.Empty:
        case 2 /* Hash */ :
        case 3 /* Query */ :
            return queryHash;
        case 4 /* RelativePath */ :
            {
                // The first char is always a "/", and we need it to be relative.
                const path = url.path.slice(1);
                if (!path) return queryHash || '.';
                if (isRelative(base || input) && !isRelative(path)) {
                    // If base started with a leading ".", or there is no base and input started with a ".",
                    // then we need to ensure that the relative path starts with a ".". We don't know if
                    // relative starts with a "..", though, so check before prepending.
                    return './' + path + queryHash;
                }
                return path + queryHash;
            }
        case 5 /* AbsolutePath */ :
            return url.path + queryHash;
        default:
            return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;
    }
}
;
 //# sourceMappingURL=resolve-uri.mjs.map
}),
"[project]/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/trace-mapping.ts
__turbopack_context__.s({
    "AnyMap": ()=>FlattenMap,
    "FlattenMap": ()=>FlattenMap,
    "GREATEST_LOWER_BOUND": ()=>GREATEST_LOWER_BOUND,
    "LEAST_UPPER_BOUND": ()=>LEAST_UPPER_BOUND,
    "TraceMap": ()=>TraceMap,
    "allGeneratedPositionsFor": ()=>allGeneratedPositionsFor,
    "decodedMap": ()=>decodedMap,
    "decodedMappings": ()=>decodedMappings,
    "eachMapping": ()=>eachMapping,
    "encodedMap": ()=>encodedMap,
    "encodedMappings": ()=>encodedMappings,
    "generatedPositionFor": ()=>generatedPositionFor,
    "isIgnored": ()=>isIgnored,
    "originalPositionFor": ()=>originalPositionFor,
    "presortedDecodedMap": ()=>presortedDecodedMap,
    "sourceContentFor": ()=>sourceContentFor,
    "traceSegment": ()=>traceSegment
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$sourcemap$2d$codec$2f$dist$2f$sourcemap$2d$codec$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs [postcss] (ecmascript)");
// src/resolve.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$resolve$2d$uri$2f$dist$2f$resolve$2d$uri$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.mjs [postcss] (ecmascript)");
;
;
// src/strip-filename.ts
function stripFilename(path) {
    if (!path) return "";
    const index = path.lastIndexOf("/");
    return path.slice(0, index + 1);
}
// src/resolve.ts
function resolver(mapUrl, sourceRoot) {
    const from = stripFilename(mapUrl);
    const prefix = sourceRoot ? sourceRoot + "/" : "";
    return (source)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$resolve$2d$uri$2f$dist$2f$resolve$2d$uri$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["default"])(prefix + (source || ""), from);
}
// src/sourcemap-segment.ts
var COLUMN = 0;
var SOURCES_INDEX = 1;
var SOURCE_LINE = 2;
var SOURCE_COLUMN = 3;
var NAMES_INDEX = 4;
var REV_GENERATED_LINE = 1;
var REV_GENERATED_COLUMN = 2;
// src/sort.ts
function maybeSort(mappings, owned) {
    const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
    if (unsortedIndex === mappings.length) return mappings;
    if (!owned) mappings = mappings.slice();
    for(let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)){
        mappings[i] = sortSegments(mappings[i], owned);
    }
    return mappings;
}
function nextUnsortedSegmentLine(mappings, start) {
    for(let i = start; i < mappings.length; i++){
        if (!isSorted(mappings[i])) return i;
    }
    return mappings.length;
}
function isSorted(line) {
    for(let j = 1; j < line.length; j++){
        if (line[j][COLUMN] < line[j - 1][COLUMN]) {
            return false;
        }
    }
    return true;
}
function sortSegments(line, owned) {
    if (!owned) line = line.slice();
    return line.sort(sortComparator);
}
function sortComparator(a, b) {
    return a[COLUMN] - b[COLUMN];
}
// src/binary-search.ts
var found = false;
function binarySearch(haystack, needle, low, high) {
    while(low <= high){
        const mid = low + (high - low >> 1);
        const cmp = haystack[mid][COLUMN] - needle;
        if (cmp === 0) {
            found = true;
            return mid;
        }
        if (cmp < 0) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    found = false;
    return low - 1;
}
function upperBound(haystack, needle, index) {
    for(let i = index + 1; i < haystack.length; index = i++){
        if (haystack[i][COLUMN] !== needle) break;
    }
    return index;
}
function lowerBound(haystack, needle, index) {
    for(let i = index - 1; i >= 0; index = i--){
        if (haystack[i][COLUMN] !== needle) break;
    }
    return index;
}
function memoizedState() {
    return {
        lastKey: -1,
        lastNeedle: -1,
        lastIndex: -1
    };
}
function memoizedBinarySearch(haystack, needle, state, key) {
    const { lastKey, lastNeedle, lastIndex } = state;
    let low = 0;
    let high = haystack.length - 1;
    if (key === lastKey) {
        if (needle === lastNeedle) {
            found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
            return lastIndex;
        }
        if (needle >= lastNeedle) {
            low = lastIndex === -1 ? 0 : lastIndex;
        } else {
            high = lastIndex;
        }
    }
    state.lastKey = key;
    state.lastNeedle = needle;
    return state.lastIndex = binarySearch(haystack, needle, low, high);
}
// src/by-source.ts
function buildBySources(decoded, memos) {
    const sources = memos.map(buildNullArray);
    for(let i = 0; i < decoded.length; i++){
        const line = decoded[i];
        for(let j = 0; j < line.length; j++){
            const seg = line[j];
            if (seg.length === 1) continue;
            const sourceIndex2 = seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            const originalSource = sources[sourceIndex2];
            const originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);
            const memo = memos[sourceIndex2];
            let index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));
            memo.lastIndex = ++index;
            insert(originalLine, index, [
                sourceColumn,
                i,
                seg[COLUMN]
            ]);
        }
    }
    return sources;
}
function insert(array, index, value) {
    for(let i = array.length; i > index; i--){
        array[i] = array[i - 1];
    }
    array[index] = value;
}
function buildNullArray() {
    return {
        __proto__: null
    };
}
// src/types.ts
function parse(map) {
    return typeof map === "string" ? JSON.parse(map) : map;
}
// src/flatten-map.ts
var FlattenMap = function(map, mapUrl) {
    const parsed = parse(map);
    if (!("sections" in parsed)) {
        return new TraceMap(parsed, mapUrl);
    }
    const mappings = [];
    const sources = [];
    const sourcesContent = [];
    const names = [];
    const ignoreList = [];
    recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, ignoreList, 0, 0, Infinity, Infinity);
    const joined = {
        version: 3,
        file: parsed.file,
        names,
        sources,
        sourcesContent,
        mappings,
        ignoreList
    };
    return presortedDecodedMap(joined);
};
function recurse(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
    const { sections } = input;
    for(let i = 0; i < sections.length; i++){
        const { map, offset } = sections[i];
        let sl = stopLine;
        let sc = stopColumn;
        if (i + 1 < sections.length) {
            const nextOffset = sections[i + 1].offset;
            sl = Math.min(stopLine, lineOffset + nextOffset.line);
            if (sl === stopLine) {
                sc = Math.min(stopColumn, columnOffset + nextOffset.column);
            } else if (sl < stopLine) {
                sc = columnOffset + nextOffset.column;
            }
        }
        addSection(map, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset + offset.line, columnOffset + offset.column, sl, sc);
    }
}
function addSection(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
    const parsed = parse(input);
    if ("sections" in parsed) return recurse(...arguments);
    const map = new TraceMap(parsed, mapUrl);
    const sourcesOffset = sources.length;
    const namesOffset = names.length;
    const decoded = decodedMappings(map);
    const { resolvedSources, sourcesContent: contents, ignoreList: ignores } = map;
    append(sources, resolvedSources);
    append(names, map.names);
    if (contents) append(sourcesContent, contents);
    else for(let i = 0; i < resolvedSources.length; i++)sourcesContent.push(null);
    if (ignores) for(let i = 0; i < ignores.length; i++)ignoreList.push(ignores[i] + sourcesOffset);
    for(let i = 0; i < decoded.length; i++){
        const lineI = lineOffset + i;
        if (lineI > stopLine) return;
        const out = getLine(mappings, lineI);
        const cOffset = i === 0 ? columnOffset : 0;
        const line = decoded[i];
        for(let j = 0; j < line.length; j++){
            const seg = line[j];
            const column = cOffset + seg[COLUMN];
            if (lineI === stopLine && column >= stopColumn) return;
            if (seg.length === 1) {
                out.push([
                    column
                ]);
                continue;
            }
            const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            out.push(seg.length === 4 ? [
                column,
                sourcesIndex,
                sourceLine,
                sourceColumn
            ] : [
                column,
                sourcesIndex,
                sourceLine,
                sourceColumn,
                namesOffset + seg[NAMES_INDEX]
            ]);
        }
    }
}
function append(arr, other) {
    for(let i = 0; i < other.length; i++)arr.push(other[i]);
}
function getLine(arr, index) {
    for(let i = arr.length; i <= index; i++)arr[i] = [];
    return arr[index];
}
// src/trace-mapping.ts
var LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
var COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
var LEAST_UPPER_BOUND = -1;
var GREATEST_LOWER_BOUND = 1;
var TraceMap = class {
    constructor(map, mapUrl){
        const isString = typeof map === "string";
        if (!isString && map._decodedMemo) return map;
        const parsed = parse(map);
        const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;
        this.version = version;
        this.file = file;
        this.names = names || [];
        this.sourceRoot = sourceRoot;
        this.sources = sources;
        this.sourcesContent = sourcesContent;
        this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;
        const resolve = resolver(mapUrl, sourceRoot);
        this.resolvedSources = sources.map(resolve);
        const { mappings } = parsed;
        if (typeof mappings === "string") {
            this._encoded = mappings;
            this._decoded = void 0;
        } else if (Array.isArray(mappings)) {
            this._encoded = void 0;
            this._decoded = maybeSort(mappings, isString);
        } else if (parsed.sections) {
            throw new Error(`TraceMap passed sectioned source map, please use FlattenMap export instead`);
        } else {
            throw new Error(`invalid source map: ${JSON.stringify(parsed)}`);
        }
        this._decodedMemo = memoizedState();
        this._bySources = void 0;
        this._bySourceMemos = void 0;
    }
};
function cast(map) {
    return map;
}
function encodedMappings(map) {
    var _a, _b;
    return (_b = (_a = cast(map))._encoded) != null ? _b : _a._encoded = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$sourcemap$2d$codec$2f$dist$2f$sourcemap$2d$codec$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["encode"])(cast(map)._decoded);
}
function decodedMappings(map) {
    var _a;
    return (_a = cast(map))._decoded || (_a._decoded = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$sourcemap$2d$codec$2f$dist$2f$sourcemap$2d$codec$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["decode"])(cast(map)._encoded));
}
function traceSegment(map, line, column) {
    const decoded = decodedMappings(map);
    if (line >= decoded.length) return null;
    const segments = decoded[line];
    const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, GREATEST_LOWER_BOUND);
    return index === -1 ? null : segments[index];
}
function originalPositionFor(map, needle) {
    let { line, column, bias } = needle;
    line--;
    if (line < 0) throw new Error(LINE_GTR_ZERO);
    if (column < 0) throw new Error(COL_GTR_EQ_ZERO);
    const decoded = decodedMappings(map);
    if (line >= decoded.length) return OMapping(null, null, null, null);
    const segments = decoded[line];
    const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
    if (index === -1) return OMapping(null, null, null, null);
    const segment = segments[index];
    if (segment.length === 1) return OMapping(null, null, null, null);
    const { names, resolvedSources } = map;
    return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);
}
function generatedPositionFor(map, needle) {
    const { source, line, column, bias } = needle;
    return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);
}
function allGeneratedPositionsFor(map, needle) {
    const { source, line, column, bias } = needle;
    return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);
}
function eachMapping(map, cb) {
    const decoded = decodedMappings(map);
    const { names, resolvedSources } = map;
    for(let i = 0; i < decoded.length; i++){
        const line = decoded[i];
        for(let j = 0; j < line.length; j++){
            const seg = line[j];
            const generatedLine = i + 1;
            const generatedColumn = seg[0];
            let source = null;
            let originalLine = null;
            let originalColumn = null;
            let name = null;
            if (seg.length !== 1) {
                source = resolvedSources[seg[1]];
                originalLine = seg[2] + 1;
                originalColumn = seg[3];
            }
            if (seg.length === 5) name = names[seg[4]];
            cb({
                generatedLine,
                generatedColumn,
                source,
                originalLine,
                originalColumn,
                name
            });
        }
    }
}
function sourceIndex(map, source) {
    const { sources, resolvedSources } = map;
    let index = sources.indexOf(source);
    if (index === -1) index = resolvedSources.indexOf(source);
    return index;
}
function sourceContentFor(map, source) {
    const { sourcesContent } = map;
    if (sourcesContent == null) return null;
    const index = sourceIndex(map, source);
    return index === -1 ? null : sourcesContent[index];
}
function isIgnored(map, source) {
    const { ignoreList } = map;
    if (ignoreList == null) return false;
    const index = sourceIndex(map, source);
    return index === -1 ? false : ignoreList.includes(index);
}
function presortedDecodedMap(map, mapUrl) {
    const tracer = new TraceMap(clone(map, []), mapUrl);
    cast(tracer)._decoded = map.mappings;
    return tracer;
}
function decodedMap(map) {
    return clone(map, decodedMappings(map));
}
function encodedMap(map) {
    return clone(map, encodedMappings(map));
}
function clone(map, mappings) {
    return {
        version: map.version,
        file: map.file,
        names: map.names,
        sourceRoot: map.sourceRoot,
        sources: map.sources,
        sourcesContent: map.sourcesContent,
        mappings,
        ignoreList: map.ignoreList || map.x_google_ignoreList
    };
}
function OMapping(source, line, column, name) {
    return {
        source,
        line,
        column,
        name
    };
}
function GMapping(line, column) {
    return {
        line,
        column
    };
}
function traceSegmentInternal(segments, memo, line, column, bias) {
    let index = memoizedBinarySearch(segments, column, memo, line);
    if (found) {
        index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
    } else if (bias === LEAST_UPPER_BOUND) index++;
    if (index === -1 || index === segments.length) return -1;
    return index;
}
function sliceGeneratedPositions(segments, memo, line, column, bias) {
    let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);
    if (!found && bias === LEAST_UPPER_BOUND) min++;
    if (min === -1 || min === segments.length) return [];
    const matchedColumn = found ? column : segments[min][COLUMN];
    if (!found) min = lowerBound(segments, matchedColumn, min);
    const max = upperBound(segments, matchedColumn, min);
    const result = [];
    for(; min <= max; min++){
        const segment = segments[min];
        result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));
    }
    return result;
}
function generatedPosition(map, source, line, column, bias, all) {
    var _a;
    line--;
    if (line < 0) throw new Error(LINE_GTR_ZERO);
    if (column < 0) throw new Error(COL_GTR_EQ_ZERO);
    const { sources, resolvedSources } = map;
    let sourceIndex2 = sources.indexOf(source);
    if (sourceIndex2 === -1) sourceIndex2 = resolvedSources.indexOf(source);
    if (sourceIndex2 === -1) return all ? [] : GMapping(null, null);
    const generated = (_a = cast(map))._bySources || (_a._bySources = buildBySources(decodedMappings(map), cast(map)._bySourceMemos = sources.map(memoizedState)));
    const segments = generated[sourceIndex2][line];
    if (segments == null) return all ? [] : GMapping(null, null);
    const memo = cast(map)._bySourceMemos[sourceIndex2];
    if (all) return sliceGeneratedPositions(segments, memo, line, column, bias);
    const index = traceSegmentInternal(segments, memo, line, column, bias);
    if (index === -1) return GMapping(null, null);
    const segment = segments[index];
    return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);
}
;
 //# sourceMappingURL=trace-mapping.mjs.map
}),
"[project]/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.mjs [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/set-array.ts
__turbopack_context__.s({
    "GenMapping": ()=>GenMapping,
    "addMapping": ()=>addMapping,
    "addSegment": ()=>addSegment,
    "allMappings": ()=>allMappings,
    "fromMap": ()=>fromMap,
    "maybeAddMapping": ()=>maybeAddMapping,
    "maybeAddSegment": ()=>maybeAddSegment,
    "setIgnore": ()=>setIgnore,
    "setSourceContent": ()=>setSourceContent,
    "toDecodedMap": ()=>toDecodedMap,
    "toEncodedMap": ()=>toEncodedMap
});
// src/gen-mapping.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$sourcemap$2d$codec$2f$dist$2f$sourcemap$2d$codec$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs [postcss] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$trace$2d$mapping$2f$dist$2f$trace$2d$mapping$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs [postcss] (ecmascript)");
var SetArray = class {
    constructor(){
        this._indexes = {
            __proto__: null
        };
        this.array = [];
    }
};
function cast(set) {
    return set;
}
function get(setarr, key) {
    return cast(setarr)._indexes[key];
}
function put(setarr, key) {
    const index = get(setarr, key);
    if (index !== void 0) return index;
    const { array, _indexes: indexes } = cast(setarr);
    const length = array.push(key);
    return indexes[key] = length - 1;
}
function remove(setarr, key) {
    const index = get(setarr, key);
    if (index === void 0) return;
    const { array, _indexes: indexes } = cast(setarr);
    for(let i = index + 1; i < array.length; i++){
        const k = array[i];
        array[i - 1] = k;
        indexes[k]--;
    }
    indexes[key] = void 0;
    array.pop();
}
;
;
// src/sourcemap-segment.ts
var COLUMN = 0;
var SOURCES_INDEX = 1;
var SOURCE_LINE = 2;
var SOURCE_COLUMN = 3;
var NAMES_INDEX = 4;
// src/gen-mapping.ts
var NO_NAME = -1;
var GenMapping = class {
    constructor({ file, sourceRoot } = {}){
        this._names = new SetArray();
        this._sources = new SetArray();
        this._sourcesContent = [];
        this._mappings = [];
        this.file = file;
        this.sourceRoot = sourceRoot;
        this._ignoreList = new SetArray();
    }
};
function cast2(map) {
    return map;
}
function addSegment(map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
    return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
}
function addMapping(map, mapping) {
    return addMappingInternal(false, map, mapping);
}
var maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content)=>{
    return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
};
var maybeAddMapping = (map, mapping)=>{
    return addMappingInternal(true, map, mapping);
};
function setSourceContent(map, source, content) {
    const { _sources: sources, _sourcesContent: sourcesContent } = cast2(map);
    const index = put(sources, source);
    sourcesContent[index] = content;
}
function setIgnore(map, source, ignore = true) {
    const { _sources: sources, _sourcesContent: sourcesContent, _ignoreList: ignoreList } = cast2(map);
    const index = put(sources, source);
    if (index === sourcesContent.length) sourcesContent[index] = null;
    if (ignore) put(ignoreList, index);
    else remove(ignoreList, index);
}
function toDecodedMap(map) {
    const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, _ignoreList: ignoreList } = cast2(map);
    removeEmptyFinalLines(mappings);
    return {
        version: 3,
        file: map.file || void 0,
        names: names.array,
        sourceRoot: map.sourceRoot || void 0,
        sources: sources.array,
        sourcesContent,
        mappings,
        // originalScopes,
        // generatedRanges,
        ignoreList: ignoreList.array
    };
}
function toEncodedMap(map) {
    const decoded = toDecodedMap(map);
    return Object.assign({}, decoded, {
        // originalScopes: decoded.originalScopes.map((os) => encodeOriginalScopes(os)),
        // generatedRanges: encodeGeneratedRanges(decoded.generatedRanges as GeneratedRange[]),
        mappings: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$sourcemap$2d$codec$2f$dist$2f$sourcemap$2d$codec$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["encode"])(decoded.mappings)
    });
}
function fromMap(input) {
    const map = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$trace$2d$mapping$2f$dist$2f$trace$2d$mapping$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["TraceMap"](input);
    const gen = new GenMapping({
        file: map.file,
        sourceRoot: map.sourceRoot
    });
    putAll(cast2(gen)._names, map.names);
    putAll(cast2(gen)._sources, map.sources);
    cast2(gen)._sourcesContent = map.sourcesContent || map.sources.map(()=>null);
    cast2(gen)._mappings = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$trace$2d$mapping$2f$dist$2f$trace$2d$mapping$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["decodedMappings"])(map);
    if (map.ignoreList) putAll(cast2(gen)._ignoreList, map.ignoreList);
    return gen;
}
function allMappings(map) {
    const out = [];
    const { _mappings: mappings, _sources: sources, _names: names } = cast2(map);
    for(let i = 0; i < mappings.length; i++){
        const line = mappings[i];
        for(let j = 0; j < line.length; j++){
            const seg = line[j];
            const generated = {
                line: i + 1,
                column: seg[COLUMN]
            };
            let source = void 0;
            let original = void 0;
            let name = void 0;
            if (seg.length !== 1) {
                source = sources.array[seg[SOURCES_INDEX]];
                original = {
                    line: seg[SOURCE_LINE] + 1,
                    column: seg[SOURCE_COLUMN]
                };
                if (seg.length === 5) name = names.array[seg[NAMES_INDEX]];
            }
            out.push({
                generated,
                source,
                original,
                name
            });
        }
    }
    return out;
}
function addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
    const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = cast2(map);
    const line = getIndex(mappings, genLine);
    const index = getColumnIndex(line, genColumn);
    if (!source) {
        if (skipable && skipSourceless(line, index)) return;
        return insert(line, index, [
            genColumn
        ]);
    }
    assert(sourceLine);
    assert(sourceColumn);
    const sourcesIndex = put(sources, source);
    const namesIndex = name ? put(names, name) : NO_NAME;
    if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = content != null ? content : null;
    if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
        return;
    }
    return insert(line, index, name ? [
        genColumn,
        sourcesIndex,
        sourceLine,
        sourceColumn,
        namesIndex
    ] : [
        genColumn,
        sourcesIndex,
        sourceLine,
        sourceColumn
    ]);
}
function assert(_val) {}
function getIndex(arr, index) {
    for(let i = arr.length; i <= index; i++){
        arr[i] = [];
    }
    return arr[index];
}
function getColumnIndex(line, genColumn) {
    let index = line.length;
    for(let i = index - 1; i >= 0; index = i--){
        const current = line[i];
        if (genColumn >= current[COLUMN]) break;
    }
    return index;
}
function insert(array, index, value) {
    for(let i = array.length; i > index; i--){
        array[i] = array[i - 1];
    }
    array[index] = value;
}
function removeEmptyFinalLines(mappings) {
    const { length } = mappings;
    let len = length;
    for(let i = len - 1; i >= 0; len = i, i--){
        if (mappings[i].length > 0) break;
    }
    if (len < length) mappings.length = len;
}
function putAll(setarr, array) {
    for(let i = 0; i < array.length; i++)put(setarr, array[i]);
}
function skipSourceless(line, index) {
    if (index === 0) return true;
    const prev = line[index - 1];
    return prev.length === 1;
}
function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
    if (index === 0) return false;
    const prev = line[index - 1];
    if (prev.length === 1) return false;
    return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);
}
function addMappingInternal(skipable, map, mapping) {
    const { generated, source, original, name, content } = mapping;
    if (!source) {
        return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);
    }
    assert(original);
    return addSegmentInternal(skipable, map, generated.line - 1, generated.column, source, original.line - 1, original.column, name, content);
}
;
 //# sourceMappingURL=gen-mapping.mjs.map
}),
"[project]/node_modules/@ampproject/remapping/dist/remapping.mjs [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>remapping
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$trace$2d$mapping$2f$dist$2f$trace$2d$mapping$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs [postcss] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$gen$2d$mapping$2f$dist$2f$gen$2d$mapping$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.mjs [postcss] (ecmascript)");
;
;
const SOURCELESS_MAPPING = /* #__PURE__ */ SegmentObject('', -1, -1, '', null, false);
const EMPTY_SOURCES = [];
function SegmentObject(source, line, column, name, content, ignore) {
    return {
        source,
        line,
        column,
        name,
        content,
        ignore
    };
}
function Source(map, sources, source, content, ignore) {
    return {
        map,
        sources,
        source,
        content,
        ignore
    };
}
/**
 * MapSource represents a single sourcemap, with the ability to trace mappings into its child nodes
 * (which may themselves be SourceMapTrees).
 */ function MapSource(map, sources) {
    return Source(map, sources, '', null, false);
}
/**
 * A "leaf" node in the sourcemap tree, representing an original, unmodified source file. Recursive
 * segment tracing ends at the `OriginalSource`.
 */ function OriginalSource(source, content, ignore) {
    return Source(null, EMPTY_SOURCES, source, content, ignore);
}
/**
 * traceMappings is only called on the root level SourceMapTree, and begins the process of
 * resolving each mapping in terms of the original source files.
 */ function traceMappings(tree) {
    // TODO: Eventually support sourceRoot, which has to be removed because the sources are already
    // fully resolved. We'll need to make sources relative to the sourceRoot before adding them.
    const gen = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$gen$2d$mapping$2f$dist$2f$gen$2d$mapping$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["GenMapping"]({
        file: tree.map.file
    });
    const { sources: rootSources, map } = tree;
    const rootNames = map.names;
    const rootMappings = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$trace$2d$mapping$2f$dist$2f$trace$2d$mapping$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["decodedMappings"])(map);
    for(let i = 0; i < rootMappings.length; i++){
        const segments = rootMappings[i];
        for(let j = 0; j < segments.length; j++){
            const segment = segments[j];
            const genCol = segment[0];
            let traced = SOURCELESS_MAPPING;
            // 1-length segments only move the current generated column, there's no source information
            // to gather from it.
            if (segment.length !== 1) {
                const source = rootSources[segment[1]];
                traced = originalPositionFor(source, segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : '');
                // If the trace is invalid, then the trace ran into a sourcemap that doesn't contain a
                // respective segment into an original source.
                if (traced == null) continue;
            }
            const { column, line, name, content, source, ignore } = traced;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$gen$2d$mapping$2f$dist$2f$gen$2d$mapping$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["maybeAddSegment"])(gen, i, genCol, source, line, column, name);
            if (source && content != null) (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$gen$2d$mapping$2f$dist$2f$gen$2d$mapping$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["setSourceContent"])(gen, source, content);
            if (ignore) (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$gen$2d$mapping$2f$dist$2f$gen$2d$mapping$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["setIgnore"])(gen, source, true);
        }
    }
    return gen;
}
/**
 * originalPositionFor is only called on children SourceMapTrees. It recurses down into its own
 * child SourceMapTrees, until we find the original source map.
 */ function originalPositionFor(source, line, column, name) {
    if (!source.map) {
        return SegmentObject(source.source, line, column, name, source.content, source.ignore);
    }
    const segment = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$trace$2d$mapping$2f$dist$2f$trace$2d$mapping$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["traceSegment"])(source.map, line, column);
    // If we couldn't find a segment, then this doesn't exist in the sourcemap.
    if (segment == null) return null;
    // 1-length segments only move the current generated column, there's no source information
    // to gather from it.
    if (segment.length === 1) return SOURCELESS_MAPPING;
    return originalPositionFor(source.sources[segment[1]], segment[2], segment[3], segment.length === 5 ? source.map.names[segment[4]] : name);
}
function asArray(value) {
    if (Array.isArray(value)) return value;
    return [
        value
    ];
}
/**
 * Recursively builds a tree structure out of sourcemap files, with each node
 * being either an `OriginalSource` "leaf" or a `SourceMapTree` composed of
 * `OriginalSource`s and `SourceMapTree`s.
 *
 * Every sourcemap is composed of a collection of source files and mappings
 * into locations of those source files. When we generate a `SourceMapTree` for
 * the sourcemap, we attempt to load each source file's own sourcemap. If it
 * does not have an associated sourcemap, it is considered an original,
 * unmodified source file.
 */ function buildSourceMapTree(input, loader) {
    const maps = asArray(input).map((m)=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$trace$2d$mapping$2f$dist$2f$trace$2d$mapping$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["TraceMap"](m, ''));
    const map = maps.pop();
    for(let i = 0; i < maps.length; i++){
        if (maps[i].sources.length > 1) {
            throw new Error(`Transformation map ${i} must have exactly one source file.\n` + 'Did you specify these with the most recent transformation maps first?');
        }
    }
    let tree = build(map, loader, '', 0);
    for(let i = maps.length - 1; i >= 0; i--){
        tree = MapSource(maps[i], [
            tree
        ]);
    }
    return tree;
}
function build(map, loader, importer, importerDepth) {
    const { resolvedSources, sourcesContent, ignoreList } = map;
    const depth = importerDepth + 1;
    const children = resolvedSources.map((sourceFile, i)=>{
        // The loading context gives the loader more information about why this file is being loaded
        // (eg, from which importer). It also allows the loader to override the location of the loaded
        // sourcemap/original source, or to override the content in the sourcesContent field if it's
        // an unmodified source file.
        const ctx = {
            importer,
            depth,
            source: sourceFile || '',
            content: undefined,
            ignore: undefined
        };
        // Use the provided loader callback to retrieve the file's sourcemap.
        // TODO: We should eventually support async loading of sourcemap files.
        const sourceMap = loader(ctx.source, ctx);
        const { source, content, ignore } = ctx;
        // If there is a sourcemap, then we need to recurse into it to load its source files.
        if (sourceMap) return build(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$trace$2d$mapping$2f$dist$2f$trace$2d$mapping$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["TraceMap"](sourceMap, source), loader, source, depth);
        // Else, it's an unmodified source file.
        // The contents of this unmodified source file can be overridden via the loader context,
        // allowing it to be explicitly null or a string. If it remains undefined, we fall back to
        // the importing sourcemap's `sourcesContent` field.
        const sourceContent = content !== undefined ? content : sourcesContent ? sourcesContent[i] : null;
        const ignored = ignore !== undefined ? ignore : ignoreList ? ignoreList.includes(i) : false;
        return OriginalSource(source, sourceContent, ignored);
    });
    return MapSource(map, children);
}
/**
 * A SourceMap v3 compatible sourcemap, which only includes fields that were
 * provided to it.
 */ class SourceMap {
    constructor(map, options){
        const out = options.decodedMappings ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$gen$2d$mapping$2f$dist$2f$gen$2d$mapping$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["toDecodedMap"])(map) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$gen$2d$mapping$2f$dist$2f$gen$2d$mapping$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["toEncodedMap"])(map);
        this.version = out.version; // SourceMap spec says this should be first.
        this.file = out.file;
        this.mappings = out.mappings;
        this.names = out.names;
        this.ignoreList = out.ignoreList;
        this.sourceRoot = out.sourceRoot;
        this.sources = out.sources;
        if (!options.excludeContent) {
            this.sourcesContent = out.sourcesContent;
        }
    }
    toString() {
        return JSON.stringify(this);
    }
}
/**
 * Traces through all the mappings in the root sourcemap, through the sources
 * (and their sourcemaps), all the way back to the original source location.
 *
 * `loader` will be called every time we encounter a source file. If it returns
 * a sourcemap, we will recurse into that sourcemap to continue the trace. If
 * it returns a falsey value, that source file is treated as an original,
 * unmodified source file.
 *
 * Pass `excludeContent` to exclude any self-containing source file content
 * from the output sourcemap.
 *
 * Pass `decodedMappings` to receive a SourceMap with decoded (instead of
 * VLQ encoded) mappings.
 */ function remapping(input, loader, options) {
    const opts = typeof options === 'object' ? options : {
        excludeContent: !!options,
        decodedMappings: false
    };
    const tree = buildSourceMapTree(input, loader);
    return new SourceMap(traceMappings(tree), opts);
}
;
 //# sourceMappingURL=remapping.mjs.map
}),
"[project]/node_modules/lightningcss/node/browserslistToTargets.js [postcss] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const BROWSER_MAPPING = {
    and_chr: 'chrome',
    and_ff: 'firefox',
    ie_mob: 'ie',
    op_mob: 'opera',
    and_qq: null,
    and_uc: null,
    baidu: null,
    bb: null,
    kaios: null,
    op_mini: null
};
function browserslistToTargets(browserslist) {
    let targets = {};
    for (let browser of browserslist){
        let [name, v] = browser.split(' ');
        if (BROWSER_MAPPING[name] === null) {
            continue;
        }
        let version = parseVersion(v);
        if (version == null) {
            continue;
        }
        if (targets[name] == null || version < targets[name]) {
            targets[name] = version;
        }
    }
    return targets;
}
function parseVersion(version) {
    let [major, minor = 0, patch = 0] = version.split('-')[0].split('.').map((v)=>parseInt(v, 10));
    if (isNaN(major) || isNaN(minor) || isNaN(patch)) {
        return null;
    }
    return major << 16 | minor << 8 | patch;
}
module.exports = browserslistToTargets;
}}),
"[project]/node_modules/lightningcss/node/composeVisitors.js [postcss] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
// @ts-check
/** @typedef {import('./index').Visitor} Visitor */ /**
 * Composes multiple visitor objects into a single one.
 * @param {Visitor[]} visitors 
 * @return {Visitor}
 */ function composeVisitors(visitors) {
    if (visitors.length === 1) {
        return visitors[0];
    }
    /** @type Visitor */ let res = {};
    composeSimpleVisitors(res, visitors, 'StyleSheet');
    composeSimpleVisitors(res, visitors, 'StyleSheetExit');
    composeObjectVisitors(res, visitors, 'Rule', ruleVisitor, wrapCustomAndUnknownAtRule);
    composeObjectVisitors(res, visitors, 'RuleExit', ruleVisitor, wrapCustomAndUnknownAtRule);
    composeObjectVisitors(res, visitors, 'Declaration', declarationVisitor, wrapCustomProperty);
    composeObjectVisitors(res, visitors, 'DeclarationExit', declarationVisitor, wrapCustomProperty);
    composeSimpleVisitors(res, visitors, 'Url');
    composeSimpleVisitors(res, visitors, 'Color');
    composeSimpleVisitors(res, visitors, 'Image');
    composeSimpleVisitors(res, visitors, 'ImageExit');
    composeSimpleVisitors(res, visitors, 'Length');
    composeSimpleVisitors(res, visitors, 'Angle');
    composeSimpleVisitors(res, visitors, 'Ratio');
    composeSimpleVisitors(res, visitors, 'Resolution');
    composeSimpleVisitors(res, visitors, 'Time');
    composeSimpleVisitors(res, visitors, 'CustomIdent');
    composeSimpleVisitors(res, visitors, 'DashedIdent');
    composeArrayFunctions(res, visitors, 'MediaQuery');
    composeArrayFunctions(res, visitors, 'MediaQueryExit');
    composeSimpleVisitors(res, visitors, 'SupportsCondition');
    composeSimpleVisitors(res, visitors, 'SupportsConditionExit');
    composeArrayFunctions(res, visitors, 'Selector');
    composeTokenVisitors(res, visitors, 'Token', 'token', false);
    composeTokenVisitors(res, visitors, 'Function', 'function', false);
    composeTokenVisitors(res, visitors, 'FunctionExit', 'function', true);
    composeTokenVisitors(res, visitors, 'Variable', 'var', false);
    composeTokenVisitors(res, visitors, 'VariableExit', 'var', true);
    composeTokenVisitors(res, visitors, 'EnvironmentVariable', 'env', false);
    composeTokenVisitors(res, visitors, 'EnvironmentVariableExit', 'env', true);
    return res;
}
module.exports = composeVisitors;
function wrapCustomAndUnknownAtRule(k, f) {
    if (k === 'unknown') {
        return (value)=>f({
                type: 'unknown',
                value
            });
    }
    if (k === 'custom') {
        return (value)=>f({
                type: 'custom',
                value
            });
    }
    return f;
}
function wrapCustomProperty(k, f) {
    return k === 'custom' ? (value)=>f({
            property: 'custom',
            value
        }) : f;
}
/**
 * @param {import('./index').Visitor['Rule']} f 
 * @param {import('./ast').Rule} item 
 */ function ruleVisitor(f, item) {
    if (typeof f === 'object') {
        if (item.type === 'unknown') {
            let v = f.unknown;
            if (typeof v === 'object') {
                v = v[item.value.name];
            }
            return v?.(item.value);
        }
        if (item.type === 'custom') {
            let v = f.custom;
            if (typeof v === 'object') {
                v = v[item.value.name];
            }
            return v?.(item.value);
        }
        return f[item.type]?.(item);
    }
    return f?.(item);
}
/**
 * @param {import('./index').Visitor['Declaration']} f 
 * @param {import('./ast').Declaration} item 
 */ function declarationVisitor(f, item) {
    if (typeof f === 'object') {
        /** @type {string} */ let name = item.property;
        if (item.property === 'unparsed') {
            name = item.value.propertyId.property;
        } else if (item.property === 'custom') {
            let v = f.custom;
            if (typeof v === 'object') {
                v = v[item.value.name];
            }
            return v?.(item.value);
        }
        return f[name]?.(item);
    }
    return f?.(item);
}
/**
 * 
 * @param {Visitor[]} visitors 
 * @param {string} key 
 * @returns {[any[], boolean, Set<string>]}
 */ function extractObjectsOrFunctions(visitors, key) {
    let values = [];
    let hasFunction = false;
    let allKeys = new Set();
    for (let visitor of visitors){
        let v = visitor[key];
        if (v) {
            if (typeof v === 'function') {
                hasFunction = true;
            } else {
                for(let key in v){
                    allKeys.add(key);
                }
            }
            values.push(v);
        }
    }
    return [
        values,
        hasFunction,
        allKeys
    ];
}
/**
 * @template {keyof Visitor} K
 * @param {Visitor} res
 * @param {Visitor[]} visitors
 * @param {K} key
 * @param {(visitor: Visitor[K], item: any) => any | any[] | void} apply 
 * @param {(k: string, f: any) => any} wrapKey 
 */ function composeObjectVisitors(res, visitors, key, apply, wrapKey) {
    let [values, hasFunction, allKeys] = extractObjectsOrFunctions(visitors, key);
    if (values.length === 0) {
        return;
    }
    if (values.length === 1) {
        res[key] = values[0];
        return;
    }
    let f = createArrayVisitor(visitors, (visitor, item)=>apply(visitor[key], item));
    if (hasFunction) {
        res[key] = f;
    } else {
        /** @type {any} */ let v = {};
        for (let k of allKeys){
            v[k] = wrapKey(k, f);
        }
        res[key] = v;
    }
}
/**
 * @param {Visitor} res 
 * @param {Visitor[]} visitors 
 * @param {string} key 
 * @param {import('./ast').TokenOrValue['type']} type 
 * @param {boolean} isExit 
 */ function composeTokenVisitors(res, visitors, key, type, isExit) {
    let [values, hasFunction, allKeys] = extractObjectsOrFunctions(visitors, key);
    if (values.length === 0) {
        return;
    }
    if (values.length === 1) {
        res[key] = values[0];
        return;
    }
    let f = createTokenVisitor(visitors, type, isExit);
    if (hasFunction) {
        res[key] = f;
    } else {
        let v = {};
        for (let key of allKeys){
            v[key] = f;
        }
        res[key] = v;
    }
}
/**
 * @param {Visitor[]} visitors 
 * @param {import('./ast').TokenOrValue['type']} type 
 */ function createTokenVisitor(visitors, type, isExit) {
    let v = createArrayVisitor(visitors, (visitor, /** @type {import('./ast').TokenOrValue} */ item)=>{
        let f;
        switch(item.type){
            case 'token':
                f = visitor.Token;
                if (typeof f === 'object') {
                    f = f[item.value.type];
                }
                break;
            case 'function':
                f = isExit ? visitor.FunctionExit : visitor.Function;
                if (typeof f === 'object') {
                    f = f[item.value.name];
                }
                break;
            case 'var':
                f = isExit ? visitor.VariableExit : visitor.Variable;
                break;
            case 'env':
                f = isExit ? visitor.EnvironmentVariableExit : visitor.EnvironmentVariable;
                if (typeof f === 'object') {
                    let name;
                    switch(item.value.name.type){
                        case 'ua':
                        case 'unknown':
                            name = item.value.name.value;
                            break;
                        case 'custom':
                            name = item.value.name.ident;
                            break;
                    }
                    f = f[name];
                }
                break;
            case 'color':
                f = visitor.Color;
                break;
            case 'url':
                f = visitor.Url;
                break;
            case 'length':
                f = visitor.Length;
                break;
            case 'angle':
                f = visitor.Angle;
                break;
            case 'time':
                f = visitor.Time;
                break;
            case 'resolution':
                f = visitor.Resolution;
                break;
            case 'dashed-ident':
                f = visitor.DashedIdent;
                break;
        }
        if (!f) {
            return;
        }
        let res = f(item.value);
        switch(item.type){
            case 'color':
            case 'url':
            case 'length':
            case 'angle':
            case 'time':
            case 'resolution':
            case 'dashed-ident':
                if (Array.isArray(res)) {
                    res = res.map((value)=>({
                            type: item.type,
                            value
                        }));
                } else if (res) {
                    res = {
                        type: item.type,
                        value: res
                    };
                }
                break;
        }
        return res;
    });
    return (value)=>v({
            type,
            value
        });
}
/**
 * @param {Visitor[]} visitors 
 * @param {string} key 
 */ function extractFunctions(visitors, key) {
    let functions = [];
    for (let visitor of visitors){
        let f = visitor[key];
        if (f) {
            functions.push(f);
        }
    }
    return functions;
}
/**
 * @param {Visitor} res 
 * @param {Visitor[]} visitors 
 * @param {string} key 
 */ function composeSimpleVisitors(res, visitors, key) {
    let functions = extractFunctions(visitors, key);
    if (functions.length === 0) {
        return;
    }
    if (functions.length === 1) {
        res[key] = functions[0];
        return;
    }
    res[key] = (arg)=>{
        let mutated = false;
        for (let f of functions){
            let res = f(arg);
            if (res) {
                arg = res;
                mutated = true;
            }
        }
        return mutated ? arg : undefined;
    };
}
/**
 * @param {Visitor} res 
 * @param {Visitor[]} visitors 
 * @param {string} key 
 */ function composeArrayFunctions(res, visitors, key) {
    let functions = extractFunctions(visitors, key);
    if (functions.length === 0) {
        return;
    }
    if (functions.length === 1) {
        res[key] = functions[0];
        return;
    }
    res[key] = createArrayVisitor(functions, (f, item)=>f(item));
}
/**
 * @template T
 * @template V
 * @param {T[]} visitors 
 * @param {(visitor: T, item: V) => V | V[] | void} apply 
 * @returns {(item: V) => V | V[] | void}
 */ function createArrayVisitor(visitors, apply) {
    let seen = new Bitset(visitors.length);
    return (arg)=>{
        let arr = [
            arg
        ];
        let mutated = false;
        seen.clear();
        for(let i = 0; i < arr.length; i++){
            // For each value, call all visitors. If a visitor returns a new value,
            // we start over, but skip the visitor that generated the value or saw
            // it before (to avoid cycles). This way, visitors can be composed in any order. 
            for(let v = 0; v < visitors.length;){
                if (seen.get(v)) {
                    v++;
                    continue;
                }
                let item = arr[i];
                let visitor = visitors[v];
                let res = apply(visitor, item);
                if (Array.isArray(res)) {
                    if (res.length === 0) {
                        arr.splice(i, 1);
                    } else if (res.length === 1) {
                        arr[i] = res[0];
                    } else {
                        arr.splice(i, 1, ...res);
                    }
                    mutated = true;
                    seen.set(v);
                    v = 0;
                } else if (res) {
                    arr[i] = res;
                    mutated = true;
                    seen.set(v);
                    v = 0;
                } else {
                    v++;
                }
            }
        }
        if (!mutated) {
            return;
        }
        return arr.length === 1 ? arr[0] : arr;
    };
}
class Bitset {
    constructor(maxBits = 32){
        this.bits = 0;
        this.more = maxBits > 32 ? new Uint32Array(Math.ceil((maxBits - 32) / 32)) : null;
    }
    /** @param {number} bit */ get(bit) {
        if (bit >= 32 && this.more) {
            let i = Math.floor((bit - 32) / 32);
            let b = bit % 32;
            return Boolean(this.more[i] & 1 << b);
        } else {
            return Boolean(this.bits & 1 << bit);
        }
    }
    /** @param {number} bit */ set(bit) {
        if (bit >= 32 && this.more) {
            let i = Math.floor((bit - 32) / 32);
            let b = bit % 32;
            this.more[i] |= 1 << b;
        } else {
            this.bits |= 1 << bit;
        }
    }
    clear() {
        this.bits = 0;
        if (this.more) {
            this.more.fill(0);
        }
    }
}
}}),
"[project]/node_modules/lightningcss/node/flags.js [postcss] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
// This file is autogenerated by build-prefixes.js. DO NOT EDIT!
exports.Features = {
    Nesting: 1,
    NotSelectorList: 2,
    DirSelector: 4,
    LangSelectorList: 8,
    IsSelector: 16,
    TextDecorationThicknessPercent: 32,
    MediaIntervalSyntax: 64,
    MediaRangeSyntax: 128,
    CustomMediaQueries: 256,
    ClampFunction: 512,
    ColorFunction: 1024,
    OklabColors: 2048,
    LabColors: 4096,
    P3Colors: 8192,
    HexAlphaColors: 16384,
    SpaceSeparatedColorNotation: 32768,
    FontFamilySystemUi: 65536,
    DoublePositionGradients: 131072,
    VendorPrefixes: 262144,
    LogicalProperties: 524288,
    LightDark: 1048576,
    Selectors: 31,
    MediaQueries: 448,
    Colors: 1113088
};
}}),
"[project]/node_modules/lightningcss/node/index.js [postcss] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
let parts = [
    process.platform,
    process.arch
];
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
if (process.env.CSS_TRANSFORMER_WASM) {
    module.exports = (()=>{
        const e = new Error("Cannot find module '../pkg'");
        e.code = 'MODULE_NOT_FOUND';
        throw e;
    })();
} else {
    try {
        module.exports = (()=>{
            const e = new Error("Cannot find module 'unknown'");
            e.code = 'MODULE_NOT_FOUND';
            throw e;
        })();
    } catch (err) {
        module.exports = (()=>{
            const e = new Error("Cannot find module 'unknown'");
            e.code = 'MODULE_NOT_FOUND';
            throw e;
        })();
    }
}
module.exports.browserslistToTargets = __turbopack_context__.r("[project]/node_modules/lightningcss/node/browserslistToTargets.js [postcss] (ecmascript)");
module.exports.composeVisitors = __turbopack_context__.r("[project]/node_modules/lightningcss/node/composeVisitors.js [postcss] (ecmascript)");
module.exports.Features = __turbopack_context__.r("[project]/node_modules/lightningcss/node/flags.js [postcss] (ecmascript)").Features;
}}),
"[project]/node_modules/lightningcss/node/index.mjs [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "Features": ()=>Features,
    "browserslistToTargets": ()=>browserslistToTargets,
    "bundle": ()=>bundle,
    "bundleAsync": ()=>bundleAsync,
    "composeVisitors": ()=>composeVisitors,
    "transform": ()=>transform,
    "transformStyleAttribute": ()=>transformStyleAttribute
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lightningcss$2f$node$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lightningcss/node/index.js [postcss] (ecmascript)");
;
const { transform, transformStyleAttribute, bundle, bundleAsync, browserslistToTargets, composeVisitors, Features } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lightningcss$2f$node$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__["default"];
;
}),
"[project]/node_modules/magic-string/dist/magic-string.es.mjs [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "Bundle": ()=>Bundle,
    "SourceMap": ()=>SourceMap,
    "default": ()=>MagicString
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$sourcemap$2d$codec$2f$dist$2f$sourcemap$2d$codec$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs [postcss] (ecmascript)");
;
class BitSet {
    constructor(arg){
        this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
    }
    add(n) {
        this.bits[n >> 5] |= 1 << (n & 31);
    }
    has(n) {
        return !!(this.bits[n >> 5] & 1 << (n & 31));
    }
}
class Chunk {
    constructor(start, end, content){
        this.start = start;
        this.end = end;
        this.original = content;
        this.intro = '';
        this.outro = '';
        this.content = content;
        this.storeName = false;
        this.edited = false;
        {
            this.previous = null;
            this.next = null;
        }
    }
    appendLeft(content) {
        this.outro += content;
    }
    appendRight(content) {
        this.intro = this.intro + content;
    }
    clone() {
        const chunk = new Chunk(this.start, this.end, this.original);
        chunk.intro = this.intro;
        chunk.outro = this.outro;
        chunk.content = this.content;
        chunk.storeName = this.storeName;
        chunk.edited = this.edited;
        return chunk;
    }
    contains(index) {
        return this.start < index && index < this.end;
    }
    eachNext(fn) {
        let chunk = this;
        while(chunk){
            fn(chunk);
            chunk = chunk.next;
        }
    }
    eachPrevious(fn) {
        let chunk = this;
        while(chunk){
            fn(chunk);
            chunk = chunk.previous;
        }
    }
    edit(content, storeName, contentOnly) {
        this.content = content;
        if (!contentOnly) {
            this.intro = '';
            this.outro = '';
        }
        this.storeName = storeName;
        this.edited = true;
        return this;
    }
    prependLeft(content) {
        this.outro = content + this.outro;
    }
    prependRight(content) {
        this.intro = content + this.intro;
    }
    reset() {
        this.intro = '';
        this.outro = '';
        if (this.edited) {
            this.content = this.original;
            this.storeName = false;
            this.edited = false;
        }
    }
    split(index) {
        const sliceIndex = index - this.start;
        const originalBefore = this.original.slice(0, sliceIndex);
        const originalAfter = this.original.slice(sliceIndex);
        this.original = originalBefore;
        const newChunk = new Chunk(index, this.end, originalAfter);
        newChunk.outro = this.outro;
        this.outro = '';
        this.end = index;
        if (this.edited) {
            // after split we should save the edit content record into the correct chunk
            // to make sure sourcemap correct
            // For example:
            // '  test'.trim()
            //     split   -> '  ' + 'test'
            //   ✔️ edit    -> '' + 'test'
            //   ✖️ edit    -> 'test' + ''
            // TODO is this block necessary?...
            newChunk.edit('', false);
            this.content = '';
        } else {
            this.content = originalBefore;
        }
        newChunk.next = this.next;
        if (newChunk.next) newChunk.next.previous = newChunk;
        newChunk.previous = this;
        this.next = newChunk;
        return newChunk;
    }
    toString() {
        return this.intro + this.content + this.outro;
    }
    trimEnd(rx) {
        this.outro = this.outro.replace(rx, '');
        if (this.outro.length) return true;
        const trimmed = this.content.replace(rx, '');
        if (trimmed.length) {
            if (trimmed !== this.content) {
                this.split(this.start + trimmed.length).edit('', undefined, true);
                if (this.edited) {
                    // save the change, if it has been edited
                    this.edit(trimmed, this.storeName, true);
                }
            }
            return true;
        } else {
            this.edit('', undefined, true);
            this.intro = this.intro.replace(rx, '');
            if (this.intro.length) return true;
        }
    }
    trimStart(rx) {
        this.intro = this.intro.replace(rx, '');
        if (this.intro.length) return true;
        const trimmed = this.content.replace(rx, '');
        if (trimmed.length) {
            if (trimmed !== this.content) {
                const newChunk = this.split(this.end - trimmed.length);
                if (this.edited) {
                    // save the change, if it has been edited
                    newChunk.edit(trimmed, this.storeName, true);
                }
                this.edit('', undefined, true);
            }
            return true;
        } else {
            this.edit('', undefined, true);
            this.outro = this.outro.replace(rx, '');
            if (this.outro.length) return true;
        }
    }
}
function getBtoa() {
    if (typeof globalThis !== 'undefined' && typeof globalThis.btoa === 'function') {
        return (str)=>globalThis.btoa(unescape(encodeURIComponent(str)));
    } else if (typeof Buffer === 'function') {
        return (str)=>Buffer.from(str, 'utf-8').toString('base64');
    } else {
        return ()=>{
            throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');
        };
    }
}
const btoa = /*#__PURE__*/ getBtoa();
class SourceMap {
    constructor(properties){
        this.version = 3;
        this.file = properties.file;
        this.sources = properties.sources;
        this.sourcesContent = properties.sourcesContent;
        this.names = properties.names;
        this.mappings = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$jridgewell$2f$sourcemap$2d$codec$2f$dist$2f$sourcemap$2d$codec$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["encode"])(properties.mappings);
        if (typeof properties.x_google_ignoreList !== 'undefined') {
            this.x_google_ignoreList = properties.x_google_ignoreList;
        }
        if (typeof properties.debugId !== 'undefined') {
            this.debugId = properties.debugId;
        }
    }
    toString() {
        return JSON.stringify(this);
    }
    toUrl() {
        return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());
    }
}
function guessIndent(code) {
    const lines = code.split('\n');
    const tabbed = lines.filter((line)=>/^\t+/.test(line));
    const spaced = lines.filter((line)=>/^ {2,}/.test(line));
    if (tabbed.length === 0 && spaced.length === 0) {
        return null;
    }
    // More lines tabbed than spaced? Assume tabs, and
    // default to tabs in the case of a tie (or nothing
    // to go on)
    if (tabbed.length >= spaced.length) {
        return '\t';
    }
    // Otherwise, we need to guess the multiple
    const min = spaced.reduce((previous, current)=>{
        const numSpaces = /^ +/.exec(current)[0].length;
        return Math.min(numSpaces, previous);
    }, Infinity);
    return new Array(min + 1).join(' ');
}
function getRelativePath(from, to) {
    const fromParts = from.split(/[/\\]/);
    const toParts = to.split(/[/\\]/);
    fromParts.pop(); // get dirname
    while(fromParts[0] === toParts[0]){
        fromParts.shift();
        toParts.shift();
    }
    if (fromParts.length) {
        let i = fromParts.length;
        while(i--)fromParts[i] = '..';
    }
    return fromParts.concat(toParts).join('/');
}
const toString = Object.prototype.toString;
function isObject(thing) {
    return toString.call(thing) === '[object Object]';
}
function getLocator(source) {
    const originalLines = source.split('\n');
    const lineOffsets = [];
    for(let i = 0, pos = 0; i < originalLines.length; i++){
        lineOffsets.push(pos);
        pos += originalLines[i].length + 1;
    }
    return function locate(index) {
        let i = 0;
        let j = lineOffsets.length;
        while(i < j){
            const m = i + j >> 1;
            if (index < lineOffsets[m]) {
                j = m;
            } else {
                i = m + 1;
            }
        }
        const line = i - 1;
        const column = index - lineOffsets[line];
        return {
            line,
            column
        };
    };
}
const wordRegex = /\w/;
class Mappings {
    constructor(hires){
        this.hires = hires;
        this.generatedCodeLine = 0;
        this.generatedCodeColumn = 0;
        this.raw = [];
        this.rawSegments = this.raw[this.generatedCodeLine] = [];
        this.pending = null;
    }
    addEdit(sourceIndex, content, loc, nameIndex) {
        if (content.length) {
            const contentLengthMinusOne = content.length - 1;
            let contentLineEnd = content.indexOf('\n', 0);
            let previousContentLineEnd = -1;
            // Loop through each line in the content and add a segment, but stop if the last line is empty,
            // else code afterwards would fill one line too many
            while(contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd){
                const segment = [
                    this.generatedCodeColumn,
                    sourceIndex,
                    loc.line,
                    loc.column
                ];
                if (nameIndex >= 0) {
                    segment.push(nameIndex);
                }
                this.rawSegments.push(segment);
                this.generatedCodeLine += 1;
                this.raw[this.generatedCodeLine] = this.rawSegments = [];
                this.generatedCodeColumn = 0;
                previousContentLineEnd = contentLineEnd;
                contentLineEnd = content.indexOf('\n', contentLineEnd + 1);
            }
            const segment = [
                this.generatedCodeColumn,
                sourceIndex,
                loc.line,
                loc.column
            ];
            if (nameIndex >= 0) {
                segment.push(nameIndex);
            }
            this.rawSegments.push(segment);
            this.advance(content.slice(previousContentLineEnd + 1));
        } else if (this.pending) {
            this.rawSegments.push(this.pending);
            this.advance(content);
        }
        this.pending = null;
    }
    addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
        let originalCharIndex = chunk.start;
        let first = true;
        // when iterating each char, check if it's in a word boundary
        let charInHiresBoundary = false;
        while(originalCharIndex < chunk.end){
            if (original[originalCharIndex] === '\n') {
                loc.line += 1;
                loc.column = 0;
                this.generatedCodeLine += 1;
                this.raw[this.generatedCodeLine] = this.rawSegments = [];
                this.generatedCodeColumn = 0;
                first = true;
                charInHiresBoundary = false;
            } else {
                if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
                    const segment = [
                        this.generatedCodeColumn,
                        sourceIndex,
                        loc.line,
                        loc.column
                    ];
                    if (this.hires === 'boundary') {
                        // in hires "boundary", group segments per word boundary than per char
                        if (wordRegex.test(original[originalCharIndex])) {
                            // for first char in the boundary found, start the boundary by pushing a segment
                            if (!charInHiresBoundary) {
                                this.rawSegments.push(segment);
                                charInHiresBoundary = true;
                            }
                        } else {
                            // for non-word char, end the boundary by pushing a segment
                            this.rawSegments.push(segment);
                            charInHiresBoundary = false;
                        }
                    } else {
                        this.rawSegments.push(segment);
                    }
                }
                loc.column += 1;
                this.generatedCodeColumn += 1;
                first = false;
            }
            originalCharIndex += 1;
        }
        this.pending = null;
    }
    advance(str) {
        if (!str) return;
        const lines = str.split('\n');
        if (lines.length > 1) {
            for(let i = 0; i < lines.length - 1; i++){
                this.generatedCodeLine++;
                this.raw[this.generatedCodeLine] = this.rawSegments = [];
            }
            this.generatedCodeColumn = 0;
        }
        this.generatedCodeColumn += lines[lines.length - 1].length;
    }
}
const n = '\n';
const warned = {
    insertLeft: false,
    insertRight: false,
    storeName: false
};
class MagicString {
    constructor(string, options = {}){
        const chunk = new Chunk(0, string.length, string);
        Object.defineProperties(this, {
            original: {
                writable: true,
                value: string
            },
            outro: {
                writable: true,
                value: ''
            },
            intro: {
                writable: true,
                value: ''
            },
            firstChunk: {
                writable: true,
                value: chunk
            },
            lastChunk: {
                writable: true,
                value: chunk
            },
            lastSearchedChunk: {
                writable: true,
                value: chunk
            },
            byStart: {
                writable: true,
                value: {}
            },
            byEnd: {
                writable: true,
                value: {}
            },
            filename: {
                writable: true,
                value: options.filename
            },
            indentExclusionRanges: {
                writable: true,
                value: options.indentExclusionRanges
            },
            sourcemapLocations: {
                writable: true,
                value: new BitSet()
            },
            storedNames: {
                writable: true,
                value: {}
            },
            indentStr: {
                writable: true,
                value: undefined
            },
            ignoreList: {
                writable: true,
                value: options.ignoreList
            },
            offset: {
                writable: true,
                value: options.offset || 0
            }
        });
        this.byStart[0] = chunk;
        this.byEnd[string.length] = chunk;
    }
    addSourcemapLocation(char) {
        this.sourcemapLocations.add(char);
    }
    append(content) {
        if (typeof content !== 'string') throw new TypeError('outro content must be a string');
        this.outro += content;
        return this;
    }
    appendLeft(index, content) {
        index = index + this.offset;
        if (typeof content !== 'string') throw new TypeError('inserted content must be a string');
        this._split(index);
        const chunk = this.byEnd[index];
        if (chunk) {
            chunk.appendLeft(content);
        } else {
            this.intro += content;
        }
        return this;
    }
    appendRight(index, content) {
        index = index + this.offset;
        if (typeof content !== 'string') throw new TypeError('inserted content must be a string');
        this._split(index);
        const chunk = this.byStart[index];
        if (chunk) {
            chunk.appendRight(content);
        } else {
            this.outro += content;
        }
        return this;
    }
    clone() {
        const cloned = new MagicString(this.original, {
            filename: this.filename,
            offset: this.offset
        });
        let originalChunk = this.firstChunk;
        let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
        while(originalChunk){
            cloned.byStart[clonedChunk.start] = clonedChunk;
            cloned.byEnd[clonedChunk.end] = clonedChunk;
            const nextOriginalChunk = originalChunk.next;
            const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
            if (nextClonedChunk) {
                clonedChunk.next = nextClonedChunk;
                nextClonedChunk.previous = clonedChunk;
                clonedChunk = nextClonedChunk;
            }
            originalChunk = nextOriginalChunk;
        }
        cloned.lastChunk = clonedChunk;
        if (this.indentExclusionRanges) {
            cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
        }
        cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
        cloned.intro = this.intro;
        cloned.outro = this.outro;
        return cloned;
    }
    generateDecodedMap(options) {
        options = options || {};
        const sourceIndex = 0;
        const names = Object.keys(this.storedNames);
        const mappings = new Mappings(options.hires);
        const locate = getLocator(this.original);
        if (this.intro) {
            mappings.advance(this.intro);
        }
        this.firstChunk.eachNext((chunk)=>{
            const loc = locate(chunk.start);
            if (chunk.intro.length) mappings.advance(chunk.intro);
            if (chunk.edited) {
                mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);
            } else {
                mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
            }
            if (chunk.outro.length) mappings.advance(chunk.outro);
        });
        return {
            file: options.file ? options.file.split(/[/\\]/).pop() : undefined,
            sources: [
                options.source ? getRelativePath(options.file || '', options.source) : options.file || ''
            ],
            sourcesContent: options.includeContent ? [
                this.original
            ] : undefined,
            names,
            mappings: mappings.raw,
            x_google_ignoreList: this.ignoreList ? [
                sourceIndex
            ] : undefined
        };
    }
    generateMap(options) {
        return new SourceMap(this.generateDecodedMap(options));
    }
    _ensureindentStr() {
        if (this.indentStr === undefined) {
            this.indentStr = guessIndent(this.original);
        }
    }
    _getRawIndentString() {
        this._ensureindentStr();
        return this.indentStr;
    }
    getIndentString() {
        this._ensureindentStr();
        return this.indentStr === null ? '\t' : this.indentStr;
    }
    indent(indentStr, options) {
        const pattern = /^[^\r\n]/gm;
        if (isObject(indentStr)) {
            options = indentStr;
            indentStr = undefined;
        }
        if (indentStr === undefined) {
            this._ensureindentStr();
            indentStr = this.indentStr || '\t';
        }
        if (indentStr === '') return this; // noop
        options = options || {};
        // Process exclusion ranges
        const isExcluded = {};
        if (options.exclude) {
            const exclusions = typeof options.exclude[0] === 'number' ? [
                options.exclude
            ] : options.exclude;
            exclusions.forEach((exclusion)=>{
                for(let i = exclusion[0]; i < exclusion[1]; i += 1){
                    isExcluded[i] = true;
                }
            });
        }
        let shouldIndentNextCharacter = options.indentStart !== false;
        const replacer = (match)=>{
            if (shouldIndentNextCharacter) return `${indentStr}${match}`;
            shouldIndentNextCharacter = true;
            return match;
        };
        this.intro = this.intro.replace(pattern, replacer);
        let charIndex = 0;
        let chunk = this.firstChunk;
        while(chunk){
            const end = chunk.end;
            if (chunk.edited) {
                if (!isExcluded[charIndex]) {
                    chunk.content = chunk.content.replace(pattern, replacer);
                    if (chunk.content.length) {
                        shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\n';
                    }
                }
            } else {
                charIndex = chunk.start;
                while(charIndex < end){
                    if (!isExcluded[charIndex]) {
                        const char = this.original[charIndex];
                        if (char === '\n') {
                            shouldIndentNextCharacter = true;
                        } else if (char !== '\r' && shouldIndentNextCharacter) {
                            shouldIndentNextCharacter = false;
                            if (charIndex === chunk.start) {
                                chunk.prependRight(indentStr);
                            } else {
                                this._splitChunk(chunk, charIndex);
                                chunk = chunk.next;
                                chunk.prependRight(indentStr);
                            }
                        }
                    }
                    charIndex += 1;
                }
            }
            charIndex = chunk.end;
            chunk = chunk.next;
        }
        this.outro = this.outro.replace(pattern, replacer);
        return this;
    }
    insert() {
        throw new Error('magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)');
    }
    insertLeft(index, content) {
        if (!warned.insertLeft) {
            console.warn('magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead');
            warned.insertLeft = true;
        }
        return this.appendLeft(index, content);
    }
    insertRight(index, content) {
        if (!warned.insertRight) {
            console.warn('magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead');
            warned.insertRight = true;
        }
        return this.prependRight(index, content);
    }
    move(start, end, index) {
        start = start + this.offset;
        end = end + this.offset;
        index = index + this.offset;
        if (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');
        this._split(start);
        this._split(end);
        this._split(index);
        const first = this.byStart[start];
        const last = this.byEnd[end];
        const oldLeft = first.previous;
        const oldRight = last.next;
        const newRight = this.byStart[index];
        if (!newRight && last === this.lastChunk) return this;
        const newLeft = newRight ? newRight.previous : this.lastChunk;
        if (oldLeft) oldLeft.next = oldRight;
        if (oldRight) oldRight.previous = oldLeft;
        if (newLeft) newLeft.next = first;
        if (newRight) newRight.previous = last;
        if (!first.previous) this.firstChunk = last.next;
        if (!last.next) {
            this.lastChunk = first.previous;
            this.lastChunk.next = null;
        }
        first.previous = newLeft;
        last.next = newRight || null;
        if (!newLeft) this.firstChunk = first;
        if (!newRight) this.lastChunk = last;
        return this;
    }
    overwrite(start, end, content, options) {
        options = options || {};
        return this.update(start, end, content, {
            ...options,
            overwrite: !options.contentOnly
        });
    }
    update(start, end, content, options) {
        start = start + this.offset;
        end = end + this.offset;
        if (typeof content !== 'string') throw new TypeError('replacement content must be a string');
        if (this.original.length !== 0) {
            while(start < 0)start += this.original.length;
            while(end < 0)end += this.original.length;
        }
        if (end > this.original.length) throw new Error('end is out of bounds');
        if (start === end) throw new Error('Cannot overwrite a zero-length range – use appendLeft or prependRight instead');
        this._split(start);
        this._split(end);
        if (options === true) {
            if (!warned.storeName) {
                console.warn('The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string');
                warned.storeName = true;
            }
            options = {
                storeName: true
            };
        }
        const storeName = options !== undefined ? options.storeName : false;
        const overwrite = options !== undefined ? options.overwrite : false;
        if (storeName) {
            const original = this.original.slice(start, end);
            Object.defineProperty(this.storedNames, original, {
                writable: true,
                value: true,
                enumerable: true
            });
        }
        const first = this.byStart[start];
        const last = this.byEnd[end];
        if (first) {
            let chunk = first;
            while(chunk !== last){
                if (chunk.next !== this.byStart[chunk.end]) {
                    throw new Error('Cannot overwrite across a split point');
                }
                chunk = chunk.next;
                chunk.edit('', false);
            }
            first.edit(content, storeName, !overwrite);
        } else {
            // must be inserting at the end
            const newChunk = new Chunk(start, end, '').edit(content, storeName);
            // TODO last chunk in the array may not be the last chunk, if it's moved...
            last.next = newChunk;
            newChunk.previous = last;
        }
        return this;
    }
    prepend(content) {
        if (typeof content !== 'string') throw new TypeError('outro content must be a string');
        this.intro = content + this.intro;
        return this;
    }
    prependLeft(index, content) {
        index = index + this.offset;
        if (typeof content !== 'string') throw new TypeError('inserted content must be a string');
        this._split(index);
        const chunk = this.byEnd[index];
        if (chunk) {
            chunk.prependLeft(content);
        } else {
            this.intro = content + this.intro;
        }
        return this;
    }
    prependRight(index, content) {
        index = index + this.offset;
        if (typeof content !== 'string') throw new TypeError('inserted content must be a string');
        this._split(index);
        const chunk = this.byStart[index];
        if (chunk) {
            chunk.prependRight(content);
        } else {
            this.outro = content + this.outro;
        }
        return this;
    }
    remove(start, end) {
        start = start + this.offset;
        end = end + this.offset;
        if (this.original.length !== 0) {
            while(start < 0)start += this.original.length;
            while(end < 0)end += this.original.length;
        }
        if (start === end) return this;
        if (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');
        if (start > end) throw new Error('end must be greater than start');
        this._split(start);
        this._split(end);
        let chunk = this.byStart[start];
        while(chunk){
            chunk.intro = '';
            chunk.outro = '';
            chunk.edit('');
            chunk = end > chunk.end ? this.byStart[chunk.end] : null;
        }
        return this;
    }
    reset(start, end) {
        start = start + this.offset;
        end = end + this.offset;
        if (this.original.length !== 0) {
            while(start < 0)start += this.original.length;
            while(end < 0)end += this.original.length;
        }
        if (start === end) return this;
        if (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');
        if (start > end) throw new Error('end must be greater than start');
        this._split(start);
        this._split(end);
        let chunk = this.byStart[start];
        while(chunk){
            chunk.reset();
            chunk = end > chunk.end ? this.byStart[chunk.end] : null;
        }
        return this;
    }
    lastChar() {
        if (this.outro.length) return this.outro[this.outro.length - 1];
        let chunk = this.lastChunk;
        do {
            if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];
            if (chunk.content.length) return chunk.content[chunk.content.length - 1];
            if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];
        }while (chunk = chunk.previous)
        if (this.intro.length) return this.intro[this.intro.length - 1];
        return '';
    }
    lastLine() {
        let lineIndex = this.outro.lastIndexOf(n);
        if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);
        let lineStr = this.outro;
        let chunk = this.lastChunk;
        do {
            if (chunk.outro.length > 0) {
                lineIndex = chunk.outro.lastIndexOf(n);
                if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;
                lineStr = chunk.outro + lineStr;
            }
            if (chunk.content.length > 0) {
                lineIndex = chunk.content.lastIndexOf(n);
                if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;
                lineStr = chunk.content + lineStr;
            }
            if (chunk.intro.length > 0) {
                lineIndex = chunk.intro.lastIndexOf(n);
                if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;
                lineStr = chunk.intro + lineStr;
            }
        }while (chunk = chunk.previous)
        lineIndex = this.intro.lastIndexOf(n);
        if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;
        return this.intro + lineStr;
    }
    slice(start = 0, end = this.original.length - this.offset) {
        start = start + this.offset;
        end = end + this.offset;
        if (this.original.length !== 0) {
            while(start < 0)start += this.original.length;
            while(end < 0)end += this.original.length;
        }
        let result = '';
        // find start chunk
        let chunk = this.firstChunk;
        while(chunk && (chunk.start > start || chunk.end <= start)){
            // found end chunk before start
            if (chunk.start < end && chunk.end >= end) {
                return result;
            }
            chunk = chunk.next;
        }
        if (chunk && chunk.edited && chunk.start !== start) throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);
        const startChunk = chunk;
        while(chunk){
            if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
                result += chunk.intro;
            }
            const containsEnd = chunk.start < end && chunk.end >= end;
            if (containsEnd && chunk.edited && chunk.end !== end) throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);
            const sliceStart = startChunk === chunk ? start - chunk.start : 0;
            const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
            result += chunk.content.slice(sliceStart, sliceEnd);
            if (chunk.outro && (!containsEnd || chunk.end === end)) {
                result += chunk.outro;
            }
            if (containsEnd) {
                break;
            }
            chunk = chunk.next;
        }
        return result;
    }
    // TODO deprecate this? not really very useful
    snip(start, end) {
        const clone = this.clone();
        clone.remove(0, start);
        clone.remove(end, clone.original.length);
        return clone;
    }
    _split(index) {
        if (this.byStart[index] || this.byEnd[index]) return;
        let chunk = this.lastSearchedChunk;
        const searchForward = index > chunk.end;
        while(chunk){
            if (chunk.contains(index)) return this._splitChunk(chunk, index);
            chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
        }
    }
    _splitChunk(chunk, index) {
        if (chunk.edited && chunk.content.length) {
            // zero-length edited chunks are a special case (overlapping replacements)
            const loc = getLocator(this.original)(index);
            throw new Error(`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – "${chunk.original}")`);
        }
        const newChunk = chunk.split(index);
        this.byEnd[index] = chunk;
        this.byStart[index] = newChunk;
        this.byEnd[newChunk.end] = newChunk;
        if (chunk === this.lastChunk) this.lastChunk = newChunk;
        this.lastSearchedChunk = chunk;
        return true;
    }
    toString() {
        let str = this.intro;
        let chunk = this.firstChunk;
        while(chunk){
            str += chunk.toString();
            chunk = chunk.next;
        }
        return str + this.outro;
    }
    isEmpty() {
        let chunk = this.firstChunk;
        do {
            if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim()) return false;
        }while (chunk = chunk.next)
        return true;
    }
    length() {
        let chunk = this.firstChunk;
        let length = 0;
        do {
            length += chunk.intro.length + chunk.content.length + chunk.outro.length;
        }while (chunk = chunk.next)
        return length;
    }
    trimLines() {
        return this.trim('[\\r\\n]');
    }
    trim(charType) {
        return this.trimStart(charType).trimEnd(charType);
    }
    trimEndAborted(charType) {
        const rx = new RegExp((charType || '\\s') + '+$');
        this.outro = this.outro.replace(rx, '');
        if (this.outro.length) return true;
        let chunk = this.lastChunk;
        do {
            const end = chunk.end;
            const aborted = chunk.trimEnd(rx);
            // if chunk was trimmed, we have a new lastChunk
            if (chunk.end !== end) {
                if (this.lastChunk === chunk) {
                    this.lastChunk = chunk.next;
                }
                this.byEnd[chunk.end] = chunk;
                this.byStart[chunk.next.start] = chunk.next;
                this.byEnd[chunk.next.end] = chunk.next;
            }
            if (aborted) return true;
            chunk = chunk.previous;
        }while (chunk)
        return false;
    }
    trimEnd(charType) {
        this.trimEndAborted(charType);
        return this;
    }
    trimStartAborted(charType) {
        const rx = new RegExp('^' + (charType || '\\s') + '+');
        this.intro = this.intro.replace(rx, '');
        if (this.intro.length) return true;
        let chunk = this.firstChunk;
        do {
            const end = chunk.end;
            const aborted = chunk.trimStart(rx);
            if (chunk.end !== end) {
                // special case...
                if (chunk === this.lastChunk) this.lastChunk = chunk.next;
                this.byEnd[chunk.end] = chunk;
                this.byStart[chunk.next.start] = chunk.next;
                this.byEnd[chunk.next.end] = chunk.next;
            }
            if (aborted) return true;
            chunk = chunk.next;
        }while (chunk)
        return false;
    }
    trimStart(charType) {
        this.trimStartAborted(charType);
        return this;
    }
    hasChanged() {
        return this.original !== this.toString();
    }
    _replaceRegexp(searchValue, replacement) {
        function getReplacement(match, str) {
            if (typeof replacement === 'string') {
                return replacement.replace(/\$(\$|&|\d+)/g, (_, i)=>{
                    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter
                    if (i === '$') return '$';
                    if (i === '&') return match[0];
                    const num = +i;
                    if (num < match.length) return match[+i];
                    return `$${i}`;
                });
            } else {
                return replacement(...match, match.index, str, match.groups);
            }
        }
        function matchAll(re, str) {
            let match;
            const matches = [];
            while(match = re.exec(str)){
                matches.push(match);
            }
            return matches;
        }
        if (searchValue.global) {
            const matches = matchAll(searchValue, this.original);
            matches.forEach((match)=>{
                if (match.index != null) {
                    const replacement = getReplacement(match, this.original);
                    if (replacement !== match[0]) {
                        this.overwrite(match.index, match.index + match[0].length, replacement);
                    }
                }
            });
        } else {
            const match = this.original.match(searchValue);
            if (match && match.index != null) {
                const replacement = getReplacement(match, this.original);
                if (replacement !== match[0]) {
                    this.overwrite(match.index, match.index + match[0].length, replacement);
                }
            }
        }
        return this;
    }
    _replaceString(string, replacement) {
        const { original } = this;
        const index = original.indexOf(string);
        if (index !== -1) {
            this.overwrite(index, index + string.length, replacement);
        }
        return this;
    }
    replace(searchValue, replacement) {
        if (typeof searchValue === 'string') {
            return this._replaceString(searchValue, replacement);
        }
        return this._replaceRegexp(searchValue, replacement);
    }
    _replaceAllString(string, replacement) {
        const { original } = this;
        const stringLength = string.length;
        for(let index = original.indexOf(string); index !== -1; index = original.indexOf(string, index + stringLength)){
            const previous = original.slice(index, index + stringLength);
            if (previous !== replacement) this.overwrite(index, index + stringLength, replacement);
        }
        return this;
    }
    replaceAll(searchValue, replacement) {
        if (typeof searchValue === 'string') {
            return this._replaceAllString(searchValue, replacement);
        }
        if (!searchValue.global) {
            throw new TypeError('MagicString.prototype.replaceAll called with a non-global RegExp argument');
        }
        return this._replaceRegexp(searchValue, replacement);
    }
}
const hasOwnProp = Object.prototype.hasOwnProperty;
class Bundle {
    constructor(options = {}){
        this.intro = options.intro || '';
        this.separator = options.separator !== undefined ? options.separator : '\n';
        this.sources = [];
        this.uniqueSources = [];
        this.uniqueSourceIndexByFilename = {};
    }
    addSource(source) {
        if (source instanceof MagicString) {
            return this.addSource({
                content: source,
                filename: source.filename,
                separator: this.separator
            });
        }
        if (!isObject(source) || !source.content) {
            throw new Error('bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`');
        }
        [
            'filename',
            'ignoreList',
            'indentExclusionRanges',
            'separator'
        ].forEach((option)=>{
            if (!hasOwnProp.call(source, option)) source[option] = source.content[option];
        });
        if (source.separator === undefined) {
            // TODO there's a bunch of this sort of thing, needs cleaning up
            source.separator = this.separator;
        }
        if (source.filename) {
            if (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {
                this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;
                this.uniqueSources.push({
                    filename: source.filename,
                    content: source.content.original
                });
            } else {
                const uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];
                if (source.content.original !== uniqueSource.content) {
                    throw new Error(`Illegal source: same filename (${source.filename}), different contents`);
                }
            }
        }
        this.sources.push(source);
        return this;
    }
    append(str, options) {
        this.addSource({
            content: new MagicString(str),
            separator: options && options.separator || ''
        });
        return this;
    }
    clone() {
        const bundle = new Bundle({
            intro: this.intro,
            separator: this.separator
        });
        this.sources.forEach((source)=>{
            bundle.addSource({
                filename: source.filename,
                content: source.content.clone(),
                separator: source.separator
            });
        });
        return bundle;
    }
    generateDecodedMap(options = {}) {
        const names = [];
        let x_google_ignoreList = undefined;
        this.sources.forEach((source)=>{
            Object.keys(source.content.storedNames).forEach((name)=>{
                if (!~names.indexOf(name)) names.push(name);
            });
        });
        const mappings = new Mappings(options.hires);
        if (this.intro) {
            mappings.advance(this.intro);
        }
        this.sources.forEach((source, i)=>{
            if (i > 0) {
                mappings.advance(this.separator);
            }
            const sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;
            const magicString = source.content;
            const locate = getLocator(magicString.original);
            if (magicString.intro) {
                mappings.advance(magicString.intro);
            }
            magicString.firstChunk.eachNext((chunk)=>{
                const loc = locate(chunk.start);
                if (chunk.intro.length) mappings.advance(chunk.intro);
                if (source.filename) {
                    if (chunk.edited) {
                        mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);
                    } else {
                        mappings.addUneditedChunk(sourceIndex, chunk, magicString.original, loc, magicString.sourcemapLocations);
                    }
                } else {
                    mappings.advance(chunk.content);
                }
                if (chunk.outro.length) mappings.advance(chunk.outro);
            });
            if (magicString.outro) {
                mappings.advance(magicString.outro);
            }
            if (source.ignoreList && sourceIndex !== -1) {
                if (x_google_ignoreList === undefined) {
                    x_google_ignoreList = [];
                }
                x_google_ignoreList.push(sourceIndex);
            }
        });
        return {
            file: options.file ? options.file.split(/[/\\]/).pop() : undefined,
            sources: this.uniqueSources.map((source)=>{
                return options.file ? getRelativePath(options.file, source.filename) : source.filename;
            }),
            sourcesContent: this.uniqueSources.map((source)=>{
                return options.includeContent ? source.content : null;
            }),
            names,
            mappings: mappings.raw,
            x_google_ignoreList
        };
    }
    generateMap(options) {
        return new SourceMap(this.generateDecodedMap(options));
    }
    getIndentString() {
        const indentStringCounts = {};
        this.sources.forEach((source)=>{
            const indentStr = source.content._getRawIndentString();
            if (indentStr === null) return;
            if (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;
            indentStringCounts[indentStr] += 1;
        });
        return Object.keys(indentStringCounts).sort((a, b)=>{
            return indentStringCounts[a] - indentStringCounts[b];
        })[0] || '\t';
    }
    indent(indentStr) {
        if (!arguments.length) {
            indentStr = this.getIndentString();
        }
        if (indentStr === '') return this; // noop
        let trailingNewline = !this.intro || this.intro.slice(-1) === '\n';
        this.sources.forEach((source, i)=>{
            const separator = source.separator !== undefined ? source.separator : this.separator;
            const indentStart = trailingNewline || i > 0 && /\r?\n$/.test(separator);
            source.content.indent(indentStr, {
                exclude: source.indentExclusionRanges,
                indentStart
            });
            trailingNewline = source.content.lastChar() === '\n';
        });
        if (this.intro) {
            this.intro = indentStr + this.intro.replace(/^[^\n]/gm, (match, index)=>{
                return index > 0 ? indentStr + match : match;
            });
        }
        return this;
    }
    prepend(str) {
        this.intro = str + this.intro;
        return this;
    }
    toString() {
        const body = this.sources.map((source, i)=>{
            const separator = source.separator !== undefined ? source.separator : this.separator;
            const str = (i > 0 ? separator : '') + source.content.toString();
            return str;
        }).join('');
        return this.intro + body;
    }
    isEmpty() {
        if (this.intro.length && this.intro.trim()) return false;
        if (this.sources.some((source)=>!source.content.isEmpty())) return false;
        return true;
    }
    length() {
        return this.sources.reduce((length, source)=>length + source.content.length(), this.intro.length);
    }
    trimLines() {
        return this.trim('[\\r\\n]');
    }
    trim(charType) {
        return this.trimStart(charType).trimEnd(charType);
    }
    trimStart(charType) {
        const rx = new RegExp('^' + (charType || '\\s') + '+');
        this.intro = this.intro.replace(rx, '');
        if (!this.intro) {
            let source;
            let i = 0;
            do {
                source = this.sources[i++];
                if (!source) {
                    break;
                }
            }while (!source.content.trimStartAborted(charType))
        }
        return this;
    }
    trimEnd(charType) {
        const rx = new RegExp((charType || '\\s') + '+$');
        let source;
        let i = this.sources.length - 1;
        do {
            source = this.sources[i--];
            if (!source) {
                this.intro = this.intro.replace(rx, '');
                break;
            }
        }while (!source.content.trimEndAborted(charType))
        return this;
    }
}
;
 //# sourceMappingURL=magic-string.es.mjs.map
}),
"[project]/node_modules/@tailwindcss/node/dist/index.mjs [postcss] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "Instrumentation": ()=>pt,
    "__unstable__loadDesignSystem": ()=>Sa,
    "compile": ()=>$a,
    "compileAst": ()=>Ca,
    "env": ()=>ae,
    "loadModule": ()=>ct,
    "normalizePath": ()=>be,
    "optimize": ()=>Oa,
    "toSourceMap": ()=>Ka
});
var __TURBOPACK__imported__module__$5b$externals$5d2f$module__$5b$external$5d$__$28$module$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/module [external] (module, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/url [external] (url, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$enhanced$2d$resolve$2f$lib$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/enhanced-resolve/lib/index.js [postcss] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jiti$2f$lib$2f$jiti$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/jiti/lib/jiti.mjs [postcss] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs [external] (fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs/promises [external] (fs/promises, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/path [external] (path, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$lib$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/tailwindcss/dist/lib.mjs [postcss] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$4WXWQT6Y$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__e__as__$5f$_unstable_$5f$loadDesignSystem$3e$__ = __turbopack_context__.i("[project]/node_modules/tailwindcss/dist/chunk-4WXWQT6Y.mjs [postcss] (ecmascript) <export e as __unstable__loadDesignSystem>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$4WXWQT6Y$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__d__as__compile$3e$__ = __turbopack_context__.i("[project]/node_modules/tailwindcss/dist/chunk-4WXWQT6Y.mjs [postcss] (ecmascript) <export d as compile>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$4WXWQT6Y$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__c__as__compileAst$3e$__ = __turbopack_context__.i("[project]/node_modules/tailwindcss/dist/chunk-4WXWQT6Y.mjs [postcss] (ecmascript) <export c as compileAst>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ampproject$2f$remapping$2f$dist$2f$remapping$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ampproject/remapping/dist/remapping.mjs [postcss] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lightningcss$2f$node$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lightningcss/node/index.mjs [postcss] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$magic$2d$string$2f$dist$2f$magic$2d$string$2e$es$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/magic-string/dist/magic-string.es.mjs [postcss] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$source$2d$map$2d$js$2f$source$2d$map$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/source-map-js/source-map.js [postcss] (ecmascript)");
const __TURBOPACK__import$2e$meta__ = {
    get url () {
        return `file://${__turbopack_context__.P("node_modules/@tailwindcss/node/dist/index.mjs")}`;
    }
};
var mt = Object.defineProperty;
var gt = (e, r)=>{
    for(var t in r)mt(e, t, {
        get: r[t],
        enumerable: !0
    });
};
;
;
var ae = {};
gt(ae, {
    DEBUG: ()=>le
});
var le = ht(process.env.DEBUG);
function ht(e) {
    if (e === void 0) return !1;
    if (e === "true" || e === "1") return !0;
    if (e === "false" || e === "0") return !1;
    if (e === "*") return !0;
    let r = e.split(",").map((t)=>t.split(":")[0]);
    return r.includes("-tailwindcss") ? !1 : !!r.includes("tailwindcss");
}
;
;
;
;
;
;
;
;
;
var vt = [
    /import[\s\S]*?['"](.{3,}?)['"]/gi,
    /import[\s\S]*from[\s\S]*?['"](.{3,}?)['"]/gi,
    /export[\s\S]*from[\s\S]*?['"](.{3,}?)['"]/gi,
    /require\(['"`](.+)['"`]\)/gi
], wt = [
    ".js",
    ".cjs",
    ".mjs"
], kt = [
    "",
    ".js",
    ".cjs",
    ".mjs",
    ".ts",
    ".cts",
    ".mts",
    ".jsx",
    ".tsx"
], yt = [
    "",
    ".ts",
    ".cts",
    ".mts",
    ".tsx",
    ".js",
    ".cjs",
    ".mjs",
    ".jsx"
];
async function bt(e, r) {
    for (let t of r){
        let i = `${e}${t}`;
        if ((await __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__["default"].stat(i).catch(()=>null))?.isFile()) return i;
    }
    for (let t of r){
        let i = `${e}/index${t}`;
        if (await __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__["default"].access(i).then(()=>!0, ()=>!1)) return i;
    }
    return null;
}
async function Ne(e, r, t, i) {
    let n = wt.includes(i) ? kt : yt, l = await bt(__TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].resolve(t, r), n);
    if (l === null || e.has(l)) return;
    e.add(l), t = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].dirname(l), i = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].extname(l);
    let o = await __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__["default"].readFile(l, "utf-8"), s = [];
    for (let a of vt)for (let u of o.matchAll(a))u[1].startsWith(".") && s.push(Ne(e, u[1], t, i));
    await Promise.all(s);
}
async function Ee(e) {
    let r = new Set;
    return await Ne(r, e, __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].dirname(e), __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].extname(e)), Array.from(r);
}
;
function ue(e) {
    return {
        kind: "word",
        value: e
    };
}
function xt(e, r) {
    return {
        kind: "function",
        value: e,
        nodes: r
    };
}
function At(e) {
    return {
        kind: "separator",
        value: e
    };
}
function E(e, r, t = null) {
    for(let i = 0; i < e.length; i++){
        let n = e[i], l = !1, o = 0, s = r(n, {
            parent: t,
            replaceWith (a) {
                l || (l = !0, Array.isArray(a) ? a.length === 0 ? (e.splice(i, 1), o = 0) : a.length === 1 ? (e[i] = a[0], o = 1) : (e.splice(i, 1, ...a), o = a.length) : e[i] = a);
            }
        }) ?? 0;
        if (l) {
            s === 0 ? i-- : i += o - 1;
            continue;
        }
        if (s === 2) return 2;
        if (s !== 1 && n.kind === "function" && E(n.nodes, r, n) === 2) return 2;
    }
}
function N(e) {
    let r = "";
    for (let t of e)switch(t.kind){
        case "word":
        case "separator":
            {
                r += t.value;
                break;
            }
        case "function":
            r += t.value + "(" + N(t.nodes) + ")";
    }
    return r;
}
var Ve = 92, Ct = 41, Te = 58, Re = 44, $t = 34, Pe = 61, Oe = 62, _e = 60, De = 10, St = 40, Nt = 39, Ue = 47, Ke = 32, Le = 9;
function x(e) {
    e = e.replaceAll(`\r
`, `
`);
    let r = [], t = [], i = null, n = "", l;
    for(let o = 0; o < e.length; o++){
        let s = e.charCodeAt(o);
        switch(s){
            case Ve:
                {
                    n += e[o] + e[o + 1], o++;
                    break;
                }
            case Te:
            case Re:
            case Pe:
            case Oe:
            case _e:
            case De:
            case Ue:
            case Ke:
            case Le:
                {
                    if (n.length > 0) {
                        let c = ue(n);
                        i ? i.nodes.push(c) : r.push(c), n = "";
                    }
                    let a = o, u = o + 1;
                    for(; u < e.length && (l = e.charCodeAt(u), !(l !== Te && l !== Re && l !== Pe && l !== Oe && l !== _e && l !== De && l !== Ue && l !== Ke && l !== Le)); u++);
                    o = u - 1;
                    let p = At(e.slice(a, u));
                    i ? i.nodes.push(p) : r.push(p);
                    break;
                }
            case Nt:
            case $t:
                {
                    let a = o;
                    for(let u = o + 1; u < e.length; u++)if (l = e.charCodeAt(u), l === Ve) u += 1;
                    else if (l === s) {
                        o = u;
                        break;
                    }
                    n += e.slice(a, o + 1);
                    break;
                }
            case St:
                {
                    let a = xt(n, []);
                    n = "", i ? i.nodes.push(a) : r.push(a), t.push(a), i = a;
                    break;
                }
            case Ct:
                {
                    let a = t.pop();
                    if (n.length > 0) {
                        let u = ue(n);
                        a?.nodes.push(u), n = "";
                    }
                    t.length > 0 ? i = t[t.length - 1] : i = null;
                    break;
                }
            default:
                n += String.fromCharCode(s);
        }
    }
    return n.length > 0 && r.push(ue(n)), r;
}
var g = class extends Map {
    constructor(t){
        super();
        this.factory = t;
    }
    get(t) {
        let i = super.get(t);
        return i === void 0 && (i = this.factory(t, this), this.set(t, i)), i;
    }
};
var Mr = new Uint8Array(256);
var Y = new Uint8Array(256);
function k(e, r) {
    let t = 0, i = [], n = 0, l = e.length, o = r.charCodeAt(0);
    for(let s = 0; s < l; s++){
        let a = e.charCodeAt(s);
        if (t === 0 && a === o) {
            i.push(e.slice(n, s)), n = s + 1;
            continue;
        }
        switch(a){
            case 92:
                s += 1;
                break;
            case 39:
            case 34:
                for(; ++s < l;){
                    let u = e.charCodeAt(s);
                    if (u === 92) {
                        s += 1;
                        continue;
                    }
                    if (u === a) break;
                }
                break;
            case 40:
                Y[t] = 41, t++;
                break;
            case 91:
                Y[t] = 93, t++;
                break;
            case 123:
                Y[t] = 125, t++;
                break;
            case 93:
            case 125:
            case 41:
                t > 0 && a === Y[t - 1] && t--;
                break;
        }
    }
    return i.push(e.slice(n)), i;
}
var Qr = new g((e)=>{
    let r = x(e), t = new Set;
    return E(r, (i, { parent: n })=>{
        let l = n === null ? r : n.nodes ?? [];
        if (i.kind === "word" && (i.value === "+" || i.value === "-" || i.value === "*" || i.value === "/")) {
            let o = l.indexOf(i) ?? -1;
            if (o === -1) return;
            let s = l[o - 1];
            if (s?.kind !== "separator" || s.value !== " ") return;
            let a = l[o + 1];
            if (a?.kind !== "separator" || a.value !== " ") return;
            t.add(s), t.add(a);
        } else i.kind === "separator" && i.value.trim() === "/" ? i.value = "/" : i.kind === "separator" && i.value.length > 0 && i.value.trim() === "" ? (l[0] === i || l[l.length - 1] === i) && t.add(i) : i.kind === "separator" && i.value.trim() === "," && (i.value = ",");
    }), t.size > 0 && E(r, (i, { replaceWith: n })=>{
        t.has(i) && (t.delete(i), n([]));
    }), ce(r), N(r);
});
var Xr = new g((e)=>{
    let r = x(e);
    return r.length === 3 && r[0].kind === "word" && r[0].value === "&" && r[1].kind === "separator" && r[1].value === ":" && r[2].kind === "function" && r[2].value === "is" ? N(r[2].nodes) : e;
});
function ce(e) {
    for (let r of e)switch(r.kind){
        case "function":
            {
                if (r.value === "url" || r.value.endsWith("_url")) {
                    r.value = z(r.value);
                    break;
                }
                if (r.value === "var" || r.value.endsWith("_var") || r.value === "theme" || r.value.endsWith("_theme")) {
                    r.value = z(r.value);
                    for(let t = 0; t < r.nodes.length; t++)ce([
                        r.nodes[t]
                    ]);
                    break;
                }
                r.value = z(r.value), ce(r.nodes);
                break;
            }
        case "separator":
            r.value = z(r.value);
            break;
        case "word":
            {
                (r.value[0] !== "-" || r.value[1] !== "-") && (r.value = z(r.value));
                break;
            }
        default:
            Et(r);
    }
}
var ei = new g((e)=>{
    let r = x(e);
    return r.length === 1 && r[0].kind === "function" && r[0].value === "var";
});
function Et(e) {
    throw new Error(`Unexpected value: ${e}`);
}
function z(e) {
    return e.replaceAll("_", String.raw`\_`).replaceAll(" ", "_");
}
var V = /[+-]?\d*\.?\d+(?:[eE][+-]?\d+)?/, ui = new RegExp(`^${V.source}$`);
var ci = new RegExp(`^${V.source}%$`);
var fi = new RegExp(`^${V.source}s*/s*${V.source}$`);
var Vt = [
    "cm",
    "mm",
    "Q",
    "in",
    "pc",
    "pt",
    "px",
    "em",
    "ex",
    "ch",
    "rem",
    "lh",
    "rlh",
    "vw",
    "vh",
    "vmin",
    "vmax",
    "vb",
    "vi",
    "svw",
    "svh",
    "lvw",
    "lvh",
    "dvw",
    "dvh",
    "cqw",
    "cqh",
    "cqi",
    "cqb",
    "cqmin",
    "cqmax"
], pi = new RegExp(`^${V.source}(${Vt.join("|")})$`);
var Tt = [
    "deg",
    "rad",
    "grad",
    "turn"
], di = new RegExp(`^${V.source}(${Tt.join("|")})$`);
var mi = new RegExp(`^${V.source} +${V.source} +${V.source}$`);
function b(e) {
    let r = Number(e);
    return Number.isInteger(r) && r >= 0 && String(r) === String(e);
}
function j(e, r) {
    if (r === null) return e;
    let t = Number(r);
    return Number.isNaN(t) || (r = `${t * 100}%`), r === "100%" ? e : `color-mix(in oklab, ${e} ${r}, transparent)`;
}
var Ot = {
    "--alpha": _t,
    "--spacing": Dt,
    "--theme": Ut,
    theme: Kt
};
function _t(e, r, t, ...i) {
    let [n, l] = k(t, "/").map((o)=>o.trim());
    if (!n || !l) throw new Error(`The --alpha(\u2026) function requires a color and an alpha value, e.g.: \`--alpha(${n || "var(--my-color)"} / ${l || "50%"})\``);
    if (i.length > 0) throw new Error(`The --alpha(\u2026) function only accepts one argument, e.g.: \`--alpha(${n || "var(--my-color)"} / ${l || "50%"})\``);
    return j(n, l);
}
function Dt(e, r, t, ...i) {
    if (!t) throw new Error("The --spacing(\u2026) function requires an argument, but received none.");
    if (i.length > 0) throw new Error(`The --spacing(\u2026) function only accepts a single argument, but received ${i.length + 1}.`);
    let n = e.theme.resolve(null, [
        "--spacing"
    ]);
    if (!n) throw new Error("The --spacing(\u2026) function requires that the `--spacing` theme variable exists, but it was not found.");
    return `calc(${n} * ${t})`;
}
function Ut(e, r, t, ...i) {
    if (!t.startsWith("--")) throw new Error("The --theme(\u2026) function can only be used with CSS variables from your theme.");
    let n = !1;
    t.endsWith(" inline") && (n = !0, t = t.slice(0, -7)), r.kind === "at-rule" && (n = !0);
    let l = e.resolveThemeValue(t, n);
    if (!l) {
        if (i.length > 0) return i.join(", ");
        throw new Error(`Could not resolve value for theme function: \`theme(${t})\`. Consider checking if the variable name is correct or provide a fallback value to silence this error.`);
    }
    if (i.length === 0) return l;
    let o = i.join(", ");
    if (o === "initial") return l;
    if (l === "initial") return o;
    if (l.startsWith("var(") || l.startsWith("theme(") || l.startsWith("--theme(")) {
        let s = x(l);
        return It(s, o), N(s);
    }
    return l;
}
function Kt(e, r, t, ...i) {
    t = Lt(t);
    let n = e.resolveThemeValue(t);
    if (!n && i.length > 0) return i.join(", ");
    if (!n) throw new Error(`Could not resolve value for theme function: \`theme(${t})\`. Consider checking if the path is correct or provide a fallback value to silence this error.`);
    return n;
}
var Oi = new RegExp(Object.keys(Ot).map((e)=>`${e}\\(`).join("|"));
function Lt(e) {
    if (e[0] !== "'" && e[0] !== '"') return e;
    let r = "", t = e[0];
    for(let i = 1; i < e.length - 1; i++){
        let n = e[i], l = e[i + 1];
        n === "\\" && (l === t || l === "\\") ? (r += l, i++) : r += n;
    }
    return r;
}
function It(e, r) {
    E(e, (t)=>{
        if (t.kind === "function" && !(t.value !== "var" && t.value !== "theme" && t.value !== "--theme")) if (t.nodes.length === 1) t.nodes.push({
            kind: "word",
            value: `, ${r}`
        });
        else {
            let i = t.nodes[t.nodes.length - 1];
            i.kind === "word" && i.value === "initial" && (i.value = r);
        }
    });
}
var W = 92, Q = 47, X = 42, Me = 34, We = 39, Bt = 58, te = 59, C = 10, re = 13, B = 32, ee = 9, Be = 123, me = 125, ve = 40, He = 41, Ht = 91, qt = 93, qe = 45, ge = 64, Gt = 33;
function q(e, r) {
    let t = r?.from ? {
        file: r.from,
        code: e
    } : null;
    e[0] === "\uFEFF" && (e = " " + e.slice(1));
    let i = [], n = [], l = [], o = null, s = null, a = "", u = "", p = 0, c;
    for(let f = 0; f < e.length; f++){
        let m = e.charCodeAt(f);
        if (!(m === re && (c = e.charCodeAt(f + 1), c === C))) if (m === W) a === "" && (p = f), a += e.slice(f, f + 2), f += 1;
        else if (m === Q && e.charCodeAt(f + 1) === X) {
            let d = f;
            for(let h = f + 2; h < e.length; h++)if (c = e.charCodeAt(h), c === W) h += 1;
            else if (c === X && e.charCodeAt(h + 1) === Q) {
                f = h + 1;
                break;
            }
            let S = e.slice(d, f + 1);
            if (S.charCodeAt(2) === Gt) {
                let h = ke(S.slice(2, -2));
                n.push(h), t && (h.src = [
                    t,
                    d,
                    f + 1
                ], h.dst = [
                    t,
                    d,
                    f + 1
                ]);
            }
        } else if (m === We || m === Me) {
            let d = Ge(e, f, m);
            a += e.slice(f, d + 1), f = d;
        } else {
            if ((m === B || m === C || m === ee) && (c = e.charCodeAt(f + 1)) && (c === B || c === C || c === ee || c === re && (c = e.charCodeAt(f + 2)) && c == C)) continue;
            if (m === C) {
                if (a.length === 0) continue;
                c = a.charCodeAt(a.length - 1), c !== B && c !== C && c !== ee && (a += " ");
            } else if (m === qe && e.charCodeAt(f + 1) === qe && a.length === 0) {
                let d = "", S = f, h = -1;
                for(let v = f + 2; v < e.length; v++)if (c = e.charCodeAt(v), c === W) v += 1;
                else if (c === We || c === Me) v = Ge(e, v, c);
                else if (c === Q && e.charCodeAt(v + 1) === X) {
                    for(let D = v + 2; D < e.length; D++)if (c = e.charCodeAt(D), c === W) D += 1;
                    else if (c === X && e.charCodeAt(D + 1) === Q) {
                        v = D + 1;
                        break;
                    }
                } else if (h === -1 && c === Bt) h = a.length + v - S;
                else if (c === te && d.length === 0) {
                    a += e.slice(S, v), f = v;
                    break;
                } else if (c === ve) d += ")";
                else if (c === Ht) d += "]";
                else if (c === Be) d += "}";
                else if ((c === me || e.length - 1 === v) && d.length === 0) {
                    f = v - 1, a += e.slice(S, v);
                    break;
                } else (c === He || c === qt || c === me) && d.length > 0 && e[v] === d[d.length - 1] && (d = d.slice(0, -1));
                let I = he(a, h);
                if (!I) throw new Error("Invalid custom property, expected a value");
                t && (I.src = [
                    t,
                    S,
                    f
                ], I.dst = [
                    t,
                    S,
                    f
                ]), o ? o.nodes.push(I) : i.push(I), a = "";
            } else if (m === te && a.charCodeAt(0) === ge) s = H(a), t && (s.src = [
                t,
                p,
                f
            ], s.dst = [
                t,
                p,
                f
            ]), o ? o.nodes.push(s) : i.push(s), a = "", s = null;
            else if (m === te && u[u.length - 1] !== ")") {
                let d = he(a);
                if (!d) throw a.length === 0 ? new Error("Unexpected semicolon") : new Error(`Invalid declaration: \`${a.trim()}\``);
                t && (d.src = [
                    t,
                    p,
                    f
                ], d.dst = [
                    t,
                    p,
                    f
                ]), o ? o.nodes.push(d) : i.push(d), a = "";
            } else if (m === Be && u[u.length - 1] !== ")") u += "}", s = R(a.trim()), t && (s.src = [
                t,
                p,
                f
            ], s.dst = [
                t,
                p,
                f
            ]), o && o.nodes.push(s), l.push(o), o = s, a = "", s = null;
            else if (m === me && u[u.length - 1] !== ")") {
                if (u === "") throw new Error("Missing opening {");
                if (u = u.slice(0, -1), a.length > 0) if (a.charCodeAt(0) === ge) s = H(a), t && (s.src = [
                    t,
                    p,
                    f
                ], s.dst = [
                    t,
                    p,
                    f
                ]), o ? o.nodes.push(s) : i.push(s), a = "", s = null;
                else {
                    let S = a.indexOf(":");
                    if (o) {
                        let h = he(a, S);
                        if (!h) throw new Error(`Invalid declaration: \`${a.trim()}\``);
                        t && (h.src = [
                            t,
                            p,
                            f
                        ], h.dst = [
                            t,
                            p,
                            f
                        ]), o.nodes.push(h);
                    }
                }
                let d = l.pop() ?? null;
                d === null && o && i.push(o), o = d, a = "", s = null;
            } else if (m === ve) u += ")", a += "(";
            else if (m === He) {
                if (u[u.length - 1] !== ")") throw new Error("Missing opening (");
                u = u.slice(0, -1), a += ")";
            } else {
                if (a.length === 0 && (m === B || m === C || m === ee)) continue;
                a === "" && (p = f), a += String.fromCharCode(m);
            }
        }
    }
    if (a.charCodeAt(0) === ge) {
        let f = H(a);
        t && (f.src = [
            t,
            p,
            e.length
        ], f.dst = [
            t,
            p,
            e.length
        ]), i.push(f);
    }
    if (u.length > 0 && o) {
        if (o.kind === "rule") throw new Error(`Missing closing } at ${o.selector}`);
        if (o.kind === "at-rule") throw new Error(`Missing closing } at ${o.name} ${o.params}`);
    }
    return n.length > 0 ? n.concat(i) : i;
}
function H(e, r = []) {
    let t = e, i = "";
    for(let n = 5; n < e.length; n++){
        let l = e.charCodeAt(n);
        if (l === B || l === ve) {
            t = e.slice(0, n), i = e.slice(n);
            break;
        }
    }
    return A(t.trim(), i.trim(), r);
}
function he(e, r = e.indexOf(":")) {
    if (r === -1) return null;
    let t = e.indexOf("!important", r + 1);
    return T(e.slice(0, r).trim(), e.slice(r + 1, t === -1 ? e.length : t).trim(), t !== -1);
}
function Ge(e, r, t) {
    let i;
    for(let n = r + 1; n < e.length; n++)if (i = e.charCodeAt(n), i === W) n += 1;
    else {
        if (i === t) return n;
        if (i === te && (e.charCodeAt(n + 1) === C || e.charCodeAt(n + 1) === re && e.charCodeAt(n + 2) === C)) throw new Error(`Unterminated string: ${e.slice(r, n + 1) + String.fromCharCode(t)}`);
        if (i === C || i === re && e.charCodeAt(n + 1) === C) throw new Error(`Unterminated string: ${e.slice(r, n) + String.fromCharCode(t)}`);
    }
    return r;
}
var ye = {
    inherit: "inherit",
    current: "currentcolor",
    transparent: "transparent",
    black: "#000",
    white: "#fff",
    slate: {
        50: "oklch(98.4% 0.003 247.858)",
        100: "oklch(96.8% 0.007 247.896)",
        200: "oklch(92.9% 0.013 255.508)",
        300: "oklch(86.9% 0.022 252.894)",
        400: "oklch(70.4% 0.04 256.788)",
        500: "oklch(55.4% 0.046 257.417)",
        600: "oklch(44.6% 0.043 257.281)",
        700: "oklch(37.2% 0.044 257.287)",
        800: "oklch(27.9% 0.041 260.031)",
        900: "oklch(20.8% 0.042 265.755)",
        950: "oklch(12.9% 0.042 264.695)"
    },
    gray: {
        50: "oklch(98.5% 0.002 247.839)",
        100: "oklch(96.7% 0.003 264.542)",
        200: "oklch(92.8% 0.006 264.531)",
        300: "oklch(87.2% 0.01 258.338)",
        400: "oklch(70.7% 0.022 261.325)",
        500: "oklch(55.1% 0.027 264.364)",
        600: "oklch(44.6% 0.03 256.802)",
        700: "oklch(37.3% 0.034 259.733)",
        800: "oklch(27.8% 0.033 256.848)",
        900: "oklch(21% 0.034 264.665)",
        950: "oklch(13% 0.028 261.692)"
    },
    zinc: {
        50: "oklch(98.5% 0 0)",
        100: "oklch(96.7% 0.001 286.375)",
        200: "oklch(92% 0.004 286.32)",
        300: "oklch(87.1% 0.006 286.286)",
        400: "oklch(70.5% 0.015 286.067)",
        500: "oklch(55.2% 0.016 285.938)",
        600: "oklch(44.2% 0.017 285.786)",
        700: "oklch(37% 0.013 285.805)",
        800: "oklch(27.4% 0.006 286.033)",
        900: "oklch(21% 0.006 285.885)",
        950: "oklch(14.1% 0.005 285.823)"
    },
    neutral: {
        50: "oklch(98.5% 0 0)",
        100: "oklch(97% 0 0)",
        200: "oklch(92.2% 0 0)",
        300: "oklch(87% 0 0)",
        400: "oklch(70.8% 0 0)",
        500: "oklch(55.6% 0 0)",
        600: "oklch(43.9% 0 0)",
        700: "oklch(37.1% 0 0)",
        800: "oklch(26.9% 0 0)",
        900: "oklch(20.5% 0 0)",
        950: "oklch(14.5% 0 0)"
    },
    stone: {
        50: "oklch(98.5% 0.001 106.423)",
        100: "oklch(97% 0.001 106.424)",
        200: "oklch(92.3% 0.003 48.717)",
        300: "oklch(86.9% 0.005 56.366)",
        400: "oklch(70.9% 0.01 56.259)",
        500: "oklch(55.3% 0.013 58.071)",
        600: "oklch(44.4% 0.011 73.639)",
        700: "oklch(37.4% 0.01 67.558)",
        800: "oklch(26.8% 0.007 34.298)",
        900: "oklch(21.6% 0.006 56.043)",
        950: "oklch(14.7% 0.004 49.25)"
    },
    red: {
        50: "oklch(97.1% 0.013 17.38)",
        100: "oklch(93.6% 0.032 17.717)",
        200: "oklch(88.5% 0.062 18.334)",
        300: "oklch(80.8% 0.114 19.571)",
        400: "oklch(70.4% 0.191 22.216)",
        500: "oklch(63.7% 0.237 25.331)",
        600: "oklch(57.7% 0.245 27.325)",
        700: "oklch(50.5% 0.213 27.518)",
        800: "oklch(44.4% 0.177 26.899)",
        900: "oklch(39.6% 0.141 25.723)",
        950: "oklch(25.8% 0.092 26.042)"
    },
    orange: {
        50: "oklch(98% 0.016 73.684)",
        100: "oklch(95.4% 0.038 75.164)",
        200: "oklch(90.1% 0.076 70.697)",
        300: "oklch(83.7% 0.128 66.29)",
        400: "oklch(75% 0.183 55.934)",
        500: "oklch(70.5% 0.213 47.604)",
        600: "oklch(64.6% 0.222 41.116)",
        700: "oklch(55.3% 0.195 38.402)",
        800: "oklch(47% 0.157 37.304)",
        900: "oklch(40.8% 0.123 38.172)",
        950: "oklch(26.6% 0.079 36.259)"
    },
    amber: {
        50: "oklch(98.7% 0.022 95.277)",
        100: "oklch(96.2% 0.059 95.617)",
        200: "oklch(92.4% 0.12 95.746)",
        300: "oklch(87.9% 0.169 91.605)",
        400: "oklch(82.8% 0.189 84.429)",
        500: "oklch(76.9% 0.188 70.08)",
        600: "oklch(66.6% 0.179 58.318)",
        700: "oklch(55.5% 0.163 48.998)",
        800: "oklch(47.3% 0.137 46.201)",
        900: "oklch(41.4% 0.112 45.904)",
        950: "oklch(27.9% 0.077 45.635)"
    },
    yellow: {
        50: "oklch(98.7% 0.026 102.212)",
        100: "oklch(97.3% 0.071 103.193)",
        200: "oklch(94.5% 0.129 101.54)",
        300: "oklch(90.5% 0.182 98.111)",
        400: "oklch(85.2% 0.199 91.936)",
        500: "oklch(79.5% 0.184 86.047)",
        600: "oklch(68.1% 0.162 75.834)",
        700: "oklch(55.4% 0.135 66.442)",
        800: "oklch(47.6% 0.114 61.907)",
        900: "oklch(42.1% 0.095 57.708)",
        950: "oklch(28.6% 0.066 53.813)"
    },
    lime: {
        50: "oklch(98.6% 0.031 120.757)",
        100: "oklch(96.7% 0.067 122.328)",
        200: "oklch(93.8% 0.127 124.321)",
        300: "oklch(89.7% 0.196 126.665)",
        400: "oklch(84.1% 0.238 128.85)",
        500: "oklch(76.8% 0.233 130.85)",
        600: "oklch(64.8% 0.2 131.684)",
        700: "oklch(53.2% 0.157 131.589)",
        800: "oklch(45.3% 0.124 130.933)",
        900: "oklch(40.5% 0.101 131.063)",
        950: "oklch(27.4% 0.072 132.109)"
    },
    green: {
        50: "oklch(98.2% 0.018 155.826)",
        100: "oklch(96.2% 0.044 156.743)",
        200: "oklch(92.5% 0.084 155.995)",
        300: "oklch(87.1% 0.15 154.449)",
        400: "oklch(79.2% 0.209 151.711)",
        500: "oklch(72.3% 0.219 149.579)",
        600: "oklch(62.7% 0.194 149.214)",
        700: "oklch(52.7% 0.154 150.069)",
        800: "oklch(44.8% 0.119 151.328)",
        900: "oklch(39.3% 0.095 152.535)",
        950: "oklch(26.6% 0.065 152.934)"
    },
    emerald: {
        50: "oklch(97.9% 0.021 166.113)",
        100: "oklch(95% 0.052 163.051)",
        200: "oklch(90.5% 0.093 164.15)",
        300: "oklch(84.5% 0.143 164.978)",
        400: "oklch(76.5% 0.177 163.223)",
        500: "oklch(69.6% 0.17 162.48)",
        600: "oklch(59.6% 0.145 163.225)",
        700: "oklch(50.8% 0.118 165.612)",
        800: "oklch(43.2% 0.095 166.913)",
        900: "oklch(37.8% 0.077 168.94)",
        950: "oklch(26.2% 0.051 172.552)"
    },
    teal: {
        50: "oklch(98.4% 0.014 180.72)",
        100: "oklch(95.3% 0.051 180.801)",
        200: "oklch(91% 0.096 180.426)",
        300: "oklch(85.5% 0.138 181.071)",
        400: "oklch(77.7% 0.152 181.912)",
        500: "oklch(70.4% 0.14 182.503)",
        600: "oklch(60% 0.118 184.704)",
        700: "oklch(51.1% 0.096 186.391)",
        800: "oklch(43.7% 0.078 188.216)",
        900: "oklch(38.6% 0.063 188.416)",
        950: "oklch(27.7% 0.046 192.524)"
    },
    cyan: {
        50: "oklch(98.4% 0.019 200.873)",
        100: "oklch(95.6% 0.045 203.388)",
        200: "oklch(91.7% 0.08 205.041)",
        300: "oklch(86.5% 0.127 207.078)",
        400: "oklch(78.9% 0.154 211.53)",
        500: "oklch(71.5% 0.143 215.221)",
        600: "oklch(60.9% 0.126 221.723)",
        700: "oklch(52% 0.105 223.128)",
        800: "oklch(45% 0.085 224.283)",
        900: "oklch(39.8% 0.07 227.392)",
        950: "oklch(30.2% 0.056 229.695)"
    },
    sky: {
        50: "oklch(97.7% 0.013 236.62)",
        100: "oklch(95.1% 0.026 236.824)",
        200: "oklch(90.1% 0.058 230.902)",
        300: "oklch(82.8% 0.111 230.318)",
        400: "oklch(74.6% 0.16 232.661)",
        500: "oklch(68.5% 0.169 237.323)",
        600: "oklch(58.8% 0.158 241.966)",
        700: "oklch(50% 0.134 242.749)",
        800: "oklch(44.3% 0.11 240.79)",
        900: "oklch(39.1% 0.09 240.876)",
        950: "oklch(29.3% 0.066 243.157)"
    },
    blue: {
        50: "oklch(97% 0.014 254.604)",
        100: "oklch(93.2% 0.032 255.585)",
        200: "oklch(88.2% 0.059 254.128)",
        300: "oklch(80.9% 0.105 251.813)",
        400: "oklch(70.7% 0.165 254.624)",
        500: "oklch(62.3% 0.214 259.815)",
        600: "oklch(54.6% 0.245 262.881)",
        700: "oklch(48.8% 0.243 264.376)",
        800: "oklch(42.4% 0.199 265.638)",
        900: "oklch(37.9% 0.146 265.522)",
        950: "oklch(28.2% 0.091 267.935)"
    },
    indigo: {
        50: "oklch(96.2% 0.018 272.314)",
        100: "oklch(93% 0.034 272.788)",
        200: "oklch(87% 0.065 274.039)",
        300: "oklch(78.5% 0.115 274.713)",
        400: "oklch(67.3% 0.182 276.935)",
        500: "oklch(58.5% 0.233 277.117)",
        600: "oklch(51.1% 0.262 276.966)",
        700: "oklch(45.7% 0.24 277.023)",
        800: "oklch(39.8% 0.195 277.366)",
        900: "oklch(35.9% 0.144 278.697)",
        950: "oklch(25.7% 0.09 281.288)"
    },
    violet: {
        50: "oklch(96.9% 0.016 293.756)",
        100: "oklch(94.3% 0.029 294.588)",
        200: "oklch(89.4% 0.057 293.283)",
        300: "oklch(81.1% 0.111 293.571)",
        400: "oklch(70.2% 0.183 293.541)",
        500: "oklch(60.6% 0.25 292.717)",
        600: "oklch(54.1% 0.281 293.009)",
        700: "oklch(49.1% 0.27 292.581)",
        800: "oklch(43.2% 0.232 292.759)",
        900: "oklch(38% 0.189 293.745)",
        950: "oklch(28.3% 0.141 291.089)"
    },
    purple: {
        50: "oklch(97.7% 0.014 308.299)",
        100: "oklch(94.6% 0.033 307.174)",
        200: "oklch(90.2% 0.063 306.703)",
        300: "oklch(82.7% 0.119 306.383)",
        400: "oklch(71.4% 0.203 305.504)",
        500: "oklch(62.7% 0.265 303.9)",
        600: "oklch(55.8% 0.288 302.321)",
        700: "oklch(49.6% 0.265 301.924)",
        800: "oklch(43.8% 0.218 303.724)",
        900: "oklch(38.1% 0.176 304.987)",
        950: "oklch(29.1% 0.149 302.717)"
    },
    fuchsia: {
        50: "oklch(97.7% 0.017 320.058)",
        100: "oklch(95.2% 0.037 318.852)",
        200: "oklch(90.3% 0.076 319.62)",
        300: "oklch(83.3% 0.145 321.434)",
        400: "oklch(74% 0.238 322.16)",
        500: "oklch(66.7% 0.295 322.15)",
        600: "oklch(59.1% 0.293 322.896)",
        700: "oklch(51.8% 0.253 323.949)",
        800: "oklch(45.2% 0.211 324.591)",
        900: "oklch(40.1% 0.17 325.612)",
        950: "oklch(29.3% 0.136 325.661)"
    },
    pink: {
        50: "oklch(97.1% 0.014 343.198)",
        100: "oklch(94.8% 0.028 342.258)",
        200: "oklch(89.9% 0.061 343.231)",
        300: "oklch(82.3% 0.12 346.018)",
        400: "oklch(71.8% 0.202 349.761)",
        500: "oklch(65.6% 0.241 354.308)",
        600: "oklch(59.2% 0.249 0.584)",
        700: "oklch(52.5% 0.223 3.958)",
        800: "oklch(45.9% 0.187 3.815)",
        900: "oklch(40.8% 0.153 2.432)",
        950: "oklch(28.4% 0.109 3.907)"
    },
    rose: {
        50: "oklch(96.9% 0.015 12.422)",
        100: "oklch(94.1% 0.03 12.58)",
        200: "oklch(89.2% 0.058 10.001)",
        300: "oklch(81% 0.117 11.638)",
        400: "oklch(71.2% 0.194 13.428)",
        500: "oklch(64.5% 0.246 16.439)",
        600: "oklch(58.6% 0.253 17.585)",
        700: "oklch(51.4% 0.222 16.935)",
        800: "oklch(45.5% 0.188 13.697)",
        900: "oklch(41% 0.159 10.272)",
        950: "oklch(27.1% 0.105 12.094)"
    }
};
function _(e) {
    return {
        __BARE_VALUE__: e
    };
}
var $ = _((e)=>{
    if (b(e.value)) return e.value;
}), w = _((e)=>{
    if (b(e.value)) return `${e.value}%`;
}), P = _((e)=>{
    if (b(e.value)) return `${e.value}px`;
}), Ye = _((e)=>{
    if (b(e.value)) return `${e.value}ms`;
}), ie = _((e)=>{
    if (b(e.value)) return `${e.value}deg`;
}), rr = _((e)=>{
    if (e.fraction === null) return;
    let [r, t] = k(e.fraction, "/");
    if (!(!b(r) || !b(t))) return e.fraction;
}), Ze = _((e)=>{
    if (b(Number(e.value))) return `repeat(${e.value}, minmax(0, 1fr))`;
}), ir = {
    accentColor: ({ theme: e })=>e("colors"),
    animation: {
        none: "none",
        spin: "spin 1s linear infinite",
        ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite",
        pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
        bounce: "bounce 1s infinite"
    },
    aria: {
        busy: 'busy="true"',
        checked: 'checked="true"',
        disabled: 'disabled="true"',
        expanded: 'expanded="true"',
        hidden: 'hidden="true"',
        pressed: 'pressed="true"',
        readonly: 'readonly="true"',
        required: 'required="true"',
        selected: 'selected="true"'
    },
    aspectRatio: {
        auto: "auto",
        square: "1 / 1",
        video: "16 / 9",
        ...rr
    },
    backdropBlur: ({ theme: e })=>e("blur"),
    backdropBrightness: ({ theme: e })=>({
            ...e("brightness"),
            ...w
        }),
    backdropContrast: ({ theme: e })=>({
            ...e("contrast"),
            ...w
        }),
    backdropGrayscale: ({ theme: e })=>({
            ...e("grayscale"),
            ...w
        }),
    backdropHueRotate: ({ theme: e })=>({
            ...e("hueRotate"),
            ...ie
        }),
    backdropInvert: ({ theme: e })=>({
            ...e("invert"),
            ...w
        }),
    backdropOpacity: ({ theme: e })=>({
            ...e("opacity"),
            ...w
        }),
    backdropSaturate: ({ theme: e })=>({
            ...e("saturate"),
            ...w
        }),
    backdropSepia: ({ theme: e })=>({
            ...e("sepia"),
            ...w
        }),
    backgroundColor: ({ theme: e })=>e("colors"),
    backgroundImage: {
        none: "none",
        "gradient-to-t": "linear-gradient(to top, var(--tw-gradient-stops))",
        "gradient-to-tr": "linear-gradient(to top right, var(--tw-gradient-stops))",
        "gradient-to-r": "linear-gradient(to right, var(--tw-gradient-stops))",
        "gradient-to-br": "linear-gradient(to bottom right, var(--tw-gradient-stops))",
        "gradient-to-b": "linear-gradient(to bottom, var(--tw-gradient-stops))",
        "gradient-to-bl": "linear-gradient(to bottom left, var(--tw-gradient-stops))",
        "gradient-to-l": "linear-gradient(to left, var(--tw-gradient-stops))",
        "gradient-to-tl": "linear-gradient(to top left, var(--tw-gradient-stops))"
    },
    backgroundOpacity: ({ theme: e })=>e("opacity"),
    backgroundPosition: {
        bottom: "bottom",
        center: "center",
        left: "left",
        "left-bottom": "left bottom",
        "left-top": "left top",
        right: "right",
        "right-bottom": "right bottom",
        "right-top": "right top",
        top: "top"
    },
    backgroundSize: {
        auto: "auto",
        cover: "cover",
        contain: "contain"
    },
    blur: {
        0: "0",
        none: "",
        sm: "4px",
        DEFAULT: "8px",
        md: "12px",
        lg: "16px",
        xl: "24px",
        "2xl": "40px",
        "3xl": "64px"
    },
    borderColor: ({ theme: e })=>({
            DEFAULT: "currentcolor",
            ...e("colors")
        }),
    borderOpacity: ({ theme: e })=>e("opacity"),
    borderRadius: {
        none: "0px",
        sm: "0.125rem",
        DEFAULT: "0.25rem",
        md: "0.375rem",
        lg: "0.5rem",
        xl: "0.75rem",
        "2xl": "1rem",
        "3xl": "1.5rem",
        full: "9999px"
    },
    borderSpacing: ({ theme: e })=>e("spacing"),
    borderWidth: {
        DEFAULT: "1px",
        0: "0px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...P
    },
    boxShadow: {
        sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)",
        DEFAULT: "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)",
        md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
        lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
        xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)",
        "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)",
        inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)",
        none: "none"
    },
    boxShadowColor: ({ theme: e })=>e("colors"),
    brightness: {
        0: "0",
        50: ".5",
        75: ".75",
        90: ".9",
        95: ".95",
        100: "1",
        105: "1.05",
        110: "1.1",
        125: "1.25",
        150: "1.5",
        200: "2",
        ...w
    },
    caretColor: ({ theme: e })=>e("colors"),
    colors: ()=>({
            ...ye
        }),
    columns: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        "3xs": "16rem",
        "2xs": "18rem",
        xs: "20rem",
        sm: "24rem",
        md: "28rem",
        lg: "32rem",
        xl: "36rem",
        "2xl": "42rem",
        "3xl": "48rem",
        "4xl": "56rem",
        "5xl": "64rem",
        "6xl": "72rem",
        "7xl": "80rem",
        ...$
    },
    container: {},
    content: {
        none: "none"
    },
    contrast: {
        0: "0",
        50: ".5",
        75: ".75",
        100: "1",
        125: "1.25",
        150: "1.5",
        200: "2",
        ...w
    },
    cursor: {
        auto: "auto",
        default: "default",
        pointer: "pointer",
        wait: "wait",
        text: "text",
        move: "move",
        help: "help",
        "not-allowed": "not-allowed",
        none: "none",
        "context-menu": "context-menu",
        progress: "progress",
        cell: "cell",
        crosshair: "crosshair",
        "vertical-text": "vertical-text",
        alias: "alias",
        copy: "copy",
        "no-drop": "no-drop",
        grab: "grab",
        grabbing: "grabbing",
        "all-scroll": "all-scroll",
        "col-resize": "col-resize",
        "row-resize": "row-resize",
        "n-resize": "n-resize",
        "e-resize": "e-resize",
        "s-resize": "s-resize",
        "w-resize": "w-resize",
        "ne-resize": "ne-resize",
        "nw-resize": "nw-resize",
        "se-resize": "se-resize",
        "sw-resize": "sw-resize",
        "ew-resize": "ew-resize",
        "ns-resize": "ns-resize",
        "nesw-resize": "nesw-resize",
        "nwse-resize": "nwse-resize",
        "zoom-in": "zoom-in",
        "zoom-out": "zoom-out"
    },
    divideColor: ({ theme: e })=>e("borderColor"),
    divideOpacity: ({ theme: e })=>e("borderOpacity"),
    divideWidth: ({ theme: e })=>({
            ...e("borderWidth"),
            ...P
        }),
    dropShadow: {
        sm: "0 1px 1px rgb(0 0 0 / 0.05)",
        DEFAULT: [
            "0 1px 2px rgb(0 0 0 / 0.1)",
            "0 1px 1px rgb(0 0 0 / 0.06)"
        ],
        md: [
            "0 4px 3px rgb(0 0 0 / 0.07)",
            "0 2px 2px rgb(0 0 0 / 0.06)"
        ],
        lg: [
            "0 10px 8px rgb(0 0 0 / 0.04)",
            "0 4px 3px rgb(0 0 0 / 0.1)"
        ],
        xl: [
            "0 20px 13px rgb(0 0 0 / 0.03)",
            "0 8px 5px rgb(0 0 0 / 0.08)"
        ],
        "2xl": "0 25px 25px rgb(0 0 0 / 0.15)",
        none: "0 0 #0000"
    },
    fill: ({ theme: e })=>e("colors"),
    flex: {
        1: "1 1 0%",
        auto: "1 1 auto",
        initial: "0 1 auto",
        none: "none"
    },
    flexBasis: ({ theme: e })=>({
            auto: "auto",
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            "1/12": "8.333333%",
            "2/12": "16.666667%",
            "3/12": "25%",
            "4/12": "33.333333%",
            "5/12": "41.666667%",
            "6/12": "50%",
            "7/12": "58.333333%",
            "8/12": "66.666667%",
            "9/12": "75%",
            "10/12": "83.333333%",
            "11/12": "91.666667%",
            full: "100%",
            ...e("spacing")
        }),
    flexGrow: {
        0: "0",
        DEFAULT: "1",
        ...$
    },
    flexShrink: {
        0: "0",
        DEFAULT: "1",
        ...$
    },
    fontFamily: {
        sans: [
            "ui-sans-serif",
            "system-ui",
            "sans-serif",
            '"Apple Color Emoji"',
            '"Segoe UI Emoji"',
            '"Segoe UI Symbol"',
            '"Noto Color Emoji"'
        ],
        serif: [
            "ui-serif",
            "Georgia",
            "Cambria",
            '"Times New Roman"',
            "Times",
            "serif"
        ],
        mono: [
            "ui-monospace",
            "SFMono-Regular",
            "Menlo",
            "Monaco",
            "Consolas",
            '"Liberation Mono"',
            '"Courier New"',
            "monospace"
        ]
    },
    fontSize: {
        xs: [
            "0.75rem",
            {
                lineHeight: "1rem"
            }
        ],
        sm: [
            "0.875rem",
            {
                lineHeight: "1.25rem"
            }
        ],
        base: [
            "1rem",
            {
                lineHeight: "1.5rem"
            }
        ],
        lg: [
            "1.125rem",
            {
                lineHeight: "1.75rem"
            }
        ],
        xl: [
            "1.25rem",
            {
                lineHeight: "1.75rem"
            }
        ],
        "2xl": [
            "1.5rem",
            {
                lineHeight: "2rem"
            }
        ],
        "3xl": [
            "1.875rem",
            {
                lineHeight: "2.25rem"
            }
        ],
        "4xl": [
            "2.25rem",
            {
                lineHeight: "2.5rem"
            }
        ],
        "5xl": [
            "3rem",
            {
                lineHeight: "1"
            }
        ],
        "6xl": [
            "3.75rem",
            {
                lineHeight: "1"
            }
        ],
        "7xl": [
            "4.5rem",
            {
                lineHeight: "1"
            }
        ],
        "8xl": [
            "6rem",
            {
                lineHeight: "1"
            }
        ],
        "9xl": [
            "8rem",
            {
                lineHeight: "1"
            }
        ]
    },
    fontWeight: {
        thin: "100",
        extralight: "200",
        light: "300",
        normal: "400",
        medium: "500",
        semibold: "600",
        bold: "700",
        extrabold: "800",
        black: "900"
    },
    gap: ({ theme: e })=>e("spacing"),
    gradientColorStops: ({ theme: e })=>e("colors"),
    gradientColorStopPositions: {
        "0%": "0%",
        "5%": "5%",
        "10%": "10%",
        "15%": "15%",
        "20%": "20%",
        "25%": "25%",
        "30%": "30%",
        "35%": "35%",
        "40%": "40%",
        "45%": "45%",
        "50%": "50%",
        "55%": "55%",
        "60%": "60%",
        "65%": "65%",
        "70%": "70%",
        "75%": "75%",
        "80%": "80%",
        "85%": "85%",
        "90%": "90%",
        "95%": "95%",
        "100%": "100%",
        ...w
    },
    grayscale: {
        0: "0",
        DEFAULT: "100%",
        ...w
    },
    gridAutoColumns: {
        auto: "auto",
        min: "min-content",
        max: "max-content",
        fr: "minmax(0, 1fr)"
    },
    gridAutoRows: {
        auto: "auto",
        min: "min-content",
        max: "max-content",
        fr: "minmax(0, 1fr)"
    },
    gridColumn: {
        auto: "auto",
        "span-1": "span 1 / span 1",
        "span-2": "span 2 / span 2",
        "span-3": "span 3 / span 3",
        "span-4": "span 4 / span 4",
        "span-5": "span 5 / span 5",
        "span-6": "span 6 / span 6",
        "span-7": "span 7 / span 7",
        "span-8": "span 8 / span 8",
        "span-9": "span 9 / span 9",
        "span-10": "span 10 / span 10",
        "span-11": "span 11 / span 11",
        "span-12": "span 12 / span 12",
        "span-full": "1 / -1"
    },
    gridColumnEnd: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13",
        ...$
    },
    gridColumnStart: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13",
        ...$
    },
    gridRow: {
        auto: "auto",
        "span-1": "span 1 / span 1",
        "span-2": "span 2 / span 2",
        "span-3": "span 3 / span 3",
        "span-4": "span 4 / span 4",
        "span-5": "span 5 / span 5",
        "span-6": "span 6 / span 6",
        "span-7": "span 7 / span 7",
        "span-8": "span 8 / span 8",
        "span-9": "span 9 / span 9",
        "span-10": "span 10 / span 10",
        "span-11": "span 11 / span 11",
        "span-12": "span 12 / span 12",
        "span-full": "1 / -1"
    },
    gridRowEnd: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13",
        ...$
    },
    gridRowStart: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13",
        ...$
    },
    gridTemplateColumns: {
        none: "none",
        subgrid: "subgrid",
        1: "repeat(1, minmax(0, 1fr))",
        2: "repeat(2, minmax(0, 1fr))",
        3: "repeat(3, minmax(0, 1fr))",
        4: "repeat(4, minmax(0, 1fr))",
        5: "repeat(5, minmax(0, 1fr))",
        6: "repeat(6, minmax(0, 1fr))",
        7: "repeat(7, minmax(0, 1fr))",
        8: "repeat(8, minmax(0, 1fr))",
        9: "repeat(9, minmax(0, 1fr))",
        10: "repeat(10, minmax(0, 1fr))",
        11: "repeat(11, minmax(0, 1fr))",
        12: "repeat(12, minmax(0, 1fr))",
        ...Ze
    },
    gridTemplateRows: {
        none: "none",
        subgrid: "subgrid",
        1: "repeat(1, minmax(0, 1fr))",
        2: "repeat(2, minmax(0, 1fr))",
        3: "repeat(3, minmax(0, 1fr))",
        4: "repeat(4, minmax(0, 1fr))",
        5: "repeat(5, minmax(0, 1fr))",
        6: "repeat(6, minmax(0, 1fr))",
        7: "repeat(7, minmax(0, 1fr))",
        8: "repeat(8, minmax(0, 1fr))",
        9: "repeat(9, minmax(0, 1fr))",
        10: "repeat(10, minmax(0, 1fr))",
        11: "repeat(11, minmax(0, 1fr))",
        12: "repeat(12, minmax(0, 1fr))",
        ...Ze
    },
    height: ({ theme: e })=>({
            auto: "auto",
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            full: "100%",
            screen: "100vh",
            svh: "100svh",
            lvh: "100lvh",
            dvh: "100dvh",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    hueRotate: {
        0: "0deg",
        15: "15deg",
        30: "30deg",
        60: "60deg",
        90: "90deg",
        180: "180deg",
        ...ie
    },
    inset: ({ theme: e })=>({
            auto: "auto",
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            full: "100%",
            ...e("spacing")
        }),
    invert: {
        0: "0",
        DEFAULT: "100%",
        ...w
    },
    keyframes: {
        spin: {
            to: {
                transform: "rotate(360deg)"
            }
        },
        ping: {
            "75%, 100%": {
                transform: "scale(2)",
                opacity: "0"
            }
        },
        pulse: {
            "50%": {
                opacity: ".5"
            }
        },
        bounce: {
            "0%, 100%": {
                transform: "translateY(-25%)",
                animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
            },
            "50%": {
                transform: "none",
                animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
            }
        }
    },
    letterSpacing: {
        tighter: "-0.05em",
        tight: "-0.025em",
        normal: "0em",
        wide: "0.025em",
        wider: "0.05em",
        widest: "0.1em"
    },
    lineHeight: {
        none: "1",
        tight: "1.25",
        snug: "1.375",
        normal: "1.5",
        relaxed: "1.625",
        loose: "2",
        3: ".75rem",
        4: "1rem",
        5: "1.25rem",
        6: "1.5rem",
        7: "1.75rem",
        8: "2rem",
        9: "2.25rem",
        10: "2.5rem"
    },
    listStyleType: {
        none: "none",
        disc: "disc",
        decimal: "decimal"
    },
    listStyleImage: {
        none: "none"
    },
    margin: ({ theme: e })=>({
            auto: "auto",
            ...e("spacing")
        }),
    lineClamp: {
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        ...$
    },
    maxHeight: ({ theme: e })=>({
            none: "none",
            full: "100%",
            screen: "100vh",
            svh: "100svh",
            lvh: "100lvh",
            dvh: "100dvh",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    maxWidth: ({ theme: e })=>({
            none: "none",
            xs: "20rem",
            sm: "24rem",
            md: "28rem",
            lg: "32rem",
            xl: "36rem",
            "2xl": "42rem",
            "3xl": "48rem",
            "4xl": "56rem",
            "5xl": "64rem",
            "6xl": "72rem",
            "7xl": "80rem",
            full: "100%",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            prose: "65ch",
            ...e("spacing")
        }),
    minHeight: ({ theme: e })=>({
            full: "100%",
            screen: "100vh",
            svh: "100svh",
            lvh: "100lvh",
            dvh: "100dvh",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    minWidth: ({ theme: e })=>({
            full: "100%",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    objectPosition: {
        bottom: "bottom",
        center: "center",
        left: "left",
        "left-bottom": "left bottom",
        "left-top": "left top",
        right: "right",
        "right-bottom": "right bottom",
        "right-top": "right top",
        top: "top"
    },
    opacity: {
        0: "0",
        5: "0.05",
        10: "0.1",
        15: "0.15",
        20: "0.2",
        25: "0.25",
        30: "0.3",
        35: "0.35",
        40: "0.4",
        45: "0.45",
        50: "0.5",
        55: "0.55",
        60: "0.6",
        65: "0.65",
        70: "0.7",
        75: "0.75",
        80: "0.8",
        85: "0.85",
        90: "0.9",
        95: "0.95",
        100: "1",
        ...w
    },
    order: {
        first: "-9999",
        last: "9999",
        none: "0",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        ...$
    },
    outlineColor: ({ theme: e })=>e("colors"),
    outlineOffset: {
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...P
    },
    outlineWidth: {
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...P
    },
    padding: ({ theme: e })=>e("spacing"),
    placeholderColor: ({ theme: e })=>e("colors"),
    placeholderOpacity: ({ theme: e })=>e("opacity"),
    ringColor: ({ theme: e })=>({
            DEFAULT: "currentcolor",
            ...e("colors")
        }),
    ringOffsetColor: ({ theme: e })=>e("colors"),
    ringOffsetWidth: {
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...P
    },
    ringOpacity: ({ theme: e })=>({
            DEFAULT: "0.5",
            ...e("opacity")
        }),
    ringWidth: {
        DEFAULT: "3px",
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...P
    },
    rotate: {
        0: "0deg",
        1: "1deg",
        2: "2deg",
        3: "3deg",
        6: "6deg",
        12: "12deg",
        45: "45deg",
        90: "90deg",
        180: "180deg",
        ...ie
    },
    saturate: {
        0: "0",
        50: ".5",
        100: "1",
        150: "1.5",
        200: "2",
        ...w
    },
    scale: {
        0: "0",
        50: ".5",
        75: ".75",
        90: ".9",
        95: ".95",
        100: "1",
        105: "1.05",
        110: "1.1",
        125: "1.25",
        150: "1.5",
        ...w
    },
    screens: {
        sm: "40rem",
        md: "48rem",
        lg: "64rem",
        xl: "80rem",
        "2xl": "96rem"
    },
    scrollMargin: ({ theme: e })=>e("spacing"),
    scrollPadding: ({ theme: e })=>e("spacing"),
    sepia: {
        0: "0",
        DEFAULT: "100%",
        ...w
    },
    skew: {
        0: "0deg",
        1: "1deg",
        2: "2deg",
        3: "3deg",
        6: "6deg",
        12: "12deg",
        ...ie
    },
    space: ({ theme: e })=>e("spacing"),
    spacing: {
        px: "1px",
        0: "0px",
        .5: "0.125rem",
        1: "0.25rem",
        1.5: "0.375rem",
        2: "0.5rem",
        2.5: "0.625rem",
        3: "0.75rem",
        3.5: "0.875rem",
        4: "1rem",
        5: "1.25rem",
        6: "1.5rem",
        7: "1.75rem",
        8: "2rem",
        9: "2.25rem",
        10: "2.5rem",
        11: "2.75rem",
        12: "3rem",
        14: "3.5rem",
        16: "4rem",
        20: "5rem",
        24: "6rem",
        28: "7rem",
        32: "8rem",
        36: "9rem",
        40: "10rem",
        44: "11rem",
        48: "12rem",
        52: "13rem",
        56: "14rem",
        60: "15rem",
        64: "16rem",
        72: "18rem",
        80: "20rem",
        96: "24rem"
    },
    stroke: ({ theme: e })=>({
            none: "none",
            ...e("colors")
        }),
    strokeWidth: {
        0: "0",
        1: "1",
        2: "2",
        ...$
    },
    supports: {},
    data: {},
    textColor: ({ theme: e })=>e("colors"),
    textDecorationColor: ({ theme: e })=>e("colors"),
    textDecorationThickness: {
        auto: "auto",
        "from-font": "from-font",
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...P
    },
    textIndent: ({ theme: e })=>e("spacing"),
    textOpacity: ({ theme: e })=>e("opacity"),
    textUnderlineOffset: {
        auto: "auto",
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...P
    },
    transformOrigin: {
        center: "center",
        top: "top",
        "top-right": "top right",
        right: "right",
        "bottom-right": "bottom right",
        bottom: "bottom",
        "bottom-left": "bottom left",
        left: "left",
        "top-left": "top left"
    },
    transitionDelay: {
        0: "0s",
        75: "75ms",
        100: "100ms",
        150: "150ms",
        200: "200ms",
        300: "300ms",
        500: "500ms",
        700: "700ms",
        1e3: "1000ms",
        ...Ye
    },
    transitionDuration: {
        DEFAULT: "150ms",
        0: "0s",
        75: "75ms",
        100: "100ms",
        150: "150ms",
        200: "200ms",
        300: "300ms",
        500: "500ms",
        700: "700ms",
        1e3: "1000ms",
        ...Ye
    },
    transitionProperty: {
        none: "none",
        all: "all",
        DEFAULT: "color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter",
        colors: "color, background-color, border-color, outline-color, text-decoration-color, fill, stroke",
        opacity: "opacity",
        shadow: "box-shadow",
        transform: "transform"
    },
    transitionTimingFunction: {
        DEFAULT: "cubic-bezier(0.4, 0, 0.2, 1)",
        linear: "linear",
        in: "cubic-bezier(0.4, 0, 1, 1)",
        out: "cubic-bezier(0, 0, 0.2, 1)",
        "in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
    },
    translate: ({ theme: e })=>({
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            full: "100%",
            ...e("spacing")
        }),
    size: ({ theme: e })=>({
            auto: "auto",
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            "1/12": "8.333333%",
            "2/12": "16.666667%",
            "3/12": "25%",
            "4/12": "33.333333%",
            "5/12": "41.666667%",
            "6/12": "50%",
            "7/12": "58.333333%",
            "8/12": "66.666667%",
            "9/12": "75%",
            "10/12": "83.333333%",
            "11/12": "91.666667%",
            full: "100%",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    width: ({ theme: e })=>({
            auto: "auto",
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            "1/12": "8.333333%",
            "2/12": "16.666667%",
            "3/12": "25%",
            "4/12": "33.333333%",
            "5/12": "41.666667%",
            "6/12": "50%",
            "7/12": "58.333333%",
            "8/12": "66.666667%",
            "9/12": "75%",
            "10/12": "83.333333%",
            "11/12": "91.666667%",
            full: "100%",
            screen: "100vw",
            svw: "100svw",
            lvw: "100lvw",
            dvw: "100dvw",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    willChange: {
        auto: "auto",
        scroll: "scroll-position",
        contents: "contents",
        transform: "transform"
    },
    zIndex: {
        auto: "auto",
        0: "0",
        10: "10",
        20: "20",
        30: "30",
        40: "40",
        50: "50",
        ...$
    }
};
var nr = 64;
function U(e, r = []) {
    return {
        kind: "rule",
        selector: e,
        nodes: r
    };
}
function A(e, r = "", t = []) {
    return {
        kind: "at-rule",
        name: e,
        params: r,
        nodes: t
    };
}
function R(e, r = []) {
    return e.charCodeAt(0) === nr ? H(e, r) : U(e, r);
}
function T(e, r, t = !1) {
    return {
        kind: "declaration",
        property: e,
        value: r,
        important: t
    };
}
function ke(e) {
    return {
        kind: "comment",
        value: e
    };
}
function y(e, r, t = [], i = {}) {
    for(let n = 0; n < e.length; n++){
        let l = e[n], o = t[t.length - 1] ?? null;
        if (l.kind === "context") {
            if (y(l.nodes, r, t, {
                ...i,
                ...l.context
            }) === 2) return 2;
            continue;
        }
        t.push(l);
        let s = !1, a = 0, u = r(l, {
            parent: o,
            context: i,
            path: t,
            replaceWith (p) {
                s || (s = !0, Array.isArray(p) ? p.length === 0 ? (e.splice(n, 1), a = 0) : p.length === 1 ? (e[n] = p[0], a = 1) : (e.splice(n, 1, ...p), a = p.length) : (e[n] = p, a = 1));
            }
        }) ?? 0;
        if (t.pop(), s) {
            u === 0 ? n-- : n += a - 1;
            continue;
        }
        if (u === 2) return 2;
        if (u !== 1 && "nodes" in l) {
            t.push(l);
            let p = y(l.nodes, r, t, i);
            if (t.pop(), p === 2) return 2;
        }
    }
}
function K(e, r) {
    let t = 0, i = {
        file: null,
        code: ""
    };
    function n(o, s = 0) {
        let a = "", u = "  ".repeat(s);
        if (o.kind === "declaration") {
            if (a += `${u}${o.property}: ${o.value}${o.important ? " !important" : ""};
`, r) {
                t += u.length;
                let p = t;
                t += o.property.length, t += 2, t += o.value?.length ?? 0, o.important && (t += 11);
                let c = t;
                t += 2, o.dst = [
                    i,
                    p,
                    c
                ];
            }
        } else if (o.kind === "rule") {
            if (a += `${u}${o.selector} {
`, r) {
                t += u.length;
                let p = t;
                t += o.selector.length, t += 1;
                let c = t;
                o.dst = [
                    i,
                    p,
                    c
                ], t += 2;
            }
            for (let p of o.nodes)a += n(p, s + 1);
            a += `${u}}
`, r && (t += u.length, t += 2);
        } else if (o.kind === "at-rule") {
            if (o.nodes.length === 0) {
                let p = `${u}${o.name} ${o.params};
`;
                if (r) {
                    t += u.length;
                    let c = t;
                    t += o.name.length, t += 1, t += o.params.length;
                    let f = t;
                    t += 2, o.dst = [
                        i,
                        c,
                        f
                    ];
                }
                return p;
            }
            if (a += `${u}${o.name}${o.params ? ` ${o.params} ` : " "}{
`, r) {
                t += u.length;
                let p = t;
                t += o.name.length, o.params && (t += 1, t += o.params.length), t += 1;
                let c = t;
                o.dst = [
                    i,
                    p,
                    c
                ], t += 2;
            }
            for (let p of o.nodes)a += n(p, s + 1);
            a += `${u}}
`, r && (t += u.length, t += 2);
        } else if (o.kind === "comment") {
            if (a += `${u}/*${o.value}*/
`, r) {
                t += u.length;
                let p = t;
                t += 2 + o.value.length + 2;
                let c = t;
                o.dst = [
                    i,
                    p,
                    c
                ], t += 1;
            }
        } else if (o.kind === "context" || o.kind === "at-root") return "";
        return a;
    }
    let l = "";
    for (let o of e)l += n(o, 0);
    return i.code = l, l;
}
function or(e, r) {
    if (typeof e != "string") throw new TypeError("expected path to be a string");
    if (e === "\\" || e === "/") return "/";
    var t = e.length;
    if (t <= 1) return e;
    var i = "";
    if (t > 4 && e[3] === "\\") {
        var n = e[2];
        (n === "?" || n === ".") && e.slice(0, 2) === "\\\\" && (e = e.slice(2), i = "//");
    }
    var l = e.split(/[/\\]+/);
    return r !== !1 && l[l.length - 1] === "" && l.pop(), i + l.join("/");
}
function be(e) {
    let r = or(e);
    return e.startsWith("\\\\") && r.startsWith("/") && !r.startsWith("//") ? `/${r}` : r;
}
var Ae = /(?<!@import\s+)(?<=^|[^\w\-\u0080-\uffff])url\((\s*('[^']+'|"[^"]+")\s*|[^'")]+)\)/, Qe = /(?<=image-set\()((?:[\w-]{1,256}\([^)]*\)|[^)])*)(?=\))/, lr = /(?:gradient|element|cross-fade|image)\(/, ar = /^\s*data:/i, sr = /^([a-z]+:)?\/\//, ur = /^[A-Z_][.\w-]*\(/i, cr = /(?:^|\s)(?<url>[\w-]+\([^)]*\)|"[^"]*"|'[^']*'|[^,]\S*[^,])\s*(?:\s(?<descriptor>\w[^,]+))?(?:,|$)/g, fr = /(?<!\\)"/g, pr = /(?: |\\t|\\n|\\f|\\r)+/g, dr = (e)=>ar.test(e), mr = (e)=>sr.test(e);
async function Xe({ css: e, base: r, root: t }) {
    if (!e.includes("url(") && !e.includes("image-set(")) return e;
    let i = q(e), n = [];
    function l(o) {
        if (o[0] === "/") return o;
        let s = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["posix"].join(be(r), o), a = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["posix"].relative(be(t), s);
        return a.startsWith(".") || (a = "./" + a), a;
    }
    return y(i, (o)=>{
        if (o.kind !== "declaration" || !o.value) return;
        let s = Ae.test(o.value), a = Qe.test(o.value);
        if (s || a) {
            let u = a ? gr : et;
            n.push(u(o.value, l).then((p)=>{
                o.value = p;
            }));
        }
    }), n.length && await Promise.all(n), K(i);
}
function et(e, r) {
    return rt(e, Ae, async (t)=>{
        let [i, n] = t;
        return await tt(n.trim(), i, r);
    });
}
async function gr(e, r) {
    return await rt(e, Qe, async (t)=>{
        let [, i] = t;
        return await vr(i, async ({ url: l })=>Ae.test(l) ? await et(l, r) : lr.test(l) ? l : await tt(l, l, r));
    });
}
async function tt(e, r, t, i = "url") {
    let n = "", l = e[0];
    if ((l === '"' || l === "'") && (n = l, e = e.slice(1, -1)), hr(e)) return r;
    let o = await t(e);
    return n === "" && o !== encodeURI(o) && (n = '"'), n === "'" && o.includes("'") && (n = '"'), n === '"' && o.includes('"') && (o = o.replace(fr, '\\"')), `${i}(${n}${o}${n})`;
}
function hr(e, r) {
    return mr(e) || dr(e) || !e[0].match(/[\.a-zA-Z0-9_]/) || ur.test(e);
}
function vr(e, r) {
    return Promise.all(wr(e).map(async ({ url: t, descriptor: i })=>({
            url: await r({
                url: t,
                descriptor: i
            }),
            descriptor: i
        }))).then(kr);
}
function wr(e) {
    let r = e.trim().replace(pr, " ").replace(/\r?\n/, "").replace(/,\s+/, ", ").replaceAll(/\s+/g, " ").matchAll(cr);
    return Array.from(r, ({ groups: t })=>({
            url: t?.url?.trim() ?? "",
            descriptor: t?.descriptor?.trim() ?? ""
        })).filter(({ url: t })=>!!t);
}
function kr(e) {
    return e.map(({ url: r, descriptor: t })=>r + (t ? ` ${t}` : "")).join(", ");
}
async function rt(e, r, t) {
    let i, n = e, l = "";
    for(; i = r.exec(n);)l += n.slice(0, i.index), l += await t(i), n = n.slice(i.index + i[0].length);
    return l += n, l;
}
function st({ base: e, from: r, polyfills: t, onDependency: i, shouldRewriteUrls: n, customCssResolver: l, customJsResolver: o }) {
    return {
        base: e,
        polyfills: t,
        from: r,
        async loadModule (s, a) {
            return ct(s, a, i, o);
        },
        async loadStylesheet (s, a) {
            let u = await ft(s, a, i, l);
            return n && (u.content = await Xe({
                css: u.content,
                root: e,
                base: u.base
            })), u;
        }
    };
}
async function ut(e, r) {
    if (e.root && e.root !== "none") {
        let t = /[*{]/, i = [];
        for (let l of e.root.pattern.split("/")){
            if (t.test(l)) break;
            i.push(l);
        }
        if (!await __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__["default"].stat(__TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].resolve(r, i.join("/"))).then((l)=>l.isDirectory()).catch(()=>!1)) throw new Error(`The \`source(${e.root.pattern})\` does not exist`);
    }
}
async function Ca(e, r) {
    let t = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$4WXWQT6Y$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__c__as__compileAst$3e$__["compileAst"])(e, st(r));
    return await ut(t, r.base), t;
}
async function $a(e, r) {
    let t = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$4WXWQT6Y$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__d__as__compile$3e$__["compile"])(e, st(r));
    return await ut(t, r.base), t;
}
async function Sa(e, { base: r }) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$4WXWQT6Y$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__e__as__$5f$_unstable_$5f$loadDesignSystem$3e$__["__unstable__loadDesignSystem"])(e, {
        base: r,
        async loadModule (t, i) {
            return ct(t, i, ()=>{});
        },
        async loadStylesheet (t, i) {
            return ft(t, i, ()=>{});
        }
    });
}
async function ct(e, r, t, i) {
    if (e[0] !== ".") {
        let s = await lt(e, r, i);
        if (!s) throw new Error(`Could not resolve '${e}' from '${r}'`);
        let a = await ot((0, __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__["pathToFileURL"])(s).href);
        return {
            path: s,
            base: __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].dirname(s),
            module: a.default ?? a
        };
    }
    let n = await lt(e, r, i);
    if (!n) throw new Error(`Could not resolve '${e}' from '${r}'`);
    let [l, o] = await Promise.all([
        ot((0, __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__["pathToFileURL"])(n).href + "?id=" + Date.now()),
        Ee(n)
    ]);
    for (let s of o)t(s);
    return {
        path: n,
        base: __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].dirname(n),
        module: l.default ?? l
    };
}
async function ft(e, r, t, i) {
    let n = await $r(e, r, i);
    if (!n) throw new Error(`Could not resolve '${e}' from '${r}'`);
    if (t(n), typeof globalThis.__tw_readFile == "function") {
        let o = await globalThis.__tw_readFile(n, "utf-8");
        if (o) return {
            path: n,
            base: __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].dirname(n),
            content: o
        };
    }
    let l = await __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__["default"].readFile(n, "utf-8");
    return {
        path: n,
        base: __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].dirname(n),
        content: l
    };
}
var nt = null;
async function ot(e) {
    if (typeof globalThis.__tw_load == "function") {
        let r = await globalThis.__tw_load(e);
        if (r) return r;
    }
    try {
        return await Promise.resolve().then(()=>{
            const e = new Error("Cannot find module as expression is too dynamic");
            e.code = 'MODULE_NOT_FOUND';
            throw e;
        });
    } catch  {
        return nt ??= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jiti$2f$lib$2f$jiti$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["createJiti"])(__TURBOPACK__import$2e$meta__.url, {
            moduleCache: !1,
            fsCache: !1
        }), await nt.import(e);
    }
}
var Se = [
    "node_modules",
    ...process.env.NODE_PATH ? [
        process.env.NODE_PATH
    ] : []
], Cr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$enhanced$2d$resolve$2f$lib$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__["default"].ResolverFactory.createResolver({
    fileSystem: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$enhanced$2d$resolve$2f$lib$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__["default"].CachedInputFileSystem(__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"], 4e3),
    useSyncFileSystemCalls: !0,
    extensions: [
        ".css"
    ],
    mainFields: [
        "style"
    ],
    conditionNames: [
        "style"
    ],
    modules: Se
});
async function $r(e, r, t) {
    if (typeof globalThis.__tw_resolve == "function") {
        let i = globalThis.__tw_resolve(e, r);
        if (i) return Promise.resolve(i);
    }
    if (t) {
        let i = await t(e, r);
        if (i) return i;
    }
    return Ce(Cr, e, r);
}
var Sr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$enhanced$2d$resolve$2f$lib$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__["default"].ResolverFactory.createResolver({
    fileSystem: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$enhanced$2d$resolve$2f$lib$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__["default"].CachedInputFileSystem(__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"], 4e3),
    useSyncFileSystemCalls: !0,
    extensions: [
        ".js",
        ".json",
        ".node",
        ".ts"
    ],
    conditionNames: [
        "node",
        "import"
    ],
    modules: Se
}), Nr = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$enhanced$2d$resolve$2f$lib$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__["default"].ResolverFactory.createResolver({
    fileSystem: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$enhanced$2d$resolve$2f$lib$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__["default"].CachedInputFileSystem(__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"], 4e3),
    useSyncFileSystemCalls: !0,
    extensions: [
        ".js",
        ".json",
        ".node",
        ".ts"
    ],
    conditionNames: [
        "node",
        "require"
    ],
    modules: Se
});
async function lt(e, r, t) {
    if (typeof globalThis.__tw_resolve == "function") {
        let i = globalThis.__tw_resolve(e, r);
        if (i) return Promise.resolve(i);
    }
    if (t) {
        let i = await t(e, r);
        if (i) return i;
    }
    return Ce(Sr, e, r).catch(()=>Ce(Nr, e, r));
}
function Ce(e, r, t) {
    return new Promise((i, n)=>e.resolve({}, t, r, {}, (l, o)=>{
            if (l) return n(l);
            i(o);
        }));
}
Symbol.dispose ??= Symbol("Symbol.dispose");
Symbol.asyncDispose ??= Symbol("Symbol.asyncDispose");
var pt = class {
    constructor(r = (t)=>void process.stderr.write(`${t}
`)){
        this.defaultFlush = r;
    }
    #r = new g(()=>({
            value: 0
        }));
    #t = new g(()=>({
            value: 0n
        }));
    #e = [];
    hit(r) {
        this.#r.get(r).value++;
    }
    start(r) {
        let t = this.#e.map((n)=>n.label).join("//"), i = `${t}${t.length === 0 ? "" : "//"}${r}`;
        this.#r.get(i).value++, this.#t.get(i), this.#e.push({
            id: i,
            label: r,
            namespace: t,
            value: process.hrtime.bigint()
        });
    }
    end(r) {
        let t = process.hrtime.bigint();
        if (this.#e[this.#e.length - 1].label !== r) throw new Error(`Mismatched timer label: \`${r}\`, expected \`${this.#e[this.#e.length - 1].label}\``);
        let i = this.#e.pop(), n = t - i.value;
        this.#t.get(i.id).value += n;
    }
    reset() {
        this.#r.clear(), this.#t.clear(), this.#e.splice(0);
    }
    report(r = this.defaultFlush) {
        let t = [], i = !1;
        for(let o = this.#e.length - 1; o >= 0; o--)this.end(this.#e[o].label);
        for (let [o, { value: s }] of this.#r.entries()){
            if (this.#t.has(o)) continue;
            t.length === 0 && (i = !0, t.push("Hits:"));
            let a = o.split("//").length;
            t.push(`${"  ".repeat(a)}${o} ${ne(dt(`\xD7 ${s}`))}`);
        }
        this.#t.size > 0 && i && t.push(`
Timers:`);
        let n = -1 / 0, l = new Map;
        for (let [o, { value: s }] of this.#t){
            let a = `${(Number(s) / 1e6).toFixed(2)}ms`;
            l.set(o, a), n = Math.max(n, a.length);
        }
        for (let o of this.#t.keys()){
            let s = o.split("//").length;
            t.push(`${ne(`[${l.get(o).padStart(n, " ")}]`)}${"  ".repeat(s - 1)}${s === 1 ? " " : ne(" \u21B3 ")}${o.split("//").pop()} ${this.#r.get(o).value === 1 ? "" : ne(dt(`\xD7 ${this.#r.get(o).value}`))}`.trimEnd());
        }
        r(`
${t.join(`
`)}
`), this.reset();
    }
    [Symbol.dispose]() {
        le && this.report();
    }
};
function ne(e) {
    return `\x1B[2m${e}\x1B[22m`;
}
function dt(e) {
    return `\x1B[34m${e}\x1B[39m`;
}
;
;
;
function Oa(e, { file: r = "input.css", minify: t = !1, map: i } = {}) {
    function n(a, u) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lightningcss$2f$node$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["transform"])({
            filename: r,
            code: a,
            minify: t,
            sourceMap: typeof u < "u",
            inputSourceMap: u,
            drafts: {
                customMedia: !0
            },
            nonStandard: {
                deepSelectorCombinator: !0
            },
            include: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lightningcss$2f$node$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["Features"].Nesting | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lightningcss$2f$node$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["Features"].MediaQueries,
            exclude: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lightningcss$2f$node$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["Features"].LogicalProperties | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lightningcss$2f$node$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["Features"].DirSelector | __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lightningcss$2f$node$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["Features"].LightDark,
            targets: {
                safari: 16 << 16 | 1024,
                ios_saf: 16 << 16 | 1024,
                firefox: 8388608,
                chrome: 7274496
            },
            errorRecovery: !0
        });
    }
    let l = n(Buffer.from(e), i);
    i = l.map?.toString(), l = n(l.code, i), i = l.map?.toString();
    let o = l.code.toString(), s = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$magic$2d$string$2f$dist$2f$magic$2d$string$2e$es$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["default"](o);
    if (s.replaceAll("@media not (", "@media not all and ("), i !== void 0 && s.hasChanged()) {
        let a = s.generateMap({
            source: "original",
            hires: "boundary"
        }).toString();
        i = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ampproject$2f$remapping$2f$dist$2f$remapping$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["default"])([
            a,
            i
        ], ()=>null).toString();
    }
    return o = s.toString(), {
        code: o,
        map: i
    };
}
;
function Pr(e) {
    let r = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$source$2d$map$2d$js$2f$source$2d$map$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__["SourceMapGenerator"], t = 1, i = new g((n)=>({
            url: n?.url ?? `<unknown ${t++}>`,
            content: n?.content ?? "<none>"
        }));
    for (let n of e.mappings){
        let l = i.get(n.originalPosition?.source ?? null);
        r.addMapping({
            generated: n.generatedPosition,
            original: n.originalPosition,
            source: l.url,
            name: n.name
        }), r.setSourceContent(l.url, l.content);
    }
    return r.toString();
}
function Ka(e) {
    let r = typeof e == "string" ? e : Pr(e);
    return {
        raw: r,
        get inline () {
            let t = "";
            return t += "/*# sourceMappingURL=data:application/json;base64,", t += Buffer.from(r, "utf-8").toString("base64"), t += ` */
`, t;
        }
    };
}
if (!process.versions.bun) {
    let e = __TURBOPACK__imported__module__$5b$externals$5d2f$module__$5b$external$5d$__$28$module$2c$__cjs$29$__["createRequire"](__TURBOPACK__import$2e$meta__.url);
    __TURBOPACK__imported__module__$5b$externals$5d2f$module__$5b$external$5d$__$28$module$2c$__cjs$29$__["register"]?.((0, __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__["pathToFileURL"])(e.resolve("@tailwindcss/node/esm-cache-loader")));
}
;
}),
"[project]/node_modules/@tailwindcss/node/dist/index.mjs [postcss] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$externals$5d2f$module__$5b$external$5d$__$28$module$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/module [external] (module, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$url__$5b$external$5d$__$28$url$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/url [external] (url, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$enhanced$2d$resolve$2f$lib$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/enhanced-resolve/lib/index.js [postcss] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jiti$2f$lib$2f$jiti$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/jiti/lib/jiti.mjs [postcss] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs [external] (fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs/promises [external] (fs/promises, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/path [external] (path, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$lib$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/tailwindcss/dist/lib.mjs [postcss] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ampproject$2f$remapping$2f$dist$2f$remapping$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ampproject/remapping/dist/remapping.mjs [postcss] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lightningcss$2f$node$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lightningcss/node/index.mjs [postcss] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$source$2d$map$2d$js$2f$source$2d$map$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/source-map-js/source-map.js [postcss] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$node$2f$dist$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@tailwindcss/node/dist/index.mjs [postcss] (ecmascript) <locals>");
}),
"[project]/node_modules/@tailwindcss/node/dist/require-cache.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var i = Object.defineProperty;
var a = Object.getOwnPropertyDescriptor;
var f = Object.getOwnPropertyNames;
var l = Object.prototype.hasOwnProperty;
var n = (r, e)=>{
    for(var t in e)i(r, t, {
        get: e[t],
        enumerable: !0
    });
}, u = (r, e, t, o)=>{
    if (e && typeof e == "object" || typeof e == "function") for (let c of f(e))!l.call(r, c) && c !== t && i(r, c, {
        get: ()=>e[c],
        enumerable: !(o = a(e, c)) || o.enumerable
    });
    return r;
};
var h = (r)=>u(i({}, "__esModule", {
        value: !0
    }), r);
var d = {};
n(d, {
    clearRequireCache: ()=>q
});
module.exports = h(d);
function q(r) {
    for (let e of r)delete __turbopack_context__.c[e];
}
0 && (module.exports = {
    clearRequireCache
});
}}),
"[project]/node_modules/@tailwindcss/oxide/index.js [postcss] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
// prettier-ignore
/* eslint-disable */ // @ts-nocheck
/* auto-generated by NAPI-RS */ const { createRequire } = __turbopack_context__.r("[externals]/node:module [external] (node:module, cjs)");
"TURBOPACK member replacement", __turbopack_context__.t;
const { readFileSync } = __turbopack_context__.r("[externals]/node:fs [external] (node:fs, cjs)");
let nativeBinding = null;
const loadErrors = [];
const isMusl = ()=>{
    let musl = false;
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    return musl;
};
const isFileMusl = (f)=>f.includes('libc.musl-') || f.includes('ld-musl-');
const isMuslFromFilesystem = ()=>{
    try {
        return readFileSync('/usr/bin/ldd', 'utf-8').includes('musl');
    } catch  {
        return null;
    }
};
const isMuslFromReport = ()=>{
    let report = null;
    if (typeof process.report?.getReport === 'function') {
        process.report.excludeNetwork = true;
        report = process.report.getReport();
    }
    if (!report) {
        return null;
    }
    if (report.header && report.header.glibcVersionRuntime) {
        return false;
    }
    if (Array.isArray(report.sharedObjects)) {
        if (report.sharedObjects.some(isFileMusl)) {
            return true;
        }
    }
    return false;
};
const isMuslFromChildProcess = ()=>{
    try {
        return __turbopack_context__.r("[externals]/child_process [external] (child_process, cjs)").execSync('ldd --version', {
            encoding: 'utf8'
        }).includes('musl');
    } catch (e) {
        // If we reach this case, we don't know if the system is musl or not, so is better to just fallback to false
        return false;
    }
};
function requireNative() {
    if (process.env.NAPI_RS_NATIVE_LIBRARY_PATH) {
        try {
            nativeBinding = (()=>{
                const e = new Error("Cannot find module as expression is too dynamic");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })();
        } catch (err) {
            loadErrors.push(err);
        }
    } else if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else if ("TURBOPACK compile-time truthy", 1) {
        try {
            return (()=>{
                const e = new Error("Cannot find module './tailwindcss-oxide.darwin-universal.node'");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })();
        } catch (e) {
            loadErrors.push(e);
        }
        try {
            return (()=>{
                const e = new Error("Cannot find module '@tailwindcss/oxide-darwin-universal'");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })();
        } catch (e) {
            loadErrors.push(e);
        }
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        else if ("TURBOPACK compile-time truthy", 1) {
            try {
                return (()=>{
                    const e = new Error("Cannot find module './tailwindcss-oxide.darwin-arm64.node'");
                    e.code = 'MODULE_NOT_FOUND';
                    throw e;
                })();
            } catch (e) {
                loadErrors.push(e);
            }
            try {
                return (()=>{
                    throw new Error('could not resolve "' + '@tailwindcss/oxide-darwin-arm64' + '" into a module');
                })();
            } catch (e) {
                loadErrors.push(e);
            }
        } else //TURBOPACK unreachable
        ;
    } else //TURBOPACK unreachable
    ;
}
nativeBinding = requireNative();
if (!nativeBinding || process.env.NAPI_RS_FORCE_WASI) {
    try {
        nativeBinding = (()=>{
            const e = new Error("Cannot find module './tailwindcss-oxide.wasi.cjs'");
            e.code = 'MODULE_NOT_FOUND';
            throw e;
        })();
    } catch (err) {
        if (process.env.NAPI_RS_FORCE_WASI) {
            loadErrors.push(err);
        }
    }
    if (!nativeBinding) {
        try {
            nativeBinding = (()=>{
                const e = new Error("Cannot find module '@tailwindcss/oxide-wasm32-wasi'");
                e.code = 'MODULE_NOT_FOUND';
                throw e;
            })();
        } catch (err) {
            if (process.env.NAPI_RS_FORCE_WASI) {
                loadErrors.push(err);
            }
        }
    }
}
if (!nativeBinding) {
    if (loadErrors.length > 0) {
        // TODO Link to documentation with potential fixes
        //  - The package owner could build/publish bindings for this arch
        //  - The user may need to bundle the correct files
        //  - The user may need to re-install node_modules to get new packages
        throw new Error('Failed to load native binding', {
            cause: loadErrors
        });
    }
    throw new Error(`Failed to load native binding`);
}
module.exports.Scanner = nativeBinding.Scanner;
}}),
"[project]/node_modules/@tailwindcss/postcss/dist/index.mjs [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>xl
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$alloc$2f$quick$2d$lru$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@alloc/quick-lru/index.js [postcss] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$node$2f$dist$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@tailwindcss/node/dist/index.mjs [postcss] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$node$2f$dist$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@tailwindcss/node/dist/index.mjs [postcss] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$4WXWQT6Y$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__b__as__Features$3e$__ = __turbopack_context__.i("[project]/node_modules/tailwindcss/dist/chunk-4WXWQT6Y.mjs [postcss] (ecmascript) <export b as Features>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$4WXWQT6Y$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__a__as__Polyfills$3e$__ = __turbopack_context__.i("[project]/node_modules/tailwindcss/dist/chunk-4WXWQT6Y.mjs [postcss] (ecmascript) <export a as Polyfills>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$node$2f$dist$2f$require$2d$cache$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tailwindcss/node/dist/require-cache.js [postcss] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$oxide$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tailwindcss/oxide/index.js [postcss] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs [external] (fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/path [external] (path, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/postcss/lib/postcss.mjs [postcss] (ecmascript)");
var ce = (e, r)=>(r = Symbol[e]) ? r : Symbol.for("Symbol." + e), fe = (e)=>{
    throw TypeError(e);
};
var pe = (e, r, t)=>{
    if (r != null) {
        typeof r != "object" && typeof r != "function" && fe("Object expected");
        var l, a;
        t && (l = r[ce("asyncDispose")]), l === void 0 && (l = r[ce("dispose")], t && (a = l)), typeof l != "function" && fe("Object not disposable"), a && (l = function() {
            try {
                a.call(this);
            } catch (i) {
                return Promise.reject(i);
            }
        }), e.push([
            t,
            l,
            r
        ]);
    } else t && e.push([
        t
    ]);
    return r;
}, de = (e, r, t)=>{
    var l = typeof SuppressedError == "function" ? SuppressedError : function(o, s, n, u) {
        return u = Error(n), u.name = "SuppressedError", u.error = o, u.suppressed = s, u;
    }, a = (o)=>r = t ? new l(o, r, "An error was suppressed during disposal") : (t = !0, o), i = (o)=>{
        for(; o = e.pop();)try {
            var s = o[1] && o[1].call(o[2]);
            if (o[0]) return Promise.resolve(s).then(i, (n)=>(a(n), i()));
        } catch (n) {
            a(n);
        }
        if (t) throw r;
    };
    return i();
};
;
;
;
;
;
;
;
function Y(e) {
    return {
        kind: "word",
        value: e
    };
}
function Ie(e, r) {
    return {
        kind: "function",
        value: e,
        nodes: r
    };
}
function Fe(e) {
    return {
        kind: "separator",
        value: e
    };
}
function N(e, r, t = null) {
    for(let l = 0; l < e.length; l++){
        let a = e[l], i = !1, o = 0, s = r(a, {
            parent: t,
            replaceWith (n) {
                i || (i = !0, Array.isArray(n) ? n.length === 0 ? (e.splice(l, 1), o = 0) : n.length === 1 ? (e[l] = n[0], o = 1) : (e.splice(l, 1, ...n), o = n.length) : e[l] = n);
            }
        }) ?? 0;
        if (i) {
            s === 0 ? l-- : l += o - 1;
            continue;
        }
        if (s === 2) return 2;
        if (s !== 1 && a.kind === "function" && N(a.nodes, r, a) === 2) return 2;
    }
}
function C(e) {
    let r = "";
    for (let t of e)switch(t.kind){
        case "word":
        case "separator":
            {
                r += t.value;
                break;
            }
        case "function":
            r += t.value + "(" + C(t.nodes) + ")";
    }
    return r;
}
var me = 92, je = 41, ge = 58, he = 44, Me = 34, ve = 61, we = 62, ke = 60, ye = 10, We = 40, Be = 39, be = 47, xe = 32, Ae = 9;
function b(e) {
    e = e.replaceAll(`\r
`, `
`);
    let r = [], t = [], l = null, a = "", i;
    for(let o = 0; o < e.length; o++){
        let s = e.charCodeAt(o);
        switch(s){
            case me:
                {
                    a += e[o] + e[o + 1], o++;
                    break;
                }
            case ge:
            case he:
            case ve:
            case we:
            case ke:
            case ye:
            case be:
            case xe:
            case Ae:
                {
                    if (a.length > 0) {
                        let p = Y(a);
                        l ? l.nodes.push(p) : r.push(p), a = "";
                    }
                    let n = o, u = o + 1;
                    for(; u < e.length && (i = e.charCodeAt(u), !(i !== ge && i !== he && i !== ve && i !== we && i !== ke && i !== ye && i !== be && i !== xe && i !== Ae)); u++);
                    o = u - 1;
                    let c = Fe(e.slice(n, u));
                    l ? l.nodes.push(c) : r.push(c);
                    break;
                }
            case Be:
            case Me:
                {
                    let n = o;
                    for(let u = o + 1; u < e.length; u++)if (i = e.charCodeAt(u), i === me) u += 1;
                    else if (i === s) {
                        o = u;
                        break;
                    }
                    a += e.slice(n, o + 1);
                    break;
                }
            case We:
                {
                    let n = Ie(a, []);
                    a = "", l ? l.nodes.push(n) : r.push(n), t.push(n), l = n;
                    break;
                }
            case je:
                {
                    let n = t.pop();
                    if (a.length > 0) {
                        let u = Y(a);
                        n?.nodes.push(u), a = "";
                    }
                    t.length > 0 ? l = t[t.length - 1] : l = null;
                    break;
                }
            default:
                a += String.fromCharCode(s);
        }
    }
    return a.length > 0 && r.push(Y(a)), r;
}
var m = class extends Map {
    constructor(t){
        super();
        this.factory = t;
    }
    get(t) {
        let l = super.get(t);
        return l === void 0 && (l = this.factory(t, this), this.set(t, l)), l;
    }
};
var It = new Uint8Array(256);
var M = new Uint8Array(256);
function v(e, r) {
    let t = 0, l = [], a = 0, i = e.length, o = r.charCodeAt(0);
    for(let s = 0; s < i; s++){
        let n = e.charCodeAt(s);
        if (t === 0 && n === o) {
            l.push(e.slice(a, s)), a = s + 1;
            continue;
        }
        switch(n){
            case 92:
                s += 1;
                break;
            case 39:
            case 34:
                for(; ++s < i;){
                    let u = e.charCodeAt(s);
                    if (u === 92) {
                        s += 1;
                        continue;
                    }
                    if (u === n) break;
                }
                break;
            case 40:
                M[t] = 41, t++;
                break;
            case 91:
                M[t] = 93, t++;
                break;
            case 123:
                M[t] = 125, t++;
                break;
            case 93:
            case 125:
            case 41:
                t > 0 && n === M[t - 1] && t--;
                break;
        }
    }
    return l.push(e.slice(a)), l;
}
var Yt = new m((e)=>{
    let r = b(e), t = new Set;
    return N(r, (l, { parent: a })=>{
        let i = a === null ? r : a.nodes ?? [];
        if (l.kind === "word" && (l.value === "+" || l.value === "-" || l.value === "*" || l.value === "/")) {
            let o = i.indexOf(l) ?? -1;
            if (o === -1) return;
            let s = i[o - 1];
            if (s?.kind !== "separator" || s.value !== " ") return;
            let n = i[o + 1];
            if (n?.kind !== "separator" || n.value !== " ") return;
            t.add(s), t.add(n);
        } else l.kind === "separator" && l.value.trim() === "/" ? l.value = "/" : l.kind === "separator" && l.value.length > 0 && l.value.trim() === "" ? (i[0] === l || i[i.length - 1] === l) && t.add(l) : l.kind === "separator" && l.value.trim() === "," && (l.value = ",");
    }), t.size > 0 && N(r, (l, { replaceWith: a })=>{
        t.has(l) && (t.delete(l), a([]));
    }), Z(r), C(r);
});
var Zt = new m((e)=>{
    let r = b(e);
    return r.length === 3 && r[0].kind === "word" && r[0].value === "&" && r[1].kind === "separator" && r[1].value === ":" && r[2].kind === "function" && r[2].value === "is" ? C(r[2].nodes) : e;
});
function Z(e) {
    for (let r of e)switch(r.kind){
        case "function":
            {
                if (r.value === "url" || r.value.endsWith("_url")) {
                    r.value = K(r.value);
                    break;
                }
                if (r.value === "var" || r.value.endsWith("_var") || r.value === "theme" || r.value.endsWith("_theme")) {
                    r.value = K(r.value);
                    for(let t = 0; t < r.nodes.length; t++)Z([
                        r.nodes[t]
                    ]);
                    break;
                }
                r.value = K(r.value), Z(r.nodes);
                break;
            }
        case "separator":
            r.value = K(r.value);
            break;
        case "word":
            {
                (r.value[0] !== "-" || r.value[1] !== "-") && (r.value = K(r.value));
                break;
            }
        default:
            He(r);
    }
}
var Jt = new m((e)=>{
    let r = b(e);
    return r.length === 1 && r[0].kind === "function" && r[0].value === "var";
});
function He(e) {
    throw new Error(`Unexpected value: ${e}`);
}
function K(e) {
    return e.replaceAll("_", String.raw`\_`).replaceAll(" ", "_");
}
var $ = /[+-]?\d*\.?\d+(?:[eE][+-]?\d+)?/, lr = new RegExp(`^${$.source}$`);
var ar = new RegExp(`^${$.source}%$`);
var sr = new RegExp(`^${$.source}s*/s*${$.source}$`);
var Ge = [
    "cm",
    "mm",
    "Q",
    "in",
    "pc",
    "pt",
    "px",
    "em",
    "ex",
    "ch",
    "rem",
    "lh",
    "rlh",
    "vw",
    "vh",
    "vmin",
    "vmax",
    "vb",
    "vi",
    "svw",
    "svh",
    "lvw",
    "lvh",
    "dvw",
    "dvh",
    "cqw",
    "cqh",
    "cqi",
    "cqb",
    "cqmin",
    "cqmax"
], ur = new RegExp(`^${$.source}(${Ge.join("|")})$`);
var qe = [
    "deg",
    "rad",
    "grad",
    "turn"
], cr = new RegExp(`^${$.source}(${qe.join("|")})$`);
var fr = new RegExp(`^${$.source} +${$.source} +${$.source}$`);
function k(e) {
    let r = Number(e);
    return Number.isInteger(r) && r >= 0 && String(r) === String(e);
}
function L(e, r) {
    if (r === null) return e;
    let t = Number(r);
    return Number.isNaN(t) || (r = `${t * 100}%`), r === "100%" ? e : `color-mix(in oklab, ${e} ${r}, transparent)`;
}
var Je = {
    "--alpha": Qe,
    "--spacing": Xe,
    "--theme": et,
    theme: tt
};
function Qe(e, r, t, ...l) {
    let [a, i] = v(t, "/").map((o)=>o.trim());
    if (!a || !i) throw new Error(`The --alpha(\u2026) function requires a color and an alpha value, e.g.: \`--alpha(${a || "var(--my-color)"} / ${i || "50%"})\``);
    if (l.length > 0) throw new Error(`The --alpha(\u2026) function only accepts one argument, e.g.: \`--alpha(${a || "var(--my-color)"} / ${i || "50%"})\``);
    return L(a, i);
}
function Xe(e, r, t, ...l) {
    if (!t) throw new Error("The --spacing(\u2026) function requires an argument, but received none.");
    if (l.length > 0) throw new Error(`The --spacing(\u2026) function only accepts a single argument, but received ${l.length + 1}.`);
    let a = e.theme.resolve(null, [
        "--spacing"
    ]);
    if (!a) throw new Error("The --spacing(\u2026) function requires that the `--spacing` theme variable exists, but it was not found.");
    return `calc(${a} * ${t})`;
}
function et(e, r, t, ...l) {
    if (!t.startsWith("--")) throw new Error("The --theme(\u2026) function can only be used with CSS variables from your theme.");
    let a = !1;
    t.endsWith(" inline") && (a = !0, t = t.slice(0, -7)), r.kind === "at-rule" && (a = !0);
    let i = e.resolveThemeValue(t, a);
    if (!i) {
        if (l.length > 0) return l.join(", ");
        throw new Error(`Could not resolve value for theme function: \`theme(${t})\`. Consider checking if the variable name is correct or provide a fallback value to silence this error.`);
    }
    if (l.length === 0) return i;
    let o = l.join(", ");
    if (o === "initial") return i;
    if (i === "initial") return o;
    if (i.startsWith("var(") || i.startsWith("theme(") || i.startsWith("--theme(")) {
        let s = b(i);
        return it(s, o), C(s);
    }
    return i;
}
function tt(e, r, t, ...l) {
    t = rt(t);
    let a = e.resolveThemeValue(t);
    if (!a && l.length > 0) return l.join(", ");
    if (!a) throw new Error(`Could not resolve value for theme function: \`theme(${t})\`. Consider checking if the path is correct or provide a fallback value to silence this error.`);
    return a;
}
var Er = new RegExp(Object.keys(Je).map((e)=>`${e}\\(`).join("|"));
function rt(e) {
    if (e[0] !== "'" && e[0] !== '"') return e;
    let r = "", t = e[0];
    for(let l = 1; l < e.length - 1; l++){
        let a = e[l], i = e[l + 1];
        a === "\\" && (i === t || i === "\\") ? (r += i, l++) : r += a;
    }
    return r;
}
function it(e, r) {
    N(e, (t)=>{
        if (t.kind === "function" && !(t.value !== "var" && t.value !== "theme" && t.value !== "--theme")) if (t.nodes.length === 1) t.nodes.push({
            kind: "word",
            value: `, ${r}`
        });
        else {
            let l = t.nodes[t.nodes.length - 1];
            l.kind === "word" && l.value === "initial" && (l.value = r);
        }
    });
}
var ut = 32;
var ct = 40;
function Ve(e, r = []) {
    let t = e, l = "";
    for(let a = 5; a < e.length; a++){
        let i = e.charCodeAt(a);
        if (i === ut || i === ct) {
            t = e.slice(0, a), l = e.slice(a);
            break;
        }
    }
    return w(t.trim(), l.trim(), r);
}
var te = {
    inherit: "inherit",
    current: "currentcolor",
    transparent: "transparent",
    black: "#000",
    white: "#fff",
    slate: {
        50: "oklch(98.4% 0.003 247.858)",
        100: "oklch(96.8% 0.007 247.896)",
        200: "oklch(92.9% 0.013 255.508)",
        300: "oklch(86.9% 0.022 252.894)",
        400: "oklch(70.4% 0.04 256.788)",
        500: "oklch(55.4% 0.046 257.417)",
        600: "oklch(44.6% 0.043 257.281)",
        700: "oklch(37.2% 0.044 257.287)",
        800: "oklch(27.9% 0.041 260.031)",
        900: "oklch(20.8% 0.042 265.755)",
        950: "oklch(12.9% 0.042 264.695)"
    },
    gray: {
        50: "oklch(98.5% 0.002 247.839)",
        100: "oklch(96.7% 0.003 264.542)",
        200: "oklch(92.8% 0.006 264.531)",
        300: "oklch(87.2% 0.01 258.338)",
        400: "oklch(70.7% 0.022 261.325)",
        500: "oklch(55.1% 0.027 264.364)",
        600: "oklch(44.6% 0.03 256.802)",
        700: "oklch(37.3% 0.034 259.733)",
        800: "oklch(27.8% 0.033 256.848)",
        900: "oklch(21% 0.034 264.665)",
        950: "oklch(13% 0.028 261.692)"
    },
    zinc: {
        50: "oklch(98.5% 0 0)",
        100: "oklch(96.7% 0.001 286.375)",
        200: "oklch(92% 0.004 286.32)",
        300: "oklch(87.1% 0.006 286.286)",
        400: "oklch(70.5% 0.015 286.067)",
        500: "oklch(55.2% 0.016 285.938)",
        600: "oklch(44.2% 0.017 285.786)",
        700: "oklch(37% 0.013 285.805)",
        800: "oklch(27.4% 0.006 286.033)",
        900: "oklch(21% 0.006 285.885)",
        950: "oklch(14.1% 0.005 285.823)"
    },
    neutral: {
        50: "oklch(98.5% 0 0)",
        100: "oklch(97% 0 0)",
        200: "oklch(92.2% 0 0)",
        300: "oklch(87% 0 0)",
        400: "oklch(70.8% 0 0)",
        500: "oklch(55.6% 0 0)",
        600: "oklch(43.9% 0 0)",
        700: "oklch(37.1% 0 0)",
        800: "oklch(26.9% 0 0)",
        900: "oklch(20.5% 0 0)",
        950: "oklch(14.5% 0 0)"
    },
    stone: {
        50: "oklch(98.5% 0.001 106.423)",
        100: "oklch(97% 0.001 106.424)",
        200: "oklch(92.3% 0.003 48.717)",
        300: "oklch(86.9% 0.005 56.366)",
        400: "oklch(70.9% 0.01 56.259)",
        500: "oklch(55.3% 0.013 58.071)",
        600: "oklch(44.4% 0.011 73.639)",
        700: "oklch(37.4% 0.01 67.558)",
        800: "oklch(26.8% 0.007 34.298)",
        900: "oklch(21.6% 0.006 56.043)",
        950: "oklch(14.7% 0.004 49.25)"
    },
    red: {
        50: "oklch(97.1% 0.013 17.38)",
        100: "oklch(93.6% 0.032 17.717)",
        200: "oklch(88.5% 0.062 18.334)",
        300: "oklch(80.8% 0.114 19.571)",
        400: "oklch(70.4% 0.191 22.216)",
        500: "oklch(63.7% 0.237 25.331)",
        600: "oklch(57.7% 0.245 27.325)",
        700: "oklch(50.5% 0.213 27.518)",
        800: "oklch(44.4% 0.177 26.899)",
        900: "oklch(39.6% 0.141 25.723)",
        950: "oklch(25.8% 0.092 26.042)"
    },
    orange: {
        50: "oklch(98% 0.016 73.684)",
        100: "oklch(95.4% 0.038 75.164)",
        200: "oklch(90.1% 0.076 70.697)",
        300: "oklch(83.7% 0.128 66.29)",
        400: "oklch(75% 0.183 55.934)",
        500: "oklch(70.5% 0.213 47.604)",
        600: "oklch(64.6% 0.222 41.116)",
        700: "oklch(55.3% 0.195 38.402)",
        800: "oklch(47% 0.157 37.304)",
        900: "oklch(40.8% 0.123 38.172)",
        950: "oklch(26.6% 0.079 36.259)"
    },
    amber: {
        50: "oklch(98.7% 0.022 95.277)",
        100: "oklch(96.2% 0.059 95.617)",
        200: "oklch(92.4% 0.12 95.746)",
        300: "oklch(87.9% 0.169 91.605)",
        400: "oklch(82.8% 0.189 84.429)",
        500: "oklch(76.9% 0.188 70.08)",
        600: "oklch(66.6% 0.179 58.318)",
        700: "oklch(55.5% 0.163 48.998)",
        800: "oklch(47.3% 0.137 46.201)",
        900: "oklch(41.4% 0.112 45.904)",
        950: "oklch(27.9% 0.077 45.635)"
    },
    yellow: {
        50: "oklch(98.7% 0.026 102.212)",
        100: "oklch(97.3% 0.071 103.193)",
        200: "oklch(94.5% 0.129 101.54)",
        300: "oklch(90.5% 0.182 98.111)",
        400: "oklch(85.2% 0.199 91.936)",
        500: "oklch(79.5% 0.184 86.047)",
        600: "oklch(68.1% 0.162 75.834)",
        700: "oklch(55.4% 0.135 66.442)",
        800: "oklch(47.6% 0.114 61.907)",
        900: "oklch(42.1% 0.095 57.708)",
        950: "oklch(28.6% 0.066 53.813)"
    },
    lime: {
        50: "oklch(98.6% 0.031 120.757)",
        100: "oklch(96.7% 0.067 122.328)",
        200: "oklch(93.8% 0.127 124.321)",
        300: "oklch(89.7% 0.196 126.665)",
        400: "oklch(84.1% 0.238 128.85)",
        500: "oklch(76.8% 0.233 130.85)",
        600: "oklch(64.8% 0.2 131.684)",
        700: "oklch(53.2% 0.157 131.589)",
        800: "oklch(45.3% 0.124 130.933)",
        900: "oklch(40.5% 0.101 131.063)",
        950: "oklch(27.4% 0.072 132.109)"
    },
    green: {
        50: "oklch(98.2% 0.018 155.826)",
        100: "oklch(96.2% 0.044 156.743)",
        200: "oklch(92.5% 0.084 155.995)",
        300: "oklch(87.1% 0.15 154.449)",
        400: "oklch(79.2% 0.209 151.711)",
        500: "oklch(72.3% 0.219 149.579)",
        600: "oklch(62.7% 0.194 149.214)",
        700: "oklch(52.7% 0.154 150.069)",
        800: "oklch(44.8% 0.119 151.328)",
        900: "oklch(39.3% 0.095 152.535)",
        950: "oklch(26.6% 0.065 152.934)"
    },
    emerald: {
        50: "oklch(97.9% 0.021 166.113)",
        100: "oklch(95% 0.052 163.051)",
        200: "oklch(90.5% 0.093 164.15)",
        300: "oklch(84.5% 0.143 164.978)",
        400: "oklch(76.5% 0.177 163.223)",
        500: "oklch(69.6% 0.17 162.48)",
        600: "oklch(59.6% 0.145 163.225)",
        700: "oklch(50.8% 0.118 165.612)",
        800: "oklch(43.2% 0.095 166.913)",
        900: "oklch(37.8% 0.077 168.94)",
        950: "oklch(26.2% 0.051 172.552)"
    },
    teal: {
        50: "oklch(98.4% 0.014 180.72)",
        100: "oklch(95.3% 0.051 180.801)",
        200: "oklch(91% 0.096 180.426)",
        300: "oklch(85.5% 0.138 181.071)",
        400: "oklch(77.7% 0.152 181.912)",
        500: "oklch(70.4% 0.14 182.503)",
        600: "oklch(60% 0.118 184.704)",
        700: "oklch(51.1% 0.096 186.391)",
        800: "oklch(43.7% 0.078 188.216)",
        900: "oklch(38.6% 0.063 188.416)",
        950: "oklch(27.7% 0.046 192.524)"
    },
    cyan: {
        50: "oklch(98.4% 0.019 200.873)",
        100: "oklch(95.6% 0.045 203.388)",
        200: "oklch(91.7% 0.08 205.041)",
        300: "oklch(86.5% 0.127 207.078)",
        400: "oklch(78.9% 0.154 211.53)",
        500: "oklch(71.5% 0.143 215.221)",
        600: "oklch(60.9% 0.126 221.723)",
        700: "oklch(52% 0.105 223.128)",
        800: "oklch(45% 0.085 224.283)",
        900: "oklch(39.8% 0.07 227.392)",
        950: "oklch(30.2% 0.056 229.695)"
    },
    sky: {
        50: "oklch(97.7% 0.013 236.62)",
        100: "oklch(95.1% 0.026 236.824)",
        200: "oklch(90.1% 0.058 230.902)",
        300: "oklch(82.8% 0.111 230.318)",
        400: "oklch(74.6% 0.16 232.661)",
        500: "oklch(68.5% 0.169 237.323)",
        600: "oklch(58.8% 0.158 241.966)",
        700: "oklch(50% 0.134 242.749)",
        800: "oklch(44.3% 0.11 240.79)",
        900: "oklch(39.1% 0.09 240.876)",
        950: "oklch(29.3% 0.066 243.157)"
    },
    blue: {
        50: "oklch(97% 0.014 254.604)",
        100: "oklch(93.2% 0.032 255.585)",
        200: "oklch(88.2% 0.059 254.128)",
        300: "oklch(80.9% 0.105 251.813)",
        400: "oklch(70.7% 0.165 254.624)",
        500: "oklch(62.3% 0.214 259.815)",
        600: "oklch(54.6% 0.245 262.881)",
        700: "oklch(48.8% 0.243 264.376)",
        800: "oklch(42.4% 0.199 265.638)",
        900: "oklch(37.9% 0.146 265.522)",
        950: "oklch(28.2% 0.091 267.935)"
    },
    indigo: {
        50: "oklch(96.2% 0.018 272.314)",
        100: "oklch(93% 0.034 272.788)",
        200: "oklch(87% 0.065 274.039)",
        300: "oklch(78.5% 0.115 274.713)",
        400: "oklch(67.3% 0.182 276.935)",
        500: "oklch(58.5% 0.233 277.117)",
        600: "oklch(51.1% 0.262 276.966)",
        700: "oklch(45.7% 0.24 277.023)",
        800: "oklch(39.8% 0.195 277.366)",
        900: "oklch(35.9% 0.144 278.697)",
        950: "oklch(25.7% 0.09 281.288)"
    },
    violet: {
        50: "oklch(96.9% 0.016 293.756)",
        100: "oklch(94.3% 0.029 294.588)",
        200: "oklch(89.4% 0.057 293.283)",
        300: "oklch(81.1% 0.111 293.571)",
        400: "oklch(70.2% 0.183 293.541)",
        500: "oklch(60.6% 0.25 292.717)",
        600: "oklch(54.1% 0.281 293.009)",
        700: "oklch(49.1% 0.27 292.581)",
        800: "oklch(43.2% 0.232 292.759)",
        900: "oklch(38% 0.189 293.745)",
        950: "oklch(28.3% 0.141 291.089)"
    },
    purple: {
        50: "oklch(97.7% 0.014 308.299)",
        100: "oklch(94.6% 0.033 307.174)",
        200: "oklch(90.2% 0.063 306.703)",
        300: "oklch(82.7% 0.119 306.383)",
        400: "oklch(71.4% 0.203 305.504)",
        500: "oklch(62.7% 0.265 303.9)",
        600: "oklch(55.8% 0.288 302.321)",
        700: "oklch(49.6% 0.265 301.924)",
        800: "oklch(43.8% 0.218 303.724)",
        900: "oklch(38.1% 0.176 304.987)",
        950: "oklch(29.1% 0.149 302.717)"
    },
    fuchsia: {
        50: "oklch(97.7% 0.017 320.058)",
        100: "oklch(95.2% 0.037 318.852)",
        200: "oklch(90.3% 0.076 319.62)",
        300: "oklch(83.3% 0.145 321.434)",
        400: "oklch(74% 0.238 322.16)",
        500: "oklch(66.7% 0.295 322.15)",
        600: "oklch(59.1% 0.293 322.896)",
        700: "oklch(51.8% 0.253 323.949)",
        800: "oklch(45.2% 0.211 324.591)",
        900: "oklch(40.1% 0.17 325.612)",
        950: "oklch(29.3% 0.136 325.661)"
    },
    pink: {
        50: "oklch(97.1% 0.014 343.198)",
        100: "oklch(94.8% 0.028 342.258)",
        200: "oklch(89.9% 0.061 343.231)",
        300: "oklch(82.3% 0.12 346.018)",
        400: "oklch(71.8% 0.202 349.761)",
        500: "oklch(65.6% 0.241 354.308)",
        600: "oklch(59.2% 0.249 0.584)",
        700: "oklch(52.5% 0.223 3.958)",
        800: "oklch(45.9% 0.187 3.815)",
        900: "oklch(40.8% 0.153 2.432)",
        950: "oklch(28.4% 0.109 3.907)"
    },
    rose: {
        50: "oklch(96.9% 0.015 12.422)",
        100: "oklch(94.1% 0.03 12.58)",
        200: "oklch(89.2% 0.058 10.001)",
        300: "oklch(81% 0.117 11.638)",
        400: "oklch(71.2% 0.194 13.428)",
        500: "oklch(64.5% 0.246 16.439)",
        600: "oklch(58.6% 0.253 17.585)",
        700: "oklch(51.4% 0.222 16.935)",
        800: "oklch(45.5% 0.188 13.697)",
        900: "oklch(41% 0.159 10.272)",
        950: "oklch(27.1% 0.105 12.094)"
    }
};
function _(e) {
    return {
        __BARE_VALUE__: e
    };
}
var x = _((e)=>{
    if (k(e.value)) return e.value;
}), h = _((e)=>{
    if (k(e.value)) return `${e.value}%`;
}), P = _((e)=>{
    if (k(e.value)) return `${e.value}px`;
}), Pe = _((e)=>{
    if (k(e.value)) return `${e.value}ms`;
}), H = _((e)=>{
    if (k(e.value)) return `${e.value}deg`;
}), wt = _((e)=>{
    if (e.fraction === null) return;
    let [r, t] = v(e.fraction, "/");
    if (!(!k(r) || !k(t))) return e.fraction;
}), Re = _((e)=>{
    if (k(Number(e.value))) return `repeat(${e.value}, minmax(0, 1fr))`;
}), kt = {
    accentColor: ({ theme: e })=>e("colors"),
    animation: {
        none: "none",
        spin: "spin 1s linear infinite",
        ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite",
        pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
        bounce: "bounce 1s infinite"
    },
    aria: {
        busy: 'busy="true"',
        checked: 'checked="true"',
        disabled: 'disabled="true"',
        expanded: 'expanded="true"',
        hidden: 'hidden="true"',
        pressed: 'pressed="true"',
        readonly: 'readonly="true"',
        required: 'required="true"',
        selected: 'selected="true"'
    },
    aspectRatio: {
        auto: "auto",
        square: "1 / 1",
        video: "16 / 9",
        ...wt
    },
    backdropBlur: ({ theme: e })=>e("blur"),
    backdropBrightness: ({ theme: e })=>({
            ...e("brightness"),
            ...h
        }),
    backdropContrast: ({ theme: e })=>({
            ...e("contrast"),
            ...h
        }),
    backdropGrayscale: ({ theme: e })=>({
            ...e("grayscale"),
            ...h
        }),
    backdropHueRotate: ({ theme: e })=>({
            ...e("hueRotate"),
            ...H
        }),
    backdropInvert: ({ theme: e })=>({
            ...e("invert"),
            ...h
        }),
    backdropOpacity: ({ theme: e })=>({
            ...e("opacity"),
            ...h
        }),
    backdropSaturate: ({ theme: e })=>({
            ...e("saturate"),
            ...h
        }),
    backdropSepia: ({ theme: e })=>({
            ...e("sepia"),
            ...h
        }),
    backgroundColor: ({ theme: e })=>e("colors"),
    backgroundImage: {
        none: "none",
        "gradient-to-t": "linear-gradient(to top, var(--tw-gradient-stops))",
        "gradient-to-tr": "linear-gradient(to top right, var(--tw-gradient-stops))",
        "gradient-to-r": "linear-gradient(to right, var(--tw-gradient-stops))",
        "gradient-to-br": "linear-gradient(to bottom right, var(--tw-gradient-stops))",
        "gradient-to-b": "linear-gradient(to bottom, var(--tw-gradient-stops))",
        "gradient-to-bl": "linear-gradient(to bottom left, var(--tw-gradient-stops))",
        "gradient-to-l": "linear-gradient(to left, var(--tw-gradient-stops))",
        "gradient-to-tl": "linear-gradient(to top left, var(--tw-gradient-stops))"
    },
    backgroundOpacity: ({ theme: e })=>e("opacity"),
    backgroundPosition: {
        bottom: "bottom",
        center: "center",
        left: "left",
        "left-bottom": "left bottom",
        "left-top": "left top",
        right: "right",
        "right-bottom": "right bottom",
        "right-top": "right top",
        top: "top"
    },
    backgroundSize: {
        auto: "auto",
        cover: "cover",
        contain: "contain"
    },
    blur: {
        0: "0",
        none: "",
        sm: "4px",
        DEFAULT: "8px",
        md: "12px",
        lg: "16px",
        xl: "24px",
        "2xl": "40px",
        "3xl": "64px"
    },
    borderColor: ({ theme: e })=>({
            DEFAULT: "currentcolor",
            ...e("colors")
        }),
    borderOpacity: ({ theme: e })=>e("opacity"),
    borderRadius: {
        none: "0px",
        sm: "0.125rem",
        DEFAULT: "0.25rem",
        md: "0.375rem",
        lg: "0.5rem",
        xl: "0.75rem",
        "2xl": "1rem",
        "3xl": "1.5rem",
        full: "9999px"
    },
    borderSpacing: ({ theme: e })=>e("spacing"),
    borderWidth: {
        DEFAULT: "1px",
        0: "0px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...P
    },
    boxShadow: {
        sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)",
        DEFAULT: "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)",
        md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
        lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
        xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)",
        "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)",
        inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)",
        none: "none"
    },
    boxShadowColor: ({ theme: e })=>e("colors"),
    brightness: {
        0: "0",
        50: ".5",
        75: ".75",
        90: ".9",
        95: ".95",
        100: "1",
        105: "1.05",
        110: "1.1",
        125: "1.25",
        150: "1.5",
        200: "2",
        ...h
    },
    caretColor: ({ theme: e })=>e("colors"),
    colors: ()=>({
            ...te
        }),
    columns: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        "3xs": "16rem",
        "2xs": "18rem",
        xs: "20rem",
        sm: "24rem",
        md: "28rem",
        lg: "32rem",
        xl: "36rem",
        "2xl": "42rem",
        "3xl": "48rem",
        "4xl": "56rem",
        "5xl": "64rem",
        "6xl": "72rem",
        "7xl": "80rem",
        ...x
    },
    container: {},
    content: {
        none: "none"
    },
    contrast: {
        0: "0",
        50: ".5",
        75: ".75",
        100: "1",
        125: "1.25",
        150: "1.5",
        200: "2",
        ...h
    },
    cursor: {
        auto: "auto",
        default: "default",
        pointer: "pointer",
        wait: "wait",
        text: "text",
        move: "move",
        help: "help",
        "not-allowed": "not-allowed",
        none: "none",
        "context-menu": "context-menu",
        progress: "progress",
        cell: "cell",
        crosshair: "crosshair",
        "vertical-text": "vertical-text",
        alias: "alias",
        copy: "copy",
        "no-drop": "no-drop",
        grab: "grab",
        grabbing: "grabbing",
        "all-scroll": "all-scroll",
        "col-resize": "col-resize",
        "row-resize": "row-resize",
        "n-resize": "n-resize",
        "e-resize": "e-resize",
        "s-resize": "s-resize",
        "w-resize": "w-resize",
        "ne-resize": "ne-resize",
        "nw-resize": "nw-resize",
        "se-resize": "se-resize",
        "sw-resize": "sw-resize",
        "ew-resize": "ew-resize",
        "ns-resize": "ns-resize",
        "nesw-resize": "nesw-resize",
        "nwse-resize": "nwse-resize",
        "zoom-in": "zoom-in",
        "zoom-out": "zoom-out"
    },
    divideColor: ({ theme: e })=>e("borderColor"),
    divideOpacity: ({ theme: e })=>e("borderOpacity"),
    divideWidth: ({ theme: e })=>({
            ...e("borderWidth"),
            ...P
        }),
    dropShadow: {
        sm: "0 1px 1px rgb(0 0 0 / 0.05)",
        DEFAULT: [
            "0 1px 2px rgb(0 0 0 / 0.1)",
            "0 1px 1px rgb(0 0 0 / 0.06)"
        ],
        md: [
            "0 4px 3px rgb(0 0 0 / 0.07)",
            "0 2px 2px rgb(0 0 0 / 0.06)"
        ],
        lg: [
            "0 10px 8px rgb(0 0 0 / 0.04)",
            "0 4px 3px rgb(0 0 0 / 0.1)"
        ],
        xl: [
            "0 20px 13px rgb(0 0 0 / 0.03)",
            "0 8px 5px rgb(0 0 0 / 0.08)"
        ],
        "2xl": "0 25px 25px rgb(0 0 0 / 0.15)",
        none: "0 0 #0000"
    },
    fill: ({ theme: e })=>e("colors"),
    flex: {
        1: "1 1 0%",
        auto: "1 1 auto",
        initial: "0 1 auto",
        none: "none"
    },
    flexBasis: ({ theme: e })=>({
            auto: "auto",
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            "1/12": "8.333333%",
            "2/12": "16.666667%",
            "3/12": "25%",
            "4/12": "33.333333%",
            "5/12": "41.666667%",
            "6/12": "50%",
            "7/12": "58.333333%",
            "8/12": "66.666667%",
            "9/12": "75%",
            "10/12": "83.333333%",
            "11/12": "91.666667%",
            full: "100%",
            ...e("spacing")
        }),
    flexGrow: {
        0: "0",
        DEFAULT: "1",
        ...x
    },
    flexShrink: {
        0: "0",
        DEFAULT: "1",
        ...x
    },
    fontFamily: {
        sans: [
            "ui-sans-serif",
            "system-ui",
            "sans-serif",
            '"Apple Color Emoji"',
            '"Segoe UI Emoji"',
            '"Segoe UI Symbol"',
            '"Noto Color Emoji"'
        ],
        serif: [
            "ui-serif",
            "Georgia",
            "Cambria",
            '"Times New Roman"',
            "Times",
            "serif"
        ],
        mono: [
            "ui-monospace",
            "SFMono-Regular",
            "Menlo",
            "Monaco",
            "Consolas",
            '"Liberation Mono"',
            '"Courier New"',
            "monospace"
        ]
    },
    fontSize: {
        xs: [
            "0.75rem",
            {
                lineHeight: "1rem"
            }
        ],
        sm: [
            "0.875rem",
            {
                lineHeight: "1.25rem"
            }
        ],
        base: [
            "1rem",
            {
                lineHeight: "1.5rem"
            }
        ],
        lg: [
            "1.125rem",
            {
                lineHeight: "1.75rem"
            }
        ],
        xl: [
            "1.25rem",
            {
                lineHeight: "1.75rem"
            }
        ],
        "2xl": [
            "1.5rem",
            {
                lineHeight: "2rem"
            }
        ],
        "3xl": [
            "1.875rem",
            {
                lineHeight: "2.25rem"
            }
        ],
        "4xl": [
            "2.25rem",
            {
                lineHeight: "2.5rem"
            }
        ],
        "5xl": [
            "3rem",
            {
                lineHeight: "1"
            }
        ],
        "6xl": [
            "3.75rem",
            {
                lineHeight: "1"
            }
        ],
        "7xl": [
            "4.5rem",
            {
                lineHeight: "1"
            }
        ],
        "8xl": [
            "6rem",
            {
                lineHeight: "1"
            }
        ],
        "9xl": [
            "8rem",
            {
                lineHeight: "1"
            }
        ]
    },
    fontWeight: {
        thin: "100",
        extralight: "200",
        light: "300",
        normal: "400",
        medium: "500",
        semibold: "600",
        bold: "700",
        extrabold: "800",
        black: "900"
    },
    gap: ({ theme: e })=>e("spacing"),
    gradientColorStops: ({ theme: e })=>e("colors"),
    gradientColorStopPositions: {
        "0%": "0%",
        "5%": "5%",
        "10%": "10%",
        "15%": "15%",
        "20%": "20%",
        "25%": "25%",
        "30%": "30%",
        "35%": "35%",
        "40%": "40%",
        "45%": "45%",
        "50%": "50%",
        "55%": "55%",
        "60%": "60%",
        "65%": "65%",
        "70%": "70%",
        "75%": "75%",
        "80%": "80%",
        "85%": "85%",
        "90%": "90%",
        "95%": "95%",
        "100%": "100%",
        ...h
    },
    grayscale: {
        0: "0",
        DEFAULT: "100%",
        ...h
    },
    gridAutoColumns: {
        auto: "auto",
        min: "min-content",
        max: "max-content",
        fr: "minmax(0, 1fr)"
    },
    gridAutoRows: {
        auto: "auto",
        min: "min-content",
        max: "max-content",
        fr: "minmax(0, 1fr)"
    },
    gridColumn: {
        auto: "auto",
        "span-1": "span 1 / span 1",
        "span-2": "span 2 / span 2",
        "span-3": "span 3 / span 3",
        "span-4": "span 4 / span 4",
        "span-5": "span 5 / span 5",
        "span-6": "span 6 / span 6",
        "span-7": "span 7 / span 7",
        "span-8": "span 8 / span 8",
        "span-9": "span 9 / span 9",
        "span-10": "span 10 / span 10",
        "span-11": "span 11 / span 11",
        "span-12": "span 12 / span 12",
        "span-full": "1 / -1"
    },
    gridColumnEnd: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13",
        ...x
    },
    gridColumnStart: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13",
        ...x
    },
    gridRow: {
        auto: "auto",
        "span-1": "span 1 / span 1",
        "span-2": "span 2 / span 2",
        "span-3": "span 3 / span 3",
        "span-4": "span 4 / span 4",
        "span-5": "span 5 / span 5",
        "span-6": "span 6 / span 6",
        "span-7": "span 7 / span 7",
        "span-8": "span 8 / span 8",
        "span-9": "span 9 / span 9",
        "span-10": "span 10 / span 10",
        "span-11": "span 11 / span 11",
        "span-12": "span 12 / span 12",
        "span-full": "1 / -1"
    },
    gridRowEnd: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13",
        ...x
    },
    gridRowStart: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13",
        ...x
    },
    gridTemplateColumns: {
        none: "none",
        subgrid: "subgrid",
        1: "repeat(1, minmax(0, 1fr))",
        2: "repeat(2, minmax(0, 1fr))",
        3: "repeat(3, minmax(0, 1fr))",
        4: "repeat(4, minmax(0, 1fr))",
        5: "repeat(5, minmax(0, 1fr))",
        6: "repeat(6, minmax(0, 1fr))",
        7: "repeat(7, minmax(0, 1fr))",
        8: "repeat(8, minmax(0, 1fr))",
        9: "repeat(9, minmax(0, 1fr))",
        10: "repeat(10, minmax(0, 1fr))",
        11: "repeat(11, minmax(0, 1fr))",
        12: "repeat(12, minmax(0, 1fr))",
        ...Re
    },
    gridTemplateRows: {
        none: "none",
        subgrid: "subgrid",
        1: "repeat(1, minmax(0, 1fr))",
        2: "repeat(2, minmax(0, 1fr))",
        3: "repeat(3, minmax(0, 1fr))",
        4: "repeat(4, minmax(0, 1fr))",
        5: "repeat(5, minmax(0, 1fr))",
        6: "repeat(6, minmax(0, 1fr))",
        7: "repeat(7, minmax(0, 1fr))",
        8: "repeat(8, minmax(0, 1fr))",
        9: "repeat(9, minmax(0, 1fr))",
        10: "repeat(10, minmax(0, 1fr))",
        11: "repeat(11, minmax(0, 1fr))",
        12: "repeat(12, minmax(0, 1fr))",
        ...Re
    },
    height: ({ theme: e })=>({
            auto: "auto",
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            full: "100%",
            screen: "100vh",
            svh: "100svh",
            lvh: "100lvh",
            dvh: "100dvh",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    hueRotate: {
        0: "0deg",
        15: "15deg",
        30: "30deg",
        60: "60deg",
        90: "90deg",
        180: "180deg",
        ...H
    },
    inset: ({ theme: e })=>({
            auto: "auto",
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            full: "100%",
            ...e("spacing")
        }),
    invert: {
        0: "0",
        DEFAULT: "100%",
        ...h
    },
    keyframes: {
        spin: {
            to: {
                transform: "rotate(360deg)"
            }
        },
        ping: {
            "75%, 100%": {
                transform: "scale(2)",
                opacity: "0"
            }
        },
        pulse: {
            "50%": {
                opacity: ".5"
            }
        },
        bounce: {
            "0%, 100%": {
                transform: "translateY(-25%)",
                animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
            },
            "50%": {
                transform: "none",
                animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
            }
        }
    },
    letterSpacing: {
        tighter: "-0.05em",
        tight: "-0.025em",
        normal: "0em",
        wide: "0.025em",
        wider: "0.05em",
        widest: "0.1em"
    },
    lineHeight: {
        none: "1",
        tight: "1.25",
        snug: "1.375",
        normal: "1.5",
        relaxed: "1.625",
        loose: "2",
        3: ".75rem",
        4: "1rem",
        5: "1.25rem",
        6: "1.5rem",
        7: "1.75rem",
        8: "2rem",
        9: "2.25rem",
        10: "2.5rem"
    },
    listStyleType: {
        none: "none",
        disc: "disc",
        decimal: "decimal"
    },
    listStyleImage: {
        none: "none"
    },
    margin: ({ theme: e })=>({
            auto: "auto",
            ...e("spacing")
        }),
    lineClamp: {
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        ...x
    },
    maxHeight: ({ theme: e })=>({
            none: "none",
            full: "100%",
            screen: "100vh",
            svh: "100svh",
            lvh: "100lvh",
            dvh: "100dvh",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    maxWidth: ({ theme: e })=>({
            none: "none",
            xs: "20rem",
            sm: "24rem",
            md: "28rem",
            lg: "32rem",
            xl: "36rem",
            "2xl": "42rem",
            "3xl": "48rem",
            "4xl": "56rem",
            "5xl": "64rem",
            "6xl": "72rem",
            "7xl": "80rem",
            full: "100%",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            prose: "65ch",
            ...e("spacing")
        }),
    minHeight: ({ theme: e })=>({
            full: "100%",
            screen: "100vh",
            svh: "100svh",
            lvh: "100lvh",
            dvh: "100dvh",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    minWidth: ({ theme: e })=>({
            full: "100%",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    objectPosition: {
        bottom: "bottom",
        center: "center",
        left: "left",
        "left-bottom": "left bottom",
        "left-top": "left top",
        right: "right",
        "right-bottom": "right bottom",
        "right-top": "right top",
        top: "top"
    },
    opacity: {
        0: "0",
        5: "0.05",
        10: "0.1",
        15: "0.15",
        20: "0.2",
        25: "0.25",
        30: "0.3",
        35: "0.35",
        40: "0.4",
        45: "0.45",
        50: "0.5",
        55: "0.55",
        60: "0.6",
        65: "0.65",
        70: "0.7",
        75: "0.75",
        80: "0.8",
        85: "0.85",
        90: "0.9",
        95: "0.95",
        100: "1",
        ...h
    },
    order: {
        first: "-9999",
        last: "9999",
        none: "0",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        ...x
    },
    outlineColor: ({ theme: e })=>e("colors"),
    outlineOffset: {
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...P
    },
    outlineWidth: {
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...P
    },
    padding: ({ theme: e })=>e("spacing"),
    placeholderColor: ({ theme: e })=>e("colors"),
    placeholderOpacity: ({ theme: e })=>e("opacity"),
    ringColor: ({ theme: e })=>({
            DEFAULT: "currentcolor",
            ...e("colors")
        }),
    ringOffsetColor: ({ theme: e })=>e("colors"),
    ringOffsetWidth: {
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...P
    },
    ringOpacity: ({ theme: e })=>({
            DEFAULT: "0.5",
            ...e("opacity")
        }),
    ringWidth: {
        DEFAULT: "3px",
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...P
    },
    rotate: {
        0: "0deg",
        1: "1deg",
        2: "2deg",
        3: "3deg",
        6: "6deg",
        12: "12deg",
        45: "45deg",
        90: "90deg",
        180: "180deg",
        ...H
    },
    saturate: {
        0: "0",
        50: ".5",
        100: "1",
        150: "1.5",
        200: "2",
        ...h
    },
    scale: {
        0: "0",
        50: ".5",
        75: ".75",
        90: ".9",
        95: ".95",
        100: "1",
        105: "1.05",
        110: "1.1",
        125: "1.25",
        150: "1.5",
        ...h
    },
    screens: {
        sm: "40rem",
        md: "48rem",
        lg: "64rem",
        xl: "80rem",
        "2xl": "96rem"
    },
    scrollMargin: ({ theme: e })=>e("spacing"),
    scrollPadding: ({ theme: e })=>e("spacing"),
    sepia: {
        0: "0",
        DEFAULT: "100%",
        ...h
    },
    skew: {
        0: "0deg",
        1: "1deg",
        2: "2deg",
        3: "3deg",
        6: "6deg",
        12: "12deg",
        ...H
    },
    space: ({ theme: e })=>e("spacing"),
    spacing: {
        px: "1px",
        0: "0px",
        .5: "0.125rem",
        1: "0.25rem",
        1.5: "0.375rem",
        2: "0.5rem",
        2.5: "0.625rem",
        3: "0.75rem",
        3.5: "0.875rem",
        4: "1rem",
        5: "1.25rem",
        6: "1.5rem",
        7: "1.75rem",
        8: "2rem",
        9: "2.25rem",
        10: "2.5rem",
        11: "2.75rem",
        12: "3rem",
        14: "3.5rem",
        16: "4rem",
        20: "5rem",
        24: "6rem",
        28: "7rem",
        32: "8rem",
        36: "9rem",
        40: "10rem",
        44: "11rem",
        48: "12rem",
        52: "13rem",
        56: "14rem",
        60: "15rem",
        64: "16rem",
        72: "18rem",
        80: "20rem",
        96: "24rem"
    },
    stroke: ({ theme: e })=>({
            none: "none",
            ...e("colors")
        }),
    strokeWidth: {
        0: "0",
        1: "1",
        2: "2",
        ...x
    },
    supports: {},
    data: {},
    textColor: ({ theme: e })=>e("colors"),
    textDecorationColor: ({ theme: e })=>e("colors"),
    textDecorationThickness: {
        auto: "auto",
        "from-font": "from-font",
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...P
    },
    textIndent: ({ theme: e })=>e("spacing"),
    textOpacity: ({ theme: e })=>e("opacity"),
    textUnderlineOffset: {
        auto: "auto",
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px",
        ...P
    },
    transformOrigin: {
        center: "center",
        top: "top",
        "top-right": "top right",
        right: "right",
        "bottom-right": "bottom right",
        bottom: "bottom",
        "bottom-left": "bottom left",
        left: "left",
        "top-left": "top left"
    },
    transitionDelay: {
        0: "0s",
        75: "75ms",
        100: "100ms",
        150: "150ms",
        200: "200ms",
        300: "300ms",
        500: "500ms",
        700: "700ms",
        1e3: "1000ms",
        ...Pe
    },
    transitionDuration: {
        DEFAULT: "150ms",
        0: "0s",
        75: "75ms",
        100: "100ms",
        150: "150ms",
        200: "200ms",
        300: "300ms",
        500: "500ms",
        700: "700ms",
        1e3: "1000ms",
        ...Pe
    },
    transitionProperty: {
        none: "none",
        all: "all",
        DEFAULT: "color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter",
        colors: "color, background-color, border-color, outline-color, text-decoration-color, fill, stroke",
        opacity: "opacity",
        shadow: "box-shadow",
        transform: "transform"
    },
    transitionTimingFunction: {
        DEFAULT: "cubic-bezier(0.4, 0, 0.2, 1)",
        linear: "linear",
        in: "cubic-bezier(0.4, 0, 1, 1)",
        out: "cubic-bezier(0, 0, 0.2, 1)",
        "in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
    },
    translate: ({ theme: e })=>({
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            full: "100%",
            ...e("spacing")
        }),
    size: ({ theme: e })=>({
            auto: "auto",
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            "1/12": "8.333333%",
            "2/12": "16.666667%",
            "3/12": "25%",
            "4/12": "33.333333%",
            "5/12": "41.666667%",
            "6/12": "50%",
            "7/12": "58.333333%",
            "8/12": "66.666667%",
            "9/12": "75%",
            "10/12": "83.333333%",
            "11/12": "91.666667%",
            full: "100%",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    width: ({ theme: e })=>({
            auto: "auto",
            "1/2": "50%",
            "1/3": "33.333333%",
            "2/3": "66.666667%",
            "1/4": "25%",
            "2/4": "50%",
            "3/4": "75%",
            "1/5": "20%",
            "2/5": "40%",
            "3/5": "60%",
            "4/5": "80%",
            "1/6": "16.666667%",
            "2/6": "33.333333%",
            "3/6": "50%",
            "4/6": "66.666667%",
            "5/6": "83.333333%",
            "1/12": "8.333333%",
            "2/12": "16.666667%",
            "3/12": "25%",
            "4/12": "33.333333%",
            "5/12": "41.666667%",
            "6/12": "50%",
            "7/12": "58.333333%",
            "8/12": "66.666667%",
            "9/12": "75%",
            "10/12": "83.333333%",
            "11/12": "91.666667%",
            full: "100%",
            screen: "100vw",
            svw: "100svw",
            lvw: "100lvw",
            dvw: "100dvw",
            min: "min-content",
            max: "max-content",
            fit: "fit-content",
            ...e("spacing")
        }),
    willChange: {
        auto: "auto",
        scroll: "scroll-position",
        contents: "contents",
        transform: "transform"
    },
    zIndex: {
        auto: "auto",
        0: "0",
        10: "10",
        20: "20",
        30: "30",
        40: "40",
        50: "50",
        ...x
    }
};
function re(e) {
    let r = [
        0
    ];
    for(let a = 0; a < e.length; a++)e.charCodeAt(a) === 10 && r.push(a + 1);
    function t(a) {
        let i = 0, o = r.length;
        for(; o > 0;){
            let n = (o | 0) >> 1, u = i + n;
            r[u] <= a ? (i = u + 1, o = o - n - 1) : o = n;
        }
        i -= 1;
        let s = a - r[i];
        return {
            line: i + 1,
            column: s
        };
    }
    function l({ line: a, column: i }) {
        a -= 1, a = Math.min(Math.max(a, 0), r.length - 1);
        let o = r[a], s = r[a + 1] ?? o;
        return Math.min(Math.max(o + i, 0), s);
    }
    return {
        find: t,
        findOffset: l
    };
}
var yt = 64;
function U(e, r = []) {
    return {
        kind: "rule",
        selector: e,
        nodes: r
    };
}
function w(e, r = "", t = []) {
    return {
        kind: "at-rule",
        name: e,
        params: r,
        nodes: t
    };
}
function V(e, r = []) {
    return e.charCodeAt(0) === yt ? Ve(e, r) : U(e, r);
}
function S(e, r, t = !1) {
    return {
        kind: "declaration",
        property: e,
        value: r,
        important: t
    };
}
function B(e) {
    return {
        kind: "comment",
        value: e
    };
}
function D(e, r) {
    let t = 0, l = {
        file: null,
        code: ""
    };
    function a(o, s = 0) {
        let n = "", u = "  ".repeat(s);
        if (o.kind === "declaration") {
            if (n += `${u}${o.property}: ${o.value}${o.important ? " !important" : ""};
`, r) {
                t += u.length;
                let c = t;
                t += o.property.length, t += 2, t += o.value?.length ?? 0, o.important && (t += 11);
                let p = t;
                t += 2, o.dst = [
                    l,
                    c,
                    p
                ];
            }
        } else if (o.kind === "rule") {
            if (n += `${u}${o.selector} {
`, r) {
                t += u.length;
                let c = t;
                t += o.selector.length, t += 1;
                let p = t;
                o.dst = [
                    l,
                    c,
                    p
                ], t += 2;
            }
            for (let c of o.nodes)n += a(c, s + 1);
            n += `${u}}
`, r && (t += u.length, t += 2);
        } else if (o.kind === "at-rule") {
            if (o.nodes.length === 0) {
                let c = `${u}${o.name} ${o.params};
`;
                if (r) {
                    t += u.length;
                    let p = t;
                    t += o.name.length, t += 1, t += o.params.length;
                    let F = t;
                    t += 2, o.dst = [
                        l,
                        p,
                        F
                    ];
                }
                return c;
            }
            if (n += `${u}${o.name}${o.params ? ` ${o.params} ` : " "}{
`, r) {
                t += u.length;
                let c = t;
                t += o.name.length, o.params && (t += 1, t += o.params.length), t += 1;
                let p = t;
                o.dst = [
                    l,
                    c,
                    p
                ], t += 2;
            }
            for (let c of o.nodes)n += a(c, s + 1);
            n += `${u}}
`, r && (t += u.length, t += 2);
        } else if (o.kind === "comment") {
            if (n += `${u}/*${o.value}*/
`, r) {
                t += u.length;
                let c = t;
                t += 2 + o.value.length + 2;
                let p = t;
                o.dst = [
                    l,
                    c,
                    p
                ], t += 1;
            }
        } else if (o.kind === "context" || o.kind === "at-root") return "";
        return n;
    }
    let i = "";
    for (let o of e)i += a(o, 0);
    return l.code = i, i;
}
;
var xt = 33;
function Oe(e, r) {
    let t = new m((n)=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["Input"](n.code, {
            map: r?.input.map,
            from: n.file ?? void 0
        })), l = new m((n)=>re(n.code)), a = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["default"].root();
    a.source = r;
    function i(n) {
        if (!n || !n[0]) return;
        let u = l.get(n[0]), c = u.find(n[1]), p = u.find(n[2]);
        return {
            input: t.get(n[0]),
            start: {
                line: c.line,
                column: c.column + 1,
                offset: n[1]
            },
            end: {
                line: p.line,
                column: p.column + 1,
                offset: n[2]
            }
        };
    }
    function o(n, u) {
        let c = i(u);
        c ? n.source = c : delete n.source;
    }
    function s(n, u) {
        if (n.kind === "declaration") {
            let c = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["default"].decl({
                prop: n.property,
                value: n.value ?? "",
                important: n.important
            });
            o(c, n.src), u.append(c);
        } else if (n.kind === "rule") {
            let c = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["default"].rule({
                selector: n.selector
            });
            o(c, n.src), c.raws.semicolon = !0, u.append(c);
            for (let p of n.nodes)s(p, c);
        } else if (n.kind === "at-rule") {
            let c = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["default"].atRule({
                name: n.name.slice(1),
                params: n.params
            });
            o(c, n.src), c.raws.semicolon = !0, u.append(c);
            for (let p of n.nodes)s(p, c);
        } else if (n.kind === "comment") {
            let c = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["default"].comment({
                text: n.value
            });
            c.raws.left = "", c.raws.right = "", o(c, n.src), u.append(c);
        } else n.kind === "at-root" || n.kind;
    }
    for (let n of e)s(n, a);
    return a;
}
function _e(e) {
    let r = new m((i)=>({
            file: i.file ?? i.id ?? null,
            code: i.css
        }));
    function t(i) {
        let o = i.source;
        if (!o) return;
        let s = o.input;
        if (s && o.start !== void 0 && o.end !== void 0) return [
            r.get(s),
            o.start.offset,
            o.end.offset
        ];
    }
    function l(i, o) {
        if (i.type === "decl") {
            let s = S(i.prop, i.value, i.important);
            s.src = t(i), o.push(s);
        } else if (i.type === "rule") {
            let s = V(i.selector);
            s.src = t(i), i.each((n)=>l(n, s.nodes)), o.push(s);
        } else if (i.type === "atrule") {
            let s = w(`@${i.name}`, i.params);
            s.src = t(i), i.each((n)=>l(n, s.nodes)), o.push(s);
        } else if (i.type === "comment") {
            if (i.text.charCodeAt(0) !== xt) return;
            let s = B(i.text);
            s.src = t(i), o.push(s);
        }
    }
    let a = [];
    return e.each((i)=>l(i, a)), a;
}
;
;
var ie = "'", ne = '"';
function oe() {
    let e = new WeakSet;
    function r(t) {
        let l = t.root().source?.input.file;
        if (!l) return;
        let a = t.source?.input.file;
        if (!a || e.has(t)) return;
        let i = t.params[0], o = i[0] === ne && i[i.length - 1] === ne ? ne : i[0] === ie && i[i.length - 1] === ie ? ie : null;
        if (!o) return;
        let s = t.params.slice(1, -1), n = "";
        if (s.startsWith("!") && (s = s.slice(1), n = "!"), !s.startsWith("./") && !s.startsWith("../")) return;
        let u = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].posix.join((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$node$2f$dist$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$locals$3e$__["normalizePath"])(__TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].dirname(a)), s), c = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].posix.dirname((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$node$2f$dist$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$locals$3e$__["normalizePath"])(l)), p = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].posix.relative(c, u);
        p.startsWith(".") || (p = "./" + p), t.params = o + n + p + o, e.add(t);
    }
    return {
        postcssPlugin: "tailwindcss-postcss-fix-relative-paths",
        Once (t) {
            t.walkAtRules(/source|plugin|config/, r);
        }
    };
}
var f = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$node$2f$dist$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$locals$3e$__["env"].DEBUG, se = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$alloc$2f$quick$2d$lru$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__["default"]({
    maxSize: 50
});
function Pt(e, r) {
    let t = `${e}:${r.base ?? ""}:${JSON.stringify(r.optimize)}`;
    if (se.has(t)) return se.get(t);
    let l = {
        mtimes: new Map,
        compiler: null,
        scanner: null,
        tailwindCssAst: [],
        cachedPostCssAst: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["default"].root(),
        optimizedPostCssAst: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["default"].root(),
        fullRebuildPaths: []
    };
    return se.set(t, l), l;
}
function Rt(e = {}) {
    let r = e.base ?? process.cwd(), t = e.optimize ?? process.env.NODE_ENV === "production";
    return {
        postcssPlugin: "@tailwindcss/postcss",
        plugins: [
            oe(),
            {
                postcssPlugin: "tailwindcss",
                async Once (l, { result: a }) {
                    var F = [];
                    try {
                        let i = pe(F, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$node$2f$dist$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Instrumentation"]);
                        let o = a.opts.from ?? "";
                        let s = o.endsWith(".module.css");
                        f && i.start(`[@tailwindcss/postcss] ${(0, __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["relative"])(r, o)}`);
                        {
                            f && i.start("Quick bail check");
                            let y = !0;
                            if (l.walkAtRules((d)=>{
                                if (d.name === "import" || d.name === "reference" || d.name === "theme" || d.name === "variant" || d.name === "config" || d.name === "plugin" || d.name === "apply" || d.name === "tailwind") return y = !1, !1;
                            }), y) return;
                            f && i.end("Quick bail check");
                        }
                        let n = Pt(o, e);
                        let u = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].dirname(__TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].resolve(o));
                        let c = n.compiler === null;
                        async function p() {
                            f && i.start("Setup compiler"), n.fullRebuildPaths.length > 0 && !c && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$node$2f$dist$2f$require$2d$cache$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__["clearRequireCache"])(n.fullRebuildPaths), n.fullRebuildPaths = [], f && i.start("PostCSS AST -> Tailwind CSS AST");
                            let y = _e(l);
                            f && i.end("PostCSS AST -> Tailwind CSS AST"), f && i.start("Create compiler");
                            let d = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$node$2f$dist$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$locals$3e$__["compileAst"])(y, {
                                from: a.opts.from,
                                base: u,
                                shouldRewriteUrls: !0,
                                onDependency: (q)=>n.fullRebuildPaths.push(q),
                                polyfills: s ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$4WXWQT6Y$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__a__as__Polyfills$3e$__["Polyfills"].All ^ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$4WXWQT6Y$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__a__as__Polyfills$3e$__["Polyfills"].AtProperty : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$4WXWQT6Y$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__a__as__Polyfills$3e$__["Polyfills"].All
                            });
                            return f && i.end("Create compiler"), f && i.end("Setup compiler"), d;
                        }
                        try {
                            if (n.compiler ??= p(), (await n.compiler).features === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$4WXWQT6Y$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__b__as__Features$3e$__["Features"].None) return;
                            let y = "incremental";
                            f && i.start("Register full rebuild paths");
                            {
                                for (let g of n.fullRebuildPaths)a.messages.push({
                                    type: "dependency",
                                    plugin: "@tailwindcss/postcss",
                                    file: __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].resolve(g),
                                    parent: a.opts.from
                                });
                                let E = a.messages.flatMap((g)=>g.type !== "dependency" ? [] : g.file);
                                E.push(o);
                                for (let g of E){
                                    let A = __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].statSync(g, {
                                        throwIfNoEntry: !1
                                    })?.mtimeMs ?? null;
                                    if (A === null) {
                                        g === o && (y = "full");
                                        continue;
                                    }
                                    n.mtimes.get(g) !== A && (y = "full", n.mtimes.set(g, A));
                                }
                            }
                            f && i.end("Register full rebuild paths"), y === "full" && !c && (n.compiler = p());
                            let d = await n.compiler;
                            if (n.scanner === null || y === "full") {
                                f && i.start("Setup scanner");
                                let E = (d.root === "none" ? [] : d.root === null ? [
                                    {
                                        base: r,
                                        pattern: "**/*",
                                        negated: !1
                                    }
                                ] : [
                                    {
                                        ...d.root,
                                        negated: !1
                                    }
                                ]).concat(d.sources);
                                n.scanner = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$oxide$2f$index$2e$js__$5b$postcss$5d$__$28$ecmascript$29$__["Scanner"]({
                                    sources: E
                                }), f && i.end("Setup scanner");
                            }
                            f && i.start("Scan for candidates");
                            let q = d.features & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$4WXWQT6Y$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__b__as__Features$3e$__["Features"].Utilities ? n.scanner.scan() : [];
                            if (f && i.end("Scan for candidates"), d.features & __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwindcss$2f$dist$2f$chunk$2d$4WXWQT6Y$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$export__b__as__Features$3e$__["Features"].Utilities) {
                                f && i.start("Register dependency messages");
                                let E = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].resolve(r, o);
                                for (let g of n.scanner.files){
                                    let A = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].resolve(g);
                                    A !== E && a.messages.push({
                                        type: "dependency",
                                        plugin: "@tailwindcss/postcss",
                                        file: A,
                                        parent: a.opts.from
                                    });
                                }
                                for (let { base: g, pattern: A } of n.scanner.globs)A === "*" && r === g || (A === "" ? a.messages.push({
                                    type: "dependency",
                                    plugin: "@tailwindcss/postcss",
                                    file: __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].resolve(g),
                                    parent: a.opts.from
                                }) : a.messages.push({
                                    type: "dir-dependency",
                                    plugin: "@tailwindcss/postcss",
                                    dir: __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].resolve(g),
                                    glob: A,
                                    parent: a.opts.from
                                }));
                                f && i.end("Register dependency messages");
                            }
                            f && i.start("Build utilities");
                            let j = d.build(q);
                            if (f && i.end("Build utilities"), n.tailwindCssAst !== j) if (t) {
                                f && i.start("Optimization"), f && i.start("AST -> CSS");
                                let E = D(j);
                                f && i.end("AST -> CSS"), f && i.start("Lightning CSS");
                                let g = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tailwindcss$2f$node$2f$dist$2f$index$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__$3c$locals$3e$__["optimize"])(E, {
                                    minify: typeof t == "object" ? t.minify : !0
                                });
                                f && i.end("Lightning CSS"), f && i.start("CSS -> PostCSS AST"), n.optimizedPostCssAst = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$postcss$2f$lib$2f$postcss$2e$mjs__$5b$postcss$5d$__$28$ecmascript$29$__["default"].parse(g.code, a.opts), f && i.end("CSS -> PostCSS AST"), f && i.end("Optimization");
                            } else f && i.start("Transform Tailwind CSS AST into PostCSS AST"), n.cachedPostCssAst = Oe(j, l.source), f && i.end("Transform Tailwind CSS AST into PostCSS AST");
                            n.tailwindCssAst = j, f && i.start("Update PostCSS AST"), l.removeAll(), l.append(t ? n.optimizedPostCssAst.clone().nodes : n.cachedPostCssAst.clone().nodes), l.raws.indent = "  ", f && i.end("Update PostCSS AST"), f && i.end(`[@tailwindcss/postcss] ${(0, __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["relative"])(r, o)}`);
                        } catch (y) {
                            n.compiler = null;
                            for (let d of n.fullRebuildPaths)a.messages.push({
                                type: "dependency",
                                plugin: "@tailwindcss/postcss",
                                file: __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].resolve(d),
                                parent: a.opts.from
                            });
                            console.error(y), l.removeAll();
                        }
                    } catch (Ke) {
                        var Le = Ke, ze = !0;
                    } finally{
                        de(F, Le, ze);
                    }
                }
            }
        ]
    };
}
var xl = Object.assign(Rt, {
    postcss: !0
});
;
}),
"[project]/node_modules/node-releases/data/processed/envs.json (json)": ((__turbopack_context__) => {

__turbopack_context__.v(JSON.parse("[{\"name\":\"nodejs\",\"version\":\"0.2.0\",\"date\":\"2011-08-26\",\"lts\":false,\"security\":false,\"v8\":\"2.3.8.0\"},{\"name\":\"nodejs\",\"version\":\"0.3.0\",\"date\":\"2011-08-26\",\"lts\":false,\"security\":false,\"v8\":\"2.5.1.0\"},{\"name\":\"nodejs\",\"version\":\"0.4.0\",\"date\":\"2011-08-26\",\"lts\":false,\"security\":false,\"v8\":\"3.1.2.0\"},{\"name\":\"nodejs\",\"version\":\"0.5.0\",\"date\":\"2011-08-26\",\"lts\":false,\"security\":false,\"v8\":\"3.1.8.25\"},{\"name\":\"nodejs\",\"version\":\"0.6.0\",\"date\":\"2011-11-04\",\"lts\":false,\"security\":false,\"v8\":\"3.6.6.6\"},{\"name\":\"nodejs\",\"version\":\"0.7.0\",\"date\":\"2012-01-17\",\"lts\":false,\"security\":false,\"v8\":\"3.8.6.0\"},{\"name\":\"nodejs\",\"version\":\"0.8.0\",\"date\":\"2012-06-22\",\"lts\":false,\"security\":false,\"v8\":\"3.11.10.10\"},{\"name\":\"nodejs\",\"version\":\"0.9.0\",\"date\":\"2012-07-20\",\"lts\":false,\"security\":false,\"v8\":\"3.11.10.15\"},{\"name\":\"nodejs\",\"version\":\"0.10.0\",\"date\":\"2013-03-11\",\"lts\":false,\"security\":false,\"v8\":\"3.14.5.8\"},{\"name\":\"nodejs\",\"version\":\"0.11.0\",\"date\":\"2013-03-28\",\"lts\":false,\"security\":false,\"v8\":\"3.17.13.0\"},{\"name\":\"nodejs\",\"version\":\"0.12.0\",\"date\":\"2015-02-06\",\"lts\":false,\"security\":false,\"v8\":\"3.28.73.0\"},{\"name\":\"nodejs\",\"version\":\"4.0.0\",\"date\":\"2015-09-08\",\"lts\":false,\"security\":false,\"v8\":\"4.5.103.30\"},{\"name\":\"nodejs\",\"version\":\"4.1.0\",\"date\":\"2015-09-17\",\"lts\":false,\"security\":false,\"v8\":\"4.5.103.33\"},{\"name\":\"nodejs\",\"version\":\"4.2.0\",\"date\":\"2015-10-12\",\"lts\":\"Argon\",\"security\":false,\"v8\":\"4.5.103.35\"},{\"name\":\"nodejs\",\"version\":\"4.3.0\",\"date\":\"2016-02-09\",\"lts\":\"Argon\",\"security\":false,\"v8\":\"4.5.103.35\"},{\"name\":\"nodejs\",\"version\":\"4.4.0\",\"date\":\"2016-03-08\",\"lts\":\"Argon\",\"security\":false,\"v8\":\"4.5.103.35\"},{\"name\":\"nodejs\",\"version\":\"4.5.0\",\"date\":\"2016-08-16\",\"lts\":\"Argon\",\"security\":false,\"v8\":\"4.5.103.37\"},{\"name\":\"nodejs\",\"version\":\"4.6.0\",\"date\":\"2016-09-27\",\"lts\":\"Argon\",\"security\":true,\"v8\":\"4.5.103.37\"},{\"name\":\"nodejs\",\"version\":\"4.7.0\",\"date\":\"2016-12-06\",\"lts\":\"Argon\",\"security\":false,\"v8\":\"4.5.103.43\"},{\"name\":\"nodejs\",\"version\":\"4.8.0\",\"date\":\"2017-02-21\",\"lts\":\"Argon\",\"security\":false,\"v8\":\"4.5.103.45\"},{\"name\":\"nodejs\",\"version\":\"4.9.0\",\"date\":\"2018-03-28\",\"lts\":\"Argon\",\"security\":true,\"v8\":\"4.5.103.53\"},{\"name\":\"nodejs\",\"version\":\"5.0.0\",\"date\":\"2015-10-29\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.28\"},{\"name\":\"nodejs\",\"version\":\"5.1.0\",\"date\":\"2015-11-17\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.2.0\",\"date\":\"2015-12-09\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.3.0\",\"date\":\"2015-12-15\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.4.0\",\"date\":\"2016-01-06\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.5.0\",\"date\":\"2016-01-21\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.6.0\",\"date\":\"2016-02-09\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.7.0\",\"date\":\"2016-02-23\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.8.0\",\"date\":\"2016-03-09\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.9.0\",\"date\":\"2016-03-16\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.10.0\",\"date\":\"2016-04-01\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.11.0\",\"date\":\"2016-04-21\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.31\"},{\"name\":\"nodejs\",\"version\":\"5.12.0\",\"date\":\"2016-06-23\",\"lts\":false,\"security\":false,\"v8\":\"4.6.85.32\"},{\"name\":\"nodejs\",\"version\":\"6.0.0\",\"date\":\"2016-04-26\",\"lts\":false,\"security\":false,\"v8\":\"5.0.71.35\"},{\"name\":\"nodejs\",\"version\":\"6.1.0\",\"date\":\"2016-05-05\",\"lts\":false,\"security\":false,\"v8\":\"5.0.71.35\"},{\"name\":\"nodejs\",\"version\":\"6.2.0\",\"date\":\"2016-05-17\",\"lts\":false,\"security\":false,\"v8\":\"5.0.71.47\"},{\"name\":\"nodejs\",\"version\":\"6.3.0\",\"date\":\"2016-07-06\",\"lts\":false,\"security\":false,\"v8\":\"5.0.71.52\"},{\"name\":\"nodejs\",\"version\":\"6.4.0\",\"date\":\"2016-08-12\",\"lts\":false,\"security\":false,\"v8\":\"5.0.71.60\"},{\"name\":\"nodejs\",\"version\":\"6.5.0\",\"date\":\"2016-08-26\",\"lts\":false,\"security\":false,\"v8\":\"5.1.281.81\"},{\"name\":\"nodejs\",\"version\":\"6.6.0\",\"date\":\"2016-09-14\",\"lts\":false,\"security\":false,\"v8\":\"5.1.281.83\"},{\"name\":\"nodejs\",\"version\":\"6.7.0\",\"date\":\"2016-09-27\",\"lts\":false,\"security\":true,\"v8\":\"5.1.281.83\"},{\"name\":\"nodejs\",\"version\":\"6.8.0\",\"date\":\"2016-10-12\",\"lts\":false,\"security\":false,\"v8\":\"5.1.281.84\"},{\"name\":\"nodejs\",\"version\":\"6.9.0\",\"date\":\"2016-10-18\",\"lts\":\"Boron\",\"security\":false,\"v8\":\"5.1.281.84\"},{\"name\":\"nodejs\",\"version\":\"6.10.0\",\"date\":\"2017-02-21\",\"lts\":\"Boron\",\"security\":false,\"v8\":\"5.1.281.93\"},{\"name\":\"nodejs\",\"version\":\"6.11.0\",\"date\":\"2017-06-06\",\"lts\":\"Boron\",\"security\":false,\"v8\":\"5.1.281.102\"},{\"name\":\"nodejs\",\"version\":\"6.12.0\",\"date\":\"2017-11-06\",\"lts\":\"Boron\",\"security\":false,\"v8\":\"5.1.281.108\"},{\"name\":\"nodejs\",\"version\":\"6.13.0\",\"date\":\"2018-02-10\",\"lts\":\"Boron\",\"security\":false,\"v8\":\"5.1.281.111\"},{\"name\":\"nodejs\",\"version\":\"6.14.0\",\"date\":\"2018-03-28\",\"lts\":\"Boron\",\"security\":true,\"v8\":\"5.1.281.111\"},{\"name\":\"nodejs\",\"version\":\"6.15.0\",\"date\":\"2018-11-27\",\"lts\":\"Boron\",\"security\":true,\"v8\":\"5.1.281.111\"},{\"name\":\"nodejs\",\"version\":\"6.16.0\",\"date\":\"2018-12-26\",\"lts\":\"Boron\",\"security\":false,\"v8\":\"5.1.281.111\"},{\"name\":\"nodejs\",\"version\":\"6.17.0\",\"date\":\"2019-02-28\",\"lts\":\"Boron\",\"security\":true,\"v8\":\"5.1.281.111\"},{\"name\":\"nodejs\",\"version\":\"7.0.0\",\"date\":\"2016-10-25\",\"lts\":false,\"security\":false,\"v8\":\"5.4.500.36\"},{\"name\":\"nodejs\",\"version\":\"7.1.0\",\"date\":\"2016-11-08\",\"lts\":false,\"security\":false,\"v8\":\"5.4.500.36\"},{\"name\":\"nodejs\",\"version\":\"7.2.0\",\"date\":\"2016-11-22\",\"lts\":false,\"security\":false,\"v8\":\"5.4.500.43\"},{\"name\":\"nodejs\",\"version\":\"7.3.0\",\"date\":\"2016-12-20\",\"lts\":false,\"security\":false,\"v8\":\"5.4.500.45\"},{\"name\":\"nodejs\",\"version\":\"7.4.0\",\"date\":\"2017-01-04\",\"lts\":false,\"security\":false,\"v8\":\"5.4.500.45\"},{\"name\":\"nodejs\",\"version\":\"7.5.0\",\"date\":\"2017-01-31\",\"lts\":false,\"security\":false,\"v8\":\"5.4.500.48\"},{\"name\":\"nodejs\",\"version\":\"7.6.0\",\"date\":\"2017-02-21\",\"lts\":false,\"security\":false,\"v8\":\"5.5.372.40\"},{\"name\":\"nodejs\",\"version\":\"7.7.0\",\"date\":\"2017-02-28\",\"lts\":false,\"security\":false,\"v8\":\"5.5.372.41\"},{\"name\":\"nodejs\",\"version\":\"7.8.0\",\"date\":\"2017-03-29\",\"lts\":false,\"security\":false,\"v8\":\"5.5.372.43\"},{\"name\":\"nodejs\",\"version\":\"7.9.0\",\"date\":\"2017-04-11\",\"lts\":false,\"security\":false,\"v8\":\"5.5.372.43\"},{\"name\":\"nodejs\",\"version\":\"7.10.0\",\"date\":\"2017-05-02\",\"lts\":false,\"security\":false,\"v8\":\"5.5.372.43\"},{\"name\":\"nodejs\",\"version\":\"8.0.0\",\"date\":\"2017-05-30\",\"lts\":false,\"security\":false,\"v8\":\"5.8.283.41\"},{\"name\":\"nodejs\",\"version\":\"8.1.0\",\"date\":\"2017-06-08\",\"lts\":false,\"security\":false,\"v8\":\"5.8.283.41\"},{\"name\":\"nodejs\",\"version\":\"8.2.0\",\"date\":\"2017-07-19\",\"lts\":false,\"security\":false,\"v8\":\"5.8.283.41\"},{\"name\":\"nodejs\",\"version\":\"8.3.0\",\"date\":\"2017-08-08\",\"lts\":false,\"security\":false,\"v8\":\"6.0.286.52\"},{\"name\":\"nodejs\",\"version\":\"8.4.0\",\"date\":\"2017-08-15\",\"lts\":false,\"security\":false,\"v8\":\"6.0.286.52\"},{\"name\":\"nodejs\",\"version\":\"8.5.0\",\"date\":\"2017-09-12\",\"lts\":false,\"security\":false,\"v8\":\"6.0.287.53\"},{\"name\":\"nodejs\",\"version\":\"8.6.0\",\"date\":\"2017-09-26\",\"lts\":false,\"security\":false,\"v8\":\"6.0.287.53\"},{\"name\":\"nodejs\",\"version\":\"8.7.0\",\"date\":\"2017-10-11\",\"lts\":false,\"security\":false,\"v8\":\"6.1.534.42\"},{\"name\":\"nodejs\",\"version\":\"8.8.0\",\"date\":\"2017-10-24\",\"lts\":false,\"security\":false,\"v8\":\"6.1.534.42\"},{\"name\":\"nodejs\",\"version\":\"8.9.0\",\"date\":\"2017-10-31\",\"lts\":\"Carbon\",\"security\":false,\"v8\":\"6.1.534.46\"},{\"name\":\"nodejs\",\"version\":\"8.10.0\",\"date\":\"2018-03-06\",\"lts\":\"Carbon\",\"security\":false,\"v8\":\"6.2.414.50\"},{\"name\":\"nodejs\",\"version\":\"8.11.0\",\"date\":\"2018-03-28\",\"lts\":\"Carbon\",\"security\":true,\"v8\":\"6.2.414.50\"},{\"name\":\"nodejs\",\"version\":\"8.12.0\",\"date\":\"2018-09-10\",\"lts\":\"Carbon\",\"security\":false,\"v8\":\"6.2.414.66\"},{\"name\":\"nodejs\",\"version\":\"8.13.0\",\"date\":\"2018-11-20\",\"lts\":\"Carbon\",\"security\":false,\"v8\":\"6.2.414.72\"},{\"name\":\"nodejs\",\"version\":\"8.14.0\",\"date\":\"2018-11-27\",\"lts\":\"Carbon\",\"security\":true,\"v8\":\"6.2.414.72\"},{\"name\":\"nodejs\",\"version\":\"8.15.0\",\"date\":\"2018-12-26\",\"lts\":\"Carbon\",\"security\":false,\"v8\":\"6.2.414.75\"},{\"name\":\"nodejs\",\"version\":\"8.16.0\",\"date\":\"2019-04-16\",\"lts\":\"Carbon\",\"security\":false,\"v8\":\"6.2.414.77\"},{\"name\":\"nodejs\",\"version\":\"8.17.0\",\"date\":\"2019-12-17\",\"lts\":\"Carbon\",\"security\":true,\"v8\":\"6.2.414.78\"},{\"name\":\"nodejs\",\"version\":\"9.0.0\",\"date\":\"2017-10-31\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.32\"},{\"name\":\"nodejs\",\"version\":\"9.1.0\",\"date\":\"2017-11-07\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.32\"},{\"name\":\"nodejs\",\"version\":\"9.2.0\",\"date\":\"2017-11-14\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.44\"},{\"name\":\"nodejs\",\"version\":\"9.3.0\",\"date\":\"2017-12-12\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"9.4.0\",\"date\":\"2018-01-10\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"9.5.0\",\"date\":\"2018-01-31\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"9.6.0\",\"date\":\"2018-02-21\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"9.7.0\",\"date\":\"2018-03-01\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"9.8.0\",\"date\":\"2018-03-07\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"9.9.0\",\"date\":\"2018-03-21\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"9.10.0\",\"date\":\"2018-03-28\",\"lts\":false,\"security\":true,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"9.11.0\",\"date\":\"2018-04-04\",\"lts\":false,\"security\":false,\"v8\":\"6.2.414.46\"},{\"name\":\"nodejs\",\"version\":\"10.0.0\",\"date\":\"2018-04-24\",\"lts\":false,\"security\":false,\"v8\":\"6.6.346.24\"},{\"name\":\"nodejs\",\"version\":\"10.1.0\",\"date\":\"2018-05-08\",\"lts\":false,\"security\":false,\"v8\":\"6.6.346.27\"},{\"name\":\"nodejs\",\"version\":\"10.2.0\",\"date\":\"2018-05-23\",\"lts\":false,\"security\":false,\"v8\":\"6.6.346.32\"},{\"name\":\"nodejs\",\"version\":\"10.3.0\",\"date\":\"2018-05-29\",\"lts\":false,\"security\":false,\"v8\":\"6.6.346.32\"},{\"name\":\"nodejs\",\"version\":\"10.4.0\",\"date\":\"2018-06-06\",\"lts\":false,\"security\":false,\"v8\":\"6.7.288.43\"},{\"name\":\"nodejs\",\"version\":\"10.5.0\",\"date\":\"2018-06-20\",\"lts\":false,\"security\":false,\"v8\":\"6.7.288.46\"},{\"name\":\"nodejs\",\"version\":\"10.6.0\",\"date\":\"2018-07-04\",\"lts\":false,\"security\":false,\"v8\":\"6.7.288.46\"},{\"name\":\"nodejs\",\"version\":\"10.7.0\",\"date\":\"2018-07-18\",\"lts\":false,\"security\":false,\"v8\":\"6.7.288.49\"},{\"name\":\"nodejs\",\"version\":\"10.8.0\",\"date\":\"2018-08-01\",\"lts\":false,\"security\":false,\"v8\":\"6.7.288.49\"},{\"name\":\"nodejs\",\"version\":\"10.9.0\",\"date\":\"2018-08-15\",\"lts\":false,\"security\":false,\"v8\":\"6.8.275.24\"},{\"name\":\"nodejs\",\"version\":\"10.10.0\",\"date\":\"2018-09-06\",\"lts\":false,\"security\":false,\"v8\":\"6.8.275.30\"},{\"name\":\"nodejs\",\"version\":\"10.11.0\",\"date\":\"2018-09-19\",\"lts\":false,\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.12.0\",\"date\":\"2018-10-10\",\"lts\":false,\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.13.0\",\"date\":\"2018-10-30\",\"lts\":\"Dubnium\",\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.14.0\",\"date\":\"2018-11-27\",\"lts\":\"Dubnium\",\"security\":true,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.15.0\",\"date\":\"2018-12-26\",\"lts\":\"Dubnium\",\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.16.0\",\"date\":\"2019-05-28\",\"lts\":\"Dubnium\",\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.17.0\",\"date\":\"2019-10-22\",\"lts\":\"Dubnium\",\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.18.0\",\"date\":\"2019-12-17\",\"lts\":\"Dubnium\",\"security\":true,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.19.0\",\"date\":\"2020-02-05\",\"lts\":\"Dubnium\",\"security\":true,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.20.0\",\"date\":\"2020-03-26\",\"lts\":\"Dubnium\",\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.21.0\",\"date\":\"2020-06-02\",\"lts\":\"Dubnium\",\"security\":true,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.22.0\",\"date\":\"2020-07-21\",\"lts\":\"Dubnium\",\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.23.0\",\"date\":\"2020-10-27\",\"lts\":\"Dubnium\",\"security\":false,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"10.24.0\",\"date\":\"2021-02-23\",\"lts\":\"Dubnium\",\"security\":true,\"v8\":\"6.8.275.32\"},{\"name\":\"nodejs\",\"version\":\"11.0.0\",\"date\":\"2018-10-23\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.28\"},{\"name\":\"nodejs\",\"version\":\"11.1.0\",\"date\":\"2018-10-30\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.32\"},{\"name\":\"nodejs\",\"version\":\"11.2.0\",\"date\":\"2018-11-15\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.3.0\",\"date\":\"2018-11-27\",\"lts\":false,\"security\":true,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.4.0\",\"date\":\"2018-12-07\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.5.0\",\"date\":\"2018-12-18\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.6.0\",\"date\":\"2018-12-26\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.7.0\",\"date\":\"2019-01-17\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.8.0\",\"date\":\"2019-01-24\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.9.0\",\"date\":\"2019-01-30\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.10.0\",\"date\":\"2019-02-14\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.11.0\",\"date\":\"2019-03-05\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.12.0\",\"date\":\"2019-03-14\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.13.0\",\"date\":\"2019-03-28\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.14.0\",\"date\":\"2019-04-10\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"11.15.0\",\"date\":\"2019-04-30\",\"lts\":false,\"security\":false,\"v8\":\"7.0.276.38\"},{\"name\":\"nodejs\",\"version\":\"12.0.0\",\"date\":\"2019-04-23\",\"lts\":false,\"security\":false,\"v8\":\"7.4.288.21\"},{\"name\":\"nodejs\",\"version\":\"12.1.0\",\"date\":\"2019-04-29\",\"lts\":false,\"security\":false,\"v8\":\"7.4.288.21\"},{\"name\":\"nodejs\",\"version\":\"12.2.0\",\"date\":\"2019-05-07\",\"lts\":false,\"security\":false,\"v8\":\"7.4.288.21\"},{\"name\":\"nodejs\",\"version\":\"12.3.0\",\"date\":\"2019-05-21\",\"lts\":false,\"security\":false,\"v8\":\"7.4.288.27\"},{\"name\":\"nodejs\",\"version\":\"12.4.0\",\"date\":\"2019-06-04\",\"lts\":false,\"security\":false,\"v8\":\"7.4.288.27\"},{\"name\":\"nodejs\",\"version\":\"12.5.0\",\"date\":\"2019-06-26\",\"lts\":false,\"security\":false,\"v8\":\"7.5.288.22\"},{\"name\":\"nodejs\",\"version\":\"12.6.0\",\"date\":\"2019-07-03\",\"lts\":false,\"security\":false,\"v8\":\"7.5.288.22\"},{\"name\":\"nodejs\",\"version\":\"12.7.0\",\"date\":\"2019-07-23\",\"lts\":false,\"security\":false,\"v8\":\"7.5.288.22\"},{\"name\":\"nodejs\",\"version\":\"12.8.0\",\"date\":\"2019-08-06\",\"lts\":false,\"security\":false,\"v8\":\"7.5.288.22\"},{\"name\":\"nodejs\",\"version\":\"12.9.0\",\"date\":\"2019-08-20\",\"lts\":false,\"security\":false,\"v8\":\"7.6.303.29\"},{\"name\":\"nodejs\",\"version\":\"12.10.0\",\"date\":\"2019-09-04\",\"lts\":false,\"security\":false,\"v8\":\"7.6.303.29\"},{\"name\":\"nodejs\",\"version\":\"12.11.0\",\"date\":\"2019-09-25\",\"lts\":false,\"security\":false,\"v8\":\"7.7.299.11\"},{\"name\":\"nodejs\",\"version\":\"12.12.0\",\"date\":\"2019-10-11\",\"lts\":false,\"security\":false,\"v8\":\"7.7.299.13\"},{\"name\":\"nodejs\",\"version\":\"12.13.0\",\"date\":\"2019-10-21\",\"lts\":\"Erbium\",\"security\":false,\"v8\":\"7.7.299.13\"},{\"name\":\"nodejs\",\"version\":\"12.14.0\",\"date\":\"2019-12-17\",\"lts\":\"Erbium\",\"security\":true,\"v8\":\"7.7.299.13\"},{\"name\":\"nodejs\",\"version\":\"12.15.0\",\"date\":\"2020-02-05\",\"lts\":\"Erbium\",\"security\":true,\"v8\":\"7.7.299.13\"},{\"name\":\"nodejs\",\"version\":\"12.16.0\",\"date\":\"2020-02-11\",\"lts\":\"Erbium\",\"security\":false,\"v8\":\"7.8.279.23\"},{\"name\":\"nodejs\",\"version\":\"12.17.0\",\"date\":\"2020-05-26\",\"lts\":\"Erbium\",\"security\":false,\"v8\":\"7.8.279.23\"},{\"name\":\"nodejs\",\"version\":\"12.18.0\",\"date\":\"2020-06-02\",\"lts\":\"Erbium\",\"security\":true,\"v8\":\"7.8.279.23\"},{\"name\":\"nodejs\",\"version\":\"12.19.0\",\"date\":\"2020-10-06\",\"lts\":\"Erbium\",\"security\":false,\"v8\":\"7.8.279.23\"},{\"name\":\"nodejs\",\"version\":\"12.20.0\",\"date\":\"2020-11-24\",\"lts\":\"Erbium\",\"security\":false,\"v8\":\"7.8.279.23\"},{\"name\":\"nodejs\",\"version\":\"12.21.0\",\"date\":\"2021-02-23\",\"lts\":\"Erbium\",\"security\":true,\"v8\":\"7.8.279.23\"},{\"name\":\"nodejs\",\"version\":\"12.22.0\",\"date\":\"2021-03-30\",\"lts\":\"Erbium\",\"security\":false,\"v8\":\"7.8.279.23\"},{\"name\":\"nodejs\",\"version\":\"13.0.0\",\"date\":\"2019-10-22\",\"lts\":false,\"security\":false,\"v8\":\"7.8.279.17\"},{\"name\":\"nodejs\",\"version\":\"13.1.0\",\"date\":\"2019-11-05\",\"lts\":false,\"security\":false,\"v8\":\"7.8.279.17\"},{\"name\":\"nodejs\",\"version\":\"13.2.0\",\"date\":\"2019-11-21\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.23\"},{\"name\":\"nodejs\",\"version\":\"13.3.0\",\"date\":\"2019-12-03\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.4.0\",\"date\":\"2019-12-17\",\"lts\":false,\"security\":true,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.5.0\",\"date\":\"2019-12-18\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.6.0\",\"date\":\"2020-01-07\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.7.0\",\"date\":\"2020-01-21\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.8.0\",\"date\":\"2020-02-05\",\"lts\":false,\"security\":true,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.9.0\",\"date\":\"2020-02-18\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.10.0\",\"date\":\"2020-03-04\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.11.0\",\"date\":\"2020-03-12\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.12.0\",\"date\":\"2020-03-26\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.13.0\",\"date\":\"2020-04-14\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"13.14.0\",\"date\":\"2020-04-29\",\"lts\":false,\"security\":false,\"v8\":\"7.9.317.25\"},{\"name\":\"nodejs\",\"version\":\"14.0.0\",\"date\":\"2020-04-21\",\"lts\":false,\"security\":false,\"v8\":\"8.1.307.30\"},{\"name\":\"nodejs\",\"version\":\"14.1.0\",\"date\":\"2020-04-29\",\"lts\":false,\"security\":false,\"v8\":\"8.1.307.31\"},{\"name\":\"nodejs\",\"version\":\"14.2.0\",\"date\":\"2020-05-05\",\"lts\":false,\"security\":false,\"v8\":\"8.1.307.31\"},{\"name\":\"nodejs\",\"version\":\"14.3.0\",\"date\":\"2020-05-19\",\"lts\":false,\"security\":false,\"v8\":\"8.1.307.31\"},{\"name\":\"nodejs\",\"version\":\"14.4.0\",\"date\":\"2020-06-02\",\"lts\":false,\"security\":true,\"v8\":\"8.1.307.31\"},{\"name\":\"nodejs\",\"version\":\"14.5.0\",\"date\":\"2020-06-30\",\"lts\":false,\"security\":false,\"v8\":\"8.3.110.9\"},{\"name\":\"nodejs\",\"version\":\"14.6.0\",\"date\":\"2020-07-20\",\"lts\":false,\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.7.0\",\"date\":\"2020-07-29\",\"lts\":false,\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.8.0\",\"date\":\"2020-08-11\",\"lts\":false,\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.9.0\",\"date\":\"2020-08-27\",\"lts\":false,\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.10.0\",\"date\":\"2020-09-08\",\"lts\":false,\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.11.0\",\"date\":\"2020-09-15\",\"lts\":false,\"security\":true,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.12.0\",\"date\":\"2020-09-22\",\"lts\":false,\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.13.0\",\"date\":\"2020-09-29\",\"lts\":false,\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.14.0\",\"date\":\"2020-10-15\",\"lts\":false,\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.15.0\",\"date\":\"2020-10-27\",\"lts\":\"Fermium\",\"security\":false,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.16.0\",\"date\":\"2021-02-23\",\"lts\":\"Fermium\",\"security\":true,\"v8\":\"8.4.371.19\"},{\"name\":\"nodejs\",\"version\":\"14.17.0\",\"date\":\"2021-05-11\",\"lts\":\"Fermium\",\"security\":false,\"v8\":\"8.4.371.23\"},{\"name\":\"nodejs\",\"version\":\"14.18.0\",\"date\":\"2021-09-28\",\"lts\":\"Fermium\",\"security\":false,\"v8\":\"8.4.371.23\"},{\"name\":\"nodejs\",\"version\":\"14.19.0\",\"date\":\"2022-02-01\",\"lts\":\"Fermium\",\"security\":false,\"v8\":\"8.4.371.23\"},{\"name\":\"nodejs\",\"version\":\"14.20.0\",\"date\":\"2022-07-07\",\"lts\":\"Fermium\",\"security\":true,\"v8\":\"8.4.371.23\"},{\"name\":\"nodejs\",\"version\":\"14.21.0\",\"date\":\"2022-11-01\",\"lts\":\"Fermium\",\"security\":false,\"v8\":\"8.4.371.23\"},{\"name\":\"nodejs\",\"version\":\"15.0.0\",\"date\":\"2020-10-20\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.16\"},{\"name\":\"nodejs\",\"version\":\"15.1.0\",\"date\":\"2020-11-04\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.2.0\",\"date\":\"2020-11-10\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.3.0\",\"date\":\"2020-11-24\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.4.0\",\"date\":\"2020-12-09\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.5.0\",\"date\":\"2020-12-22\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.6.0\",\"date\":\"2021-01-14\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.7.0\",\"date\":\"2021-01-25\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.8.0\",\"date\":\"2021-02-02\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.9.0\",\"date\":\"2021-02-18\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.10.0\",\"date\":\"2021-02-23\",\"lts\":false,\"security\":true,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.11.0\",\"date\":\"2021-03-03\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.12.0\",\"date\":\"2021-03-17\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.13.0\",\"date\":\"2021-03-31\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"15.14.0\",\"date\":\"2021-04-06\",\"lts\":false,\"security\":false,\"v8\":\"8.6.395.17\"},{\"name\":\"nodejs\",\"version\":\"16.0.0\",\"date\":\"2021-04-20\",\"lts\":false,\"security\":false,\"v8\":\"9.0.257.17\"},{\"name\":\"nodejs\",\"version\":\"16.1.0\",\"date\":\"2021-05-04\",\"lts\":false,\"security\":false,\"v8\":\"9.0.257.24\"},{\"name\":\"nodejs\",\"version\":\"16.2.0\",\"date\":\"2021-05-19\",\"lts\":false,\"security\":false,\"v8\":\"9.0.257.25\"},{\"name\":\"nodejs\",\"version\":\"16.3.0\",\"date\":\"2021-06-03\",\"lts\":false,\"security\":false,\"v8\":\"9.0.257.25\"},{\"name\":\"nodejs\",\"version\":\"16.4.0\",\"date\":\"2021-06-23\",\"lts\":false,\"security\":false,\"v8\":\"9.1.269.36\"},{\"name\":\"nodejs\",\"version\":\"16.5.0\",\"date\":\"2021-07-14\",\"lts\":false,\"security\":false,\"v8\":\"9.1.269.38\"},{\"name\":\"nodejs\",\"version\":\"16.6.0\",\"date\":\"2021-07-29\",\"lts\":false,\"security\":true,\"v8\":\"9.2.230.21\"},{\"name\":\"nodejs\",\"version\":\"16.7.0\",\"date\":\"2021-08-18\",\"lts\":false,\"security\":false,\"v8\":\"9.2.230.21\"},{\"name\":\"nodejs\",\"version\":\"16.8.0\",\"date\":\"2021-08-25\",\"lts\":false,\"security\":false,\"v8\":\"9.2.230.21\"},{\"name\":\"nodejs\",\"version\":\"16.9.0\",\"date\":\"2021-09-07\",\"lts\":false,\"security\":false,\"v8\":\"9.3.345.16\"},{\"name\":\"nodejs\",\"version\":\"16.10.0\",\"date\":\"2021-09-22\",\"lts\":false,\"security\":false,\"v8\":\"9.3.345.19\"},{\"name\":\"nodejs\",\"version\":\"16.11.0\",\"date\":\"2021-10-08\",\"lts\":false,\"security\":false,\"v8\":\"9.4.146.19\"},{\"name\":\"nodejs\",\"version\":\"16.12.0\",\"date\":\"2021-10-20\",\"lts\":false,\"security\":false,\"v8\":\"9.4.146.19\"},{\"name\":\"nodejs\",\"version\":\"16.13.0\",\"date\":\"2021-10-26\",\"lts\":\"Gallium\",\"security\":false,\"v8\":\"9.4.146.19\"},{\"name\":\"nodejs\",\"version\":\"16.14.0\",\"date\":\"2022-02-08\",\"lts\":\"Gallium\",\"security\":false,\"v8\":\"9.4.146.24\"},{\"name\":\"nodejs\",\"version\":\"16.15.0\",\"date\":\"2022-04-26\",\"lts\":\"Gallium\",\"security\":false,\"v8\":\"9.4.146.24\"},{\"name\":\"nodejs\",\"version\":\"16.16.0\",\"date\":\"2022-07-07\",\"lts\":\"Gallium\",\"security\":true,\"v8\":\"9.4.146.24\"},{\"name\":\"nodejs\",\"version\":\"16.17.0\",\"date\":\"2022-08-16\",\"lts\":\"Gallium\",\"security\":false,\"v8\":\"9.4.146.26\"},{\"name\":\"nodejs\",\"version\":\"16.18.0\",\"date\":\"2022-10-12\",\"lts\":\"Gallium\",\"security\":false,\"v8\":\"9.4.146.26\"},{\"name\":\"nodejs\",\"version\":\"16.19.0\",\"date\":\"2022-12-13\",\"lts\":\"Gallium\",\"security\":false,\"v8\":\"9.4.146.26\"},{\"name\":\"nodejs\",\"version\":\"16.20.0\",\"date\":\"2023-03-28\",\"lts\":\"Gallium\",\"security\":false,\"v8\":\"9.4.146.26\"},{\"name\":\"nodejs\",\"version\":\"17.0.0\",\"date\":\"2021-10-19\",\"lts\":false,\"security\":false,\"v8\":\"9.5.172.21\"},{\"name\":\"nodejs\",\"version\":\"17.1.0\",\"date\":\"2021-11-09\",\"lts\":false,\"security\":false,\"v8\":\"9.5.172.25\"},{\"name\":\"nodejs\",\"version\":\"17.2.0\",\"date\":\"2021-11-30\",\"lts\":false,\"security\":false,\"v8\":\"9.6.180.14\"},{\"name\":\"nodejs\",\"version\":\"17.3.0\",\"date\":\"2021-12-17\",\"lts\":false,\"security\":false,\"v8\":\"9.6.180.15\"},{\"name\":\"nodejs\",\"version\":\"17.4.0\",\"date\":\"2022-01-18\",\"lts\":false,\"security\":false,\"v8\":\"9.6.180.15\"},{\"name\":\"nodejs\",\"version\":\"17.5.0\",\"date\":\"2022-02-10\",\"lts\":false,\"security\":false,\"v8\":\"9.6.180.15\"},{\"name\":\"nodejs\",\"version\":\"17.6.0\",\"date\":\"2022-02-22\",\"lts\":false,\"security\":false,\"v8\":\"9.6.180.15\"},{\"name\":\"nodejs\",\"version\":\"17.7.0\",\"date\":\"2022-03-09\",\"lts\":false,\"security\":false,\"v8\":\"9.6.180.15\"},{\"name\":\"nodejs\",\"version\":\"17.8.0\",\"date\":\"2022-03-22\",\"lts\":false,\"security\":false,\"v8\":\"9.6.180.15\"},{\"name\":\"nodejs\",\"version\":\"17.9.0\",\"date\":\"2022-04-07\",\"lts\":false,\"security\":false,\"v8\":\"9.6.180.15\"},{\"name\":\"nodejs\",\"version\":\"18.0.0\",\"date\":\"2022-04-18\",\"lts\":false,\"security\":false,\"v8\":\"10.1.124.8\"},{\"name\":\"nodejs\",\"version\":\"18.1.0\",\"date\":\"2022-05-03\",\"lts\":false,\"security\":false,\"v8\":\"10.1.124.8\"},{\"name\":\"nodejs\",\"version\":\"18.2.0\",\"date\":\"2022-05-17\",\"lts\":false,\"security\":false,\"v8\":\"10.1.124.8\"},{\"name\":\"nodejs\",\"version\":\"18.3.0\",\"date\":\"2022-06-02\",\"lts\":false,\"security\":false,\"v8\":\"10.2.154.4\"},{\"name\":\"nodejs\",\"version\":\"18.4.0\",\"date\":\"2022-06-16\",\"lts\":false,\"security\":false,\"v8\":\"10.2.154.4\"},{\"name\":\"nodejs\",\"version\":\"18.5.0\",\"date\":\"2022-07-06\",\"lts\":false,\"security\":true,\"v8\":\"10.2.154.4\"},{\"name\":\"nodejs\",\"version\":\"18.6.0\",\"date\":\"2022-07-13\",\"lts\":false,\"security\":false,\"v8\":\"10.2.154.13\"},{\"name\":\"nodejs\",\"version\":\"18.7.0\",\"date\":\"2022-07-26\",\"lts\":false,\"security\":false,\"v8\":\"10.2.154.13\"},{\"name\":\"nodejs\",\"version\":\"18.8.0\",\"date\":\"2022-08-24\",\"lts\":false,\"security\":false,\"v8\":\"10.2.154.13\"},{\"name\":\"nodejs\",\"version\":\"18.9.0\",\"date\":\"2022-09-07\",\"lts\":false,\"security\":false,\"v8\":\"10.2.154.15\"},{\"name\":\"nodejs\",\"version\":\"18.10.0\",\"date\":\"2022-09-28\",\"lts\":false,\"security\":false,\"v8\":\"10.2.154.15\"},{\"name\":\"nodejs\",\"version\":\"18.11.0\",\"date\":\"2022-10-13\",\"lts\":false,\"security\":false,\"v8\":\"10.2.154.15\"},{\"name\":\"nodejs\",\"version\":\"18.12.0\",\"date\":\"2022-10-25\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.15\"},{\"name\":\"nodejs\",\"version\":\"18.13.0\",\"date\":\"2023-01-05\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.23\"},{\"name\":\"nodejs\",\"version\":\"18.14.0\",\"date\":\"2023-02-01\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.23\"},{\"name\":\"nodejs\",\"version\":\"18.15.0\",\"date\":\"2023-03-05\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.26\"},{\"name\":\"nodejs\",\"version\":\"18.16.0\",\"date\":\"2023-04-12\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.26\"},{\"name\":\"nodejs\",\"version\":\"18.17.0\",\"date\":\"2023-07-18\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.26\"},{\"name\":\"nodejs\",\"version\":\"18.18.0\",\"date\":\"2023-09-18\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.26\"},{\"name\":\"nodejs\",\"version\":\"18.19.0\",\"date\":\"2023-11-29\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.26\"},{\"name\":\"nodejs\",\"version\":\"18.20.0\",\"date\":\"2024-03-26\",\"lts\":\"Hydrogen\",\"security\":false,\"v8\":\"10.2.154.26\"},{\"name\":\"nodejs\",\"version\":\"19.0.0\",\"date\":\"2022-10-17\",\"lts\":false,\"security\":false,\"v8\":\"10.7.193.13\"},{\"name\":\"nodejs\",\"version\":\"19.1.0\",\"date\":\"2022-11-14\",\"lts\":false,\"security\":false,\"v8\":\"10.7.193.20\"},{\"name\":\"nodejs\",\"version\":\"19.2.0\",\"date\":\"2022-11-29\",\"lts\":false,\"security\":false,\"v8\":\"10.8.168.20\"},{\"name\":\"nodejs\",\"version\":\"19.3.0\",\"date\":\"2022-12-14\",\"lts\":false,\"security\":false,\"v8\":\"10.8.168.21\"},{\"name\":\"nodejs\",\"version\":\"19.4.0\",\"date\":\"2023-01-05\",\"lts\":false,\"security\":false,\"v8\":\"10.8.168.25\"},{\"name\":\"nodejs\",\"version\":\"19.5.0\",\"date\":\"2023-01-24\",\"lts\":false,\"security\":false,\"v8\":\"10.8.168.25\"},{\"name\":\"nodejs\",\"version\":\"19.6.0\",\"date\":\"2023-02-01\",\"lts\":false,\"security\":false,\"v8\":\"10.8.168.25\"},{\"name\":\"nodejs\",\"version\":\"19.7.0\",\"date\":\"2023-02-21\",\"lts\":false,\"security\":false,\"v8\":\"10.8.168.25\"},{\"name\":\"nodejs\",\"version\":\"19.8.0\",\"date\":\"2023-03-14\",\"lts\":false,\"security\":false,\"v8\":\"10.8.168.25\"},{\"name\":\"nodejs\",\"version\":\"19.9.0\",\"date\":\"2023-04-10\",\"lts\":false,\"security\":false,\"v8\":\"10.8.168.25\"},{\"name\":\"nodejs\",\"version\":\"20.0.0\",\"date\":\"2023-04-17\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.4\"},{\"name\":\"nodejs\",\"version\":\"20.1.0\",\"date\":\"2023-05-03\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.2.0\",\"date\":\"2023-05-16\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.3.0\",\"date\":\"2023-06-08\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.4.0\",\"date\":\"2023-07-04\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.5.0\",\"date\":\"2023-07-19\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.6.0\",\"date\":\"2023-08-23\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.7.0\",\"date\":\"2023-09-18\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.8.0\",\"date\":\"2023-09-28\",\"lts\":false,\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.9.0\",\"date\":\"2023-10-24\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.10.0\",\"date\":\"2023-11-22\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.11.0\",\"date\":\"2024-01-09\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.12.0\",\"date\":\"2024-03-26\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.13.0\",\"date\":\"2024-05-07\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.14.0\",\"date\":\"2024-05-28\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.15.0\",\"date\":\"2024-06-20\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.16.0\",\"date\":\"2024-07-24\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.17.0\",\"date\":\"2024-08-21\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"20.18.0\",\"date\":\"2024-10-03\",\"lts\":\"Iron\",\"security\":false,\"v8\":\"11.3.244.8\"},{\"name\":\"nodejs\",\"version\":\"21.0.0\",\"date\":\"2023-10-17\",\"lts\":false,\"security\":false,\"v8\":\"11.8.172.13\"},{\"name\":\"nodejs\",\"version\":\"21.1.0\",\"date\":\"2023-10-24\",\"lts\":false,\"security\":false,\"v8\":\"11.8.172.15\"},{\"name\":\"nodejs\",\"version\":\"21.2.0\",\"date\":\"2023-11-14\",\"lts\":false,\"security\":false,\"v8\":\"11.8.172.17\"},{\"name\":\"nodejs\",\"version\":\"21.3.0\",\"date\":\"2023-11-30\",\"lts\":false,\"security\":false,\"v8\":\"11.8.172.17\"},{\"name\":\"nodejs\",\"version\":\"21.4.0\",\"date\":\"2023-12-05\",\"lts\":false,\"security\":false,\"v8\":\"11.8.172.17\"},{\"name\":\"nodejs\",\"version\":\"21.5.0\",\"date\":\"2023-12-19\",\"lts\":false,\"security\":false,\"v8\":\"11.8.172.17\"},{\"name\":\"nodejs\",\"version\":\"21.6.0\",\"date\":\"2024-01-14\",\"lts\":false,\"security\":false,\"v8\":\"11.8.172.17\"},{\"name\":\"nodejs\",\"version\":\"21.7.0\",\"date\":\"2024-03-06\",\"lts\":false,\"security\":false,\"v8\":\"11.8.172.17\"},{\"name\":\"nodejs\",\"version\":\"22.0.0\",\"date\":\"2024-04-24\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.14\"},{\"name\":\"nodejs\",\"version\":\"22.1.0\",\"date\":\"2024-05-02\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.14\"},{\"name\":\"nodejs\",\"version\":\"22.2.0\",\"date\":\"2024-05-15\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.14\"},{\"name\":\"nodejs\",\"version\":\"22.3.0\",\"date\":\"2024-06-11\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.20\"},{\"name\":\"nodejs\",\"version\":\"22.4.0\",\"date\":\"2024-07-02\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.5.0\",\"date\":\"2024-07-17\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.6.0\",\"date\":\"2024-08-06\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.7.0\",\"date\":\"2024-08-21\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.8.0\",\"date\":\"2024-09-03\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.9.0\",\"date\":\"2024-09-17\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.10.0\",\"date\":\"2024-10-16\",\"lts\":false,\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.11.0\",\"date\":\"2024-10-29\",\"lts\":\"Jod\",\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"22.12.0\",\"date\":\"2024-12-02\",\"lts\":\"Jod\",\"security\":false,\"v8\":\"12.4.254.21\"},{\"name\":\"nodejs\",\"version\":\"23.0.0\",\"date\":\"2024-10-16\",\"lts\":false,\"security\":false,\"v8\":\"12.9.202.26\"},{\"name\":\"nodejs\",\"version\":\"23.1.0\",\"date\":\"2024-10-24\",\"lts\":false,\"security\":false,\"v8\":\"12.9.202.28\"},{\"name\":\"nodejs\",\"version\":\"23.2.0\",\"date\":\"2024-11-11\",\"lts\":false,\"security\":false,\"v8\":\"12.9.202.28\"},{\"name\":\"nodejs\",\"version\":\"23.3.0\",\"date\":\"2024-11-20\",\"lts\":false,\"security\":false,\"v8\":\"12.9.202.28\"}]"));}),
"[project]/node_modules/node-releases/data/release-schedule/release-schedule.json (json)": ((__turbopack_context__) => {

__turbopack_context__.v(JSON.parse("{\"v0.8\":{\"start\":\"2012-06-25\",\"end\":\"2014-07-31\"},\"v0.10\":{\"start\":\"2013-03-11\",\"end\":\"2016-10-31\"},\"v0.12\":{\"start\":\"2015-02-06\",\"end\":\"2016-12-31\"},\"v4\":{\"start\":\"2015-09-08\",\"lts\":\"2015-10-12\",\"maintenance\":\"2017-04-01\",\"end\":\"2018-04-30\",\"codename\":\"Argon\"},\"v5\":{\"start\":\"2015-10-29\",\"maintenance\":\"2016-04-30\",\"end\":\"2016-06-30\"},\"v6\":{\"start\":\"2016-04-26\",\"lts\":\"2016-10-18\",\"maintenance\":\"2018-04-30\",\"end\":\"2019-04-30\",\"codename\":\"Boron\"},\"v7\":{\"start\":\"2016-10-25\",\"maintenance\":\"2017-04-30\",\"end\":\"2017-06-30\"},\"v8\":{\"start\":\"2017-05-30\",\"lts\":\"2017-10-31\",\"maintenance\":\"2019-01-01\",\"end\":\"2019-12-31\",\"codename\":\"Carbon\"},\"v9\":{\"start\":\"2017-10-01\",\"maintenance\":\"2018-04-01\",\"end\":\"2018-06-30\"},\"v10\":{\"start\":\"2018-04-24\",\"lts\":\"2018-10-30\",\"maintenance\":\"2020-05-19\",\"end\":\"2021-04-30\",\"codename\":\"Dubnium\"},\"v11\":{\"start\":\"2018-10-23\",\"maintenance\":\"2019-04-22\",\"end\":\"2019-06-01\"},\"v12\":{\"start\":\"2019-04-23\",\"lts\":\"2019-10-21\",\"maintenance\":\"2020-11-30\",\"end\":\"2022-04-30\",\"codename\":\"Erbium\"},\"v13\":{\"start\":\"2019-10-22\",\"maintenance\":\"2020-04-01\",\"end\":\"2020-06-01\"},\"v14\":{\"start\":\"2020-04-21\",\"lts\":\"2020-10-27\",\"maintenance\":\"2021-10-19\",\"end\":\"2023-04-30\",\"codename\":\"Fermium\"},\"v15\":{\"start\":\"2020-10-20\",\"maintenance\":\"2021-04-01\",\"end\":\"2021-06-01\"},\"v16\":{\"start\":\"2021-04-20\",\"lts\":\"2021-10-26\",\"maintenance\":\"2022-10-18\",\"end\":\"2023-09-11\",\"codename\":\"Gallium\"},\"v17\":{\"start\":\"2021-10-19\",\"maintenance\":\"2022-04-01\",\"end\":\"2022-06-01\"},\"v18\":{\"start\":\"2022-04-19\",\"lts\":\"2022-10-25\",\"maintenance\":\"2023-10-18\",\"end\":\"2025-04-30\",\"codename\":\"Hydrogen\"},\"v19\":{\"start\":\"2022-10-18\",\"maintenance\":\"2023-04-01\",\"end\":\"2023-06-01\"},\"v20\":{\"start\":\"2023-04-18\",\"lts\":\"2023-10-24\",\"maintenance\":\"2024-10-22\",\"end\":\"2026-04-30\",\"codename\":\"Iron\"},\"v21\":{\"start\":\"2023-10-17\",\"maintenance\":\"2024-04-01\",\"end\":\"2024-06-01\"},\"v22\":{\"start\":\"2024-04-24\",\"lts\":\"2024-10-29\",\"maintenance\":\"2025-10-21\",\"end\":\"2027-04-30\",\"codename\":\"Jod\"},\"v23\":{\"start\":\"2024-10-16\",\"maintenance\":\"2025-04-01\",\"end\":\"2025-06-01\"},\"v24\":{\"start\":\"2025-04-22\",\"lts\":\"2025-10-28\",\"maintenance\":\"2026-10-20\",\"end\":\"2028-04-30\",\"codename\":\"\"}}"));}),
"[project]/node_modules/electron-to-chromium/versions.js [postcss] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
module.exports = {
    "0.20": "39",
    "0.21": "41",
    "0.22": "41",
    "0.23": "41",
    "0.24": "41",
    "0.25": "42",
    "0.26": "42",
    "0.27": "43",
    "0.28": "43",
    "0.29": "43",
    "0.30": "44",
    "0.31": "45",
    "0.32": "45",
    "0.33": "45",
    "0.34": "45",
    "0.35": "45",
    "0.36": "47",
    "0.37": "49",
    "1.0": "49",
    "1.1": "50",
    "1.2": "51",
    "1.3": "52",
    "1.4": "53",
    "1.5": "54",
    "1.6": "56",
    "1.7": "58",
    "1.8": "59",
    "2.0": "61",
    "2.1": "61",
    "3.0": "66",
    "3.1": "66",
    "4.0": "69",
    "4.1": "69",
    "4.2": "69",
    "5.0": "73",
    "6.0": "76",
    "6.1": "76",
    "7.0": "78",
    "7.1": "78",
    "7.2": "78",
    "7.3": "78",
    "8.0": "80",
    "8.1": "80",
    "8.2": "80",
    "8.3": "80",
    "8.4": "80",
    "8.5": "80",
    "9.0": "83",
    "9.1": "83",
    "9.2": "83",
    "9.3": "83",
    "9.4": "83",
    "10.0": "85",
    "10.1": "85",
    "10.2": "85",
    "10.3": "85",
    "10.4": "85",
    "11.0": "87",
    "11.1": "87",
    "11.2": "87",
    "11.3": "87",
    "11.4": "87",
    "11.5": "87",
    "12.0": "89",
    "12.1": "89",
    "12.2": "89",
    "13.0": "91",
    "13.1": "91",
    "13.2": "91",
    "13.3": "91",
    "13.4": "91",
    "13.5": "91",
    "13.6": "91",
    "14.0": "93",
    "14.1": "93",
    "14.2": "93",
    "15.0": "94",
    "15.1": "94",
    "15.2": "94",
    "15.3": "94",
    "15.4": "94",
    "15.5": "94",
    "16.0": "96",
    "16.1": "96",
    "16.2": "96",
    "17.0": "98",
    "17.1": "98",
    "17.2": "98",
    "17.3": "98",
    "17.4": "98",
    "18.0": "100",
    "18.1": "100",
    "18.2": "100",
    "18.3": "100",
    "19.0": "102",
    "19.1": "102",
    "20.0": "104",
    "20.1": "104",
    "20.2": "104",
    "20.3": "104",
    "21.0": "106",
    "21.1": "106",
    "21.2": "106",
    "21.3": "106",
    "21.4": "106",
    "22.0": "108",
    "22.1": "108",
    "22.2": "108",
    "22.3": "108",
    "23.0": "110",
    "23.1": "110",
    "23.2": "110",
    "23.3": "110",
    "24.0": "112",
    "24.1": "112",
    "24.2": "112",
    "24.3": "112",
    "24.4": "112",
    "24.5": "112",
    "24.6": "112",
    "24.7": "112",
    "24.8": "112",
    "25.0": "114",
    "25.1": "114",
    "25.2": "114",
    "25.3": "114",
    "25.4": "114",
    "25.5": "114",
    "25.6": "114",
    "25.7": "114",
    "25.8": "114",
    "25.9": "114",
    "26.0": "116",
    "26.1": "116",
    "26.2": "116",
    "26.3": "116",
    "26.4": "116",
    "26.5": "116",
    "26.6": "116",
    "27.0": "118",
    "27.1": "118",
    "27.2": "118",
    "27.3": "118",
    "28.0": "120",
    "28.1": "120",
    "28.2": "120",
    "28.3": "120",
    "29.0": "122",
    "29.1": "122",
    "29.2": "122",
    "29.3": "122",
    "29.4": "122",
    "30.0": "124",
    "30.1": "124",
    "30.2": "124",
    "30.3": "124",
    "30.4": "124",
    "30.5": "124",
    "31.0": "126",
    "31.1": "126",
    "31.2": "126",
    "31.3": "126",
    "31.4": "126",
    "31.5": "126",
    "31.6": "126",
    "31.7": "126",
    "32.0": "128",
    "32.1": "128",
    "32.2": "128",
    "32.3": "128",
    "33.0": "130",
    "33.1": "130",
    "33.2": "130",
    "33.3": "130",
    "33.4": "130",
    "34.0": "132",
    "34.1": "132",
    "34.2": "132",
    "34.3": "132",
    "34.4": "132",
    "34.5": "132",
    "35.0": "134",
    "35.1": "134",
    "35.2": "134",
    "35.3": "134",
    "35.4": "134",
    "35.5": "134",
    "35.6": "134",
    "35.7": "134",
    "36.0": "136",
    "36.1": "136",
    "36.2": "136",
    "36.3": "136",
    "36.4": "136",
    "36.5": "136",
    "36.6": "136",
    "36.7": "136",
    "37.0": "138",
    "37.1": "138",
    "37.2": "138",
    "38.0": "140"
};
}}),
"[project]/node_modules/normalize-range/index.js [postcss] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
module.exports = {
    wrap: wrapRange,
    limit: limitRange,
    validate: validateRange,
    test: testRange,
    curry: curry,
    name: name
};
function wrapRange(min, max, value) {
    var maxLessMin = max - min;
    return ((value - min) % maxLessMin + maxLessMin) % maxLessMin + min;
}
function limitRange(min, max, value) {
    return Math.max(min, Math.min(max, value));
}
function validateRange(min, max, value, minExclusive, maxExclusive) {
    if (!testRange(min, max, value, minExclusive, maxExclusive)) {
        throw new Error(value + ' is outside of range [' + min + ',' + max + ')');
    }
    return value;
}
function testRange(min, max, value, minExclusive, maxExclusive) {
    return !(value < min || value > max || maxExclusive && value === max || minExclusive && value === min);
}
function name(min, max, minExcl, maxExcl) {
    return (minExcl ? '(' : '[') + min + ',' + max + (maxExcl ? ')' : ']');
}
function curry(min, max, minExclusive, maxExclusive) {
    var boundNameFn = name.bind(null, min, max, minExclusive, maxExclusive);
    return {
        wrap: wrapRange.bind(null, min, max),
        limit: limitRange.bind(null, min, max),
        validate: function(value) {
            return validateRange(min, max, value, minExclusive, maxExclusive);
        },
        test: function(value) {
            return testRange(min, max, value, minExclusive, maxExclusive);
        },
        toString: boundNameFn,
        name: boundNameFn
    };
}
}}),
"[project]/node_modules/postcss-value-parser/lib/unit.js [postcss] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
var minus = "-".charCodeAt(0);
var plus = "+".charCodeAt(0);
var dot = ".".charCodeAt(0);
var exp = "e".charCodeAt(0);
var EXP = "E".charCodeAt(0);
// Check if three code points would start a number
// https://www.w3.org/TR/css-syntax-3/#starts-with-a-number
function likeNumber(value) {
    var code = value.charCodeAt(0);
    var nextCode;
    if (code === plus || code === minus) {
        nextCode = value.charCodeAt(1);
        if (nextCode >= 48 && nextCode <= 57) {
            return true;
        }
        var nextNextCode = value.charCodeAt(2);
        if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
            return true;
        }
        return false;
    }
    if (code === dot) {
        nextCode = value.charCodeAt(1);
        if (nextCode >= 48 && nextCode <= 57) {
            return true;
        }
        return false;
    }
    if (code >= 48 && code <= 57) {
        return true;
    }
    return false;
}
// Consume a number
// https://www.w3.org/TR/css-syntax-3/#consume-number
module.exports = function(value) {
    var pos = 0;
    var length = value.length;
    var code;
    var nextCode;
    var nextNextCode;
    if (length === 0 || !likeNumber(value)) {
        return false;
    }
    code = value.charCodeAt(pos);
    if (code === plus || code === minus) {
        pos++;
    }
    while(pos < length){
        code = value.charCodeAt(pos);
        if (code < 48 || code > 57) {
            break;
        }
        pos += 1;
    }
    code = value.charCodeAt(pos);
    nextCode = value.charCodeAt(pos + 1);
    if (code === dot && nextCode >= 48 && nextCode <= 57) {
        pos += 2;
        while(pos < length){
            code = value.charCodeAt(pos);
            if (code < 48 || code > 57) {
                break;
            }
            pos += 1;
        }
    }
    code = value.charCodeAt(pos);
    nextCode = value.charCodeAt(pos + 1);
    nextNextCode = value.charCodeAt(pos + 2);
    if ((code === exp || code === EXP) && (nextCode >= 48 && nextCode <= 57 || (nextCode === plus || nextCode === minus) && nextNextCode >= 48 && nextNextCode <= 57)) {
        pos += nextCode === plus || nextCode === minus ? 3 : 2;
        while(pos < length){
            code = value.charCodeAt(pos);
            if (code < 48 || code > 57) {
                break;
            }
            pos += 1;
        }
    }
    return {
        number: value.slice(0, pos),
        unit: value.slice(pos)
    };
};
}}),
"[project]/node_modules/postcss-value-parser/lib/parse.js [postcss] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
var openParentheses = "(".charCodeAt(0);
var closeParentheses = ")".charCodeAt(0);
var singleQuote = "'".charCodeAt(0);
var doubleQuote = '"'.charCodeAt(0);
var backslash = "\\".charCodeAt(0);
var slash = "/".charCodeAt(0);
var comma = ",".charCodeAt(0);
var colon = ":".charCodeAt(0);
var star = "*".charCodeAt(0);
var uLower = "u".charCodeAt(0);
var uUpper = "U".charCodeAt(0);
var plus = "+".charCodeAt(0);
var isUnicodeRange = /^[a-f0-9?-]+$/i;
module.exports = function(input) {
    var tokens = [];
    var value = input;
    var next, quote, prev, token, escape, escapePos, whitespacePos, parenthesesOpenPos;
    var pos = 0;
    var code = value.charCodeAt(pos);
    var max = value.length;
    var stack = [
        {
            nodes: tokens
        }
    ];
    var balanced = 0;
    var parent;
    var name = "";
    var before = "";
    var after = "";
    while(pos < max){
        // Whitespaces
        if (code <= 32) {
            next = pos;
            do {
                next += 1;
                code = value.charCodeAt(next);
            }while (code <= 32)
            token = value.slice(pos, next);
            prev = tokens[tokens.length - 1];
            if (code === closeParentheses && balanced) {
                after = token;
            } else if (prev && prev.type === "div") {
                prev.after = token;
                prev.sourceEndIndex += token.length;
            } else if (code === comma || code === colon || code === slash && value.charCodeAt(next + 1) !== star && (!parent || parent && parent.type === "function" && parent.value !== "calc")) {
                before = token;
            } else {
                tokens.push({
                    type: "space",
                    sourceIndex: pos,
                    sourceEndIndex: next,
                    value: token
                });
            }
            pos = next;
        // Quotes
        } else if (code === singleQuote || code === doubleQuote) {
            next = pos;
            quote = code === singleQuote ? "'" : '"';
            token = {
                type: "string",
                sourceIndex: pos,
                quote: quote
            };
            do {
                escape = false;
                next = value.indexOf(quote, next + 1);
                if (~next) {
                    escapePos = next;
                    while(value.charCodeAt(escapePos - 1) === backslash){
                        escapePos -= 1;
                        escape = !escape;
                    }
                } else {
                    value += quote;
                    next = value.length - 1;
                    token.unclosed = true;
                }
            }while (escape)
            token.value = value.slice(pos + 1, next);
            token.sourceEndIndex = token.unclosed ? next : next + 1;
            tokens.push(token);
            pos = next + 1;
            code = value.charCodeAt(pos);
        // Comments
        } else if (code === slash && value.charCodeAt(pos + 1) === star) {
            next = value.indexOf("*/", pos);
            token = {
                type: "comment",
                sourceIndex: pos,
                sourceEndIndex: next + 2
            };
            if (next === -1) {
                token.unclosed = true;
                next = value.length;
                token.sourceEndIndex = next;
            }
            token.value = value.slice(pos + 2, next);
            tokens.push(token);
            pos = next + 2;
            code = value.charCodeAt(pos);
        // Operation within calc
        } else if ((code === slash || code === star) && parent && parent.type === "function" && parent.value === "calc") {
            token = value[pos];
            tokens.push({
                type: "word",
                sourceIndex: pos - before.length,
                sourceEndIndex: pos + token.length,
                value: token
            });
            pos += 1;
            code = value.charCodeAt(pos);
        // Dividers
        } else if (code === slash || code === comma || code === colon) {
            token = value[pos];
            tokens.push({
                type: "div",
                sourceIndex: pos - before.length,
                sourceEndIndex: pos + token.length,
                value: token,
                before: before,
                after: ""
            });
            before = "";
            pos += 1;
            code = value.charCodeAt(pos);
        // Open parentheses
        } else if (openParentheses === code) {
            // Whitespaces after open parentheses
            next = pos;
            do {
                next += 1;
                code = value.charCodeAt(next);
            }while (code <= 32)
            parenthesesOpenPos = pos;
            token = {
                type: "function",
                sourceIndex: pos - name.length,
                value: name,
                before: value.slice(parenthesesOpenPos + 1, next)
            };
            pos = next;
            if (name === "url" && code !== singleQuote && code !== doubleQuote) {
                next -= 1;
                do {
                    escape = false;
                    next = value.indexOf(")", next + 1);
                    if (~next) {
                        escapePos = next;
                        while(value.charCodeAt(escapePos - 1) === backslash){
                            escapePos -= 1;
                            escape = !escape;
                        }
                    } else {
                        value += ")";
                        next = value.length - 1;
                        token.unclosed = true;
                    }
                }while (escape)
                // Whitespaces before closed
                whitespacePos = next;
                do {
                    whitespacePos -= 1;
                    code = value.charCodeAt(whitespacePos);
                }while (code <= 32)
                if (parenthesesOpenPos < whitespacePos) {
                    if (pos !== whitespacePos + 1) {
                        token.nodes = [
                            {
                                type: "word",
                                sourceIndex: pos,
                                sourceEndIndex: whitespacePos + 1,
                                value: value.slice(pos, whitespacePos + 1)
                            }
                        ];
                    } else {
                        token.nodes = [];
                    }
                    if (token.unclosed && whitespacePos + 1 !== next) {
                        token.after = "";
                        token.nodes.push({
                            type: "space",
                            sourceIndex: whitespacePos + 1,
                            sourceEndIndex: next,
                            value: value.slice(whitespacePos + 1, next)
                        });
                    } else {
                        token.after = value.slice(whitespacePos + 1, next);
                        token.sourceEndIndex = next;
                    }
                } else {
                    token.after = "";
                    token.nodes = [];
                }
                pos = next + 1;
                token.sourceEndIndex = token.unclosed ? next : pos;
                code = value.charCodeAt(pos);
                tokens.push(token);
            } else {
                balanced += 1;
                token.after = "";
                token.sourceEndIndex = pos + 1;
                tokens.push(token);
                stack.push(token);
                tokens = token.nodes = [];
                parent = token;
            }
            name = "";
        // Close parentheses
        } else if (closeParentheses === code && balanced) {
            pos += 1;
            code = value.charCodeAt(pos);
            parent.after = after;
            parent.sourceEndIndex += after.length;
            after = "";
            balanced -= 1;
            stack[stack.length - 1].sourceEndIndex = pos;
            stack.pop();
            parent = stack[balanced];
            tokens = parent.nodes;
        // Words
        } else {
            next = pos;
            do {
                if (code === backslash) {
                    next += 1;
                }
                next += 1;
                code = value.charCodeAt(next);
            }while (next < max && !(code <= 32 || code === singleQuote || code === doubleQuote || code === comma || code === colon || code === slash || code === openParentheses || code === star && parent && parent.type === "function" && parent.value === "calc" || code === slash && parent.type === "function" && parent.value === "calc" || code === closeParentheses && balanced))
            token = value.slice(pos, next);
            if (openParentheses === code) {
                name = token;
            } else if ((uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) && plus === token.charCodeAt(1) && isUnicodeRange.test(token.slice(2))) {
                tokens.push({
                    type: "unicode-range",
                    sourceIndex: pos,
                    sourceEndIndex: next,
                    value: token
                });
            } else {
                tokens.push({
                    type: "word",
                    sourceIndex: pos,
                    sourceEndIndex: next,
                    value: token
                });
            }
            pos = next;
        }
    }
    for(pos = stack.length - 1; pos; pos -= 1){
        stack[pos].unclosed = true;
        stack[pos].sourceEndIndex = value.length;
    }
    return stack[0].nodes;
};
}}),
"[project]/node_modules/postcss-value-parser/lib/walk.js [postcss] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
module.exports = function walk(nodes, cb, bubble) {
    var i, max, node, result;
    for(i = 0, max = nodes.length; i < max; i += 1){
        node = nodes[i];
        if (!bubble) {
            result = cb(node, i, nodes);
        }
        if (result !== false && node.type === "function" && Array.isArray(node.nodes)) {
            walk(node.nodes, cb, bubble);
        }
        if (bubble) {
            cb(node, i, nodes);
        }
    }
};
}}),
"[project]/node_modules/postcss-value-parser/lib/stringify.js [postcss] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
function stringifyNode(node, custom) {
    var type = node.type;
    var value = node.value;
    var buf;
    var customResult;
    if (custom && (customResult = custom(node)) !== undefined) {
        return customResult;
    } else if (type === "word" || type === "space") {
        return value;
    } else if (type === "string") {
        buf = node.quote || "";
        return buf + value + (node.unclosed ? "" : buf);
    } else if (type === "comment") {
        return "/*" + value + (node.unclosed ? "" : "*/");
    } else if (type === "div") {
        return (node.before || "") + value + (node.after || "");
    } else if (Array.isArray(node.nodes)) {
        buf = stringify(node.nodes, custom);
        if (type !== "function") {
            return buf;
        }
        return value + "(" + (node.before || "") + buf + (node.after || "") + (node.unclosed ? "" : ")");
    }
    return value;
}
function stringify(nodes, custom) {
    var result, i;
    if (Array.isArray(nodes)) {
        result = "";
        for(i = nodes.length - 1; ~i; i -= 1){
            result = stringifyNode(nodes[i], custom) + result;
        }
        return result;
    }
    return stringifyNode(nodes, custom);
}
module.exports = stringify;
}}),
"[project]/node_modules/postcss-value-parser/lib/index.js [postcss] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
var parse = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/parse.js [postcss] (ecmascript)");
var walk = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/walk.js [postcss] (ecmascript)");
var stringify = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/stringify.js [postcss] (ecmascript)");
function ValueParser(value) {
    if (this instanceof ValueParser) {
        this.nodes = parse(value);
        return this;
    }
    return new ValueParser(value);
}
ValueParser.prototype.toString = function() {
    return Array.isArray(this.nodes) ? stringify(this.nodes) : "";
};
ValueParser.prototype.walk = function(cb, bubble) {
    walk(this.nodes, cb, bubble);
    return this;
};
ValueParser.unit = __turbopack_context__.r("[project]/node_modules/postcss-value-parser/lib/unit.js [postcss] (ecmascript)");
ValueParser.walk = walk;
ValueParser.stringify = stringify;
module.exports = ValueParser;
}}),
"[project]/node_modules/fraction.js/fraction.cjs [postcss] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * @license Fraction.js v4.3.7 31/08/2023
 * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
 *
 * Copyright (c) 2023, Robert Eisele (robert@raw.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/ /**
 *
 * This class offers the possibility to calculate fractions.
 * You can pass a fraction in different formats. Either as array, as double, as string or as an integer.
 *
 * Array/Object form
 * [ 0 => <numerator>, 1 => <denominator> ]
 * [ n => <numerator>, d => <denominator> ]
 *
 * Integer form
 * - Single integer value
 *
 * Double form
 * - Single double value
 *
 * String form
 * 123.456 - a simple double
 * 123/456 - a string fraction
 * 123.'456' - a double with repeating decimal places
 * 123.(456) - synonym
 * 123.45'6' - a double with repeating last place
 * 123.45(6) - synonym
 *
 * Example:
 *
 * var f = new Fraction("9.4'31'");
 * f.mul([-4, 3]).div(4.9);
 *
 */ (function(root) {
    "use strict";
    // Maximum search depth for cyclic rational numbers. 2000 should be more than enough.
    // Example: 1/7 = 0.(142857) has 6 repeating decimal places.
    // If MAX_CYCLE_LEN gets reduced, long cycles will not be detected and toString() only gets the first 10 digits
    var MAX_CYCLE_LEN = 2000;
    // Parsed data to avoid calling "new" all the time
    var P = {
        "s": 1,
        "n": 0,
        "d": 1
    };
    function assign(n, s) {
        if (isNaN(n = parseInt(n, 10))) {
            throw InvalidParameter();
        }
        return n * s;
    }
    // Creates a new Fraction internally without the need of the bulky constructor
    function newFraction(n, d) {
        if (d === 0) {
            throw DivisionByZero();
        }
        var f = Object.create(Fraction.prototype);
        f["s"] = n < 0 ? -1 : 1;
        n = n < 0 ? -n : n;
        var a = gcd(n, d);
        f["n"] = n / a;
        f["d"] = d / a;
        return f;
    }
    function factorize(num) {
        var factors = {};
        var n = num;
        var i = 2;
        var s = 4;
        while(s <= n){
            while(n % i === 0){
                n /= i;
                factors[i] = (factors[i] || 0) + 1;
            }
            s += 1 + 2 * i++;
        }
        if (n !== num) {
            if (n > 1) factors[n] = (factors[n] || 0) + 1;
        } else {
            factors[num] = (factors[num] || 0) + 1;
        }
        return factors;
    }
    var parse = function(p1, p2) {
        var n = 0, d = 1, s = 1;
        var v = 0, w = 0, x = 0, y = 1, z = 1;
        var A = 0, B = 1;
        var C = 1, D = 1;
        var N = 10000000;
        var M;
        if (p1 === undefined || p1 === null) {
        /* void */ } else if (p2 !== undefined) {
            n = p1;
            d = p2;
            s = n * d;
            if (n % 1 !== 0 || d % 1 !== 0) {
                throw NonIntegerParameter();
            }
        } else switch(typeof p1){
            case "object":
                {
                    if ("d" in p1 && "n" in p1) {
                        n = p1["n"];
                        d = p1["d"];
                        if ("s" in p1) n *= p1["s"];
                    } else if (0 in p1) {
                        n = p1[0];
                        if (1 in p1) d = p1[1];
                    } else {
                        throw InvalidParameter();
                    }
                    s = n * d;
                    break;
                }
            case "number":
                {
                    if (p1 < 0) {
                        s = p1;
                        p1 = -p1;
                    }
                    if (p1 % 1 === 0) {
                        n = p1;
                    } else if (p1 > 0) {
                        if (p1 >= 1) {
                            z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
                            p1 /= z;
                        }
                        // Using Farey Sequences
                        // http://www.johndcook.com/blog/2010/10/20/best-rational-approximation/
                        while(B <= N && D <= N){
                            M = (A + C) / (B + D);
                            if (p1 === M) {
                                if (B + D <= N) {
                                    n = A + C;
                                    d = B + D;
                                } else if (D > B) {
                                    n = C;
                                    d = D;
                                } else {
                                    n = A;
                                    d = B;
                                }
                                break;
                            } else {
                                if (p1 > M) {
                                    A += C;
                                    B += D;
                                } else {
                                    C += A;
                                    D += B;
                                }
                                if (B > N) {
                                    n = C;
                                    d = D;
                                } else {
                                    n = A;
                                    d = B;
                                }
                            }
                        }
                        n *= z;
                    } else if (isNaN(p1) || isNaN(p2)) {
                        d = n = NaN;
                    }
                    break;
                }
            case "string":
                {
                    B = p1.match(/\d+|./g);
                    if (B === null) throw InvalidParameter();
                    if (B[A] === '-') {
                        s = -1;
                        A++;
                    } else if (B[A] === '+') {
                        A++;
                    }
                    if (B.length === A + 1) {
                        w = assign(B[A++], s);
                    } else if (B[A + 1] === '.' || B[A] === '.') {
                        if (B[A] !== '.') {
                            v = assign(B[A++], s);
                        }
                        A++;
                        // Check for decimal places
                        if (A + 1 === B.length || B[A + 1] === '(' && B[A + 3] === ')' || B[A + 1] === "'" && B[A + 3] === "'") {
                            w = assign(B[A], s);
                            y = Math.pow(10, B[A].length);
                            A++;
                        }
                        // Check for repeating places
                        if (B[A] === '(' && B[A + 2] === ')' || B[A] === "'" && B[A + 2] === "'") {
                            x = assign(B[A + 1], s);
                            z = Math.pow(10, B[A + 1].length) - 1;
                            A += 3;
                        }
                    } else if (B[A + 1] === '/' || B[A + 1] === ':') {
                        w = assign(B[A], s);
                        y = assign(B[A + 2], 1);
                        A += 3;
                    } else if (B[A + 3] === '/' && B[A + 1] === ' ') {
                        v = assign(B[A], s);
                        w = assign(B[A + 2], s);
                        y = assign(B[A + 4], 1);
                        A += 5;
                    }
                    if (B.length <= A) {
                        d = y * z;
                        s = /* void */ n = x + d * v + z * w;
                        break;
                    }
                /* Fall through on error */ }
            default:
                throw InvalidParameter();
        }
        if (d === 0) {
            throw DivisionByZero();
        }
        P["s"] = s < 0 ? -1 : 1;
        P["n"] = Math.abs(n);
        P["d"] = Math.abs(d);
    };
    function modpow(b, e, m) {
        var r = 1;
        for(; e > 0; b = b * b % m, e >>= 1){
            if (e & 1) {
                r = r * b % m;
            }
        }
        return r;
    }
    function cycleLen(n, d) {
        for(; d % 2 === 0; d /= 2){}
        for(; d % 5 === 0; d /= 5){}
        if (d === 1) return 0;
        // If we would like to compute really large numbers quicker, we could make use of Fermat's little theorem:
        // 10^(d-1) % d == 1
        // However, we don't need such large numbers and MAX_CYCLE_LEN should be the capstone,
        // as we want to translate the numbers to strings.
        var rem = 10 % d;
        var t = 1;
        for(; rem !== 1; t++){
            rem = rem * 10 % d;
            if (t > MAX_CYCLE_LEN) return 0; // Returning 0 here means that we don't print it as a cyclic number. It's likely that the answer is `d-1`
        }
        return t;
    }
    function cycleStart(n, d, len) {
        var rem1 = 1;
        var rem2 = modpow(10, len, d);
        for(var t = 0; t < 300; t++){
            // Solve 10^s == 10^(s+t) (mod d)
            if (rem1 === rem2) return t;
            rem1 = rem1 * 10 % d;
            rem2 = rem2 * 10 % d;
        }
        return 0;
    }
    function gcd(a, b) {
        if (!a) return b;
        if (!b) return a;
        while(1){
            a %= b;
            if (!a) return b;
            b %= a;
            if (!b) return a;
        }
    }
    ;
    /**
   * Module constructor
   *
   * @constructor
   * @param {number|Fraction=} a
   * @param {number=} b
   */ function Fraction(a, b) {
        parse(a, b);
        if (this instanceof Fraction) {
            a = gcd(P["d"], P["n"]); // Abuse variable a
            this["s"] = P["s"];
            this["n"] = P["n"] / a;
            this["d"] = P["d"] / a;
        } else {
            return newFraction(P['s'] * P['n'], P['d']);
        }
    }
    var DivisionByZero = function() {
        return new Error("Division by Zero");
    };
    var InvalidParameter = function() {
        return new Error("Invalid argument");
    };
    var NonIntegerParameter = function() {
        return new Error("Parameters must be integer");
    };
    Fraction.prototype = {
        "s": 1,
        "n": 0,
        "d": 1,
        /**
     * Calculates the absolute value
     *
     * Ex: new Fraction(-4).abs() => 4
     **/ "abs": function() {
            return newFraction(this["n"], this["d"]);
        },
        /**
     * Inverts the sign of the current fraction
     *
     * Ex: new Fraction(-4).neg() => 4
     **/ "neg": function() {
            return newFraction(-this["s"] * this["n"], this["d"]);
        },
        /**
     * Adds two rational numbers
     *
     * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
     **/ "add": function(a, b) {
            parse(a, b);
            return newFraction(this["s"] * this["n"] * P["d"] + P["s"] * this["d"] * P["n"], this["d"] * P["d"]);
        },
        /**
     * Subtracts two rational numbers
     *
     * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
     **/ "sub": function(a, b) {
            parse(a, b);
            return newFraction(this["s"] * this["n"] * P["d"] - P["s"] * this["d"] * P["n"], this["d"] * P["d"]);
        },
        /**
     * Multiplies two rational numbers
     *
     * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
     **/ "mul": function(a, b) {
            parse(a, b);
            return newFraction(this["s"] * P["s"] * this["n"] * P["n"], this["d"] * P["d"]);
        },
        /**
     * Divides two rational numbers
     *
     * Ex: new Fraction("-17.(345)").inverse().div(3)
     **/ "div": function(a, b) {
            parse(a, b);
            return newFraction(this["s"] * P["s"] * this["n"] * P["d"], this["d"] * P["n"]);
        },
        /**
     * Clones the actual object
     *
     * Ex: new Fraction("-17.(345)").clone()
     **/ "clone": function() {
            return newFraction(this['s'] * this['n'], this['d']);
        },
        /**
     * Calculates the modulo of two rational numbers - a more precise fmod
     *
     * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
     **/ "mod": function(a, b) {
            if (isNaN(this['n']) || isNaN(this['d'])) {
                return new Fraction(NaN);
            }
            if (a === undefined) {
                return newFraction(this["s"] * this["n"] % this["d"], 1);
            }
            parse(a, b);
            if (0 === P["n"] && 0 === this["d"]) {
                throw DivisionByZero();
            }
            /*
       * First silly attempt, kinda slow
       *
       return that["sub"]({
       "n": num["n"] * Math.floor((this.n / this.d) / (num.n / num.d)),
       "d": num["d"],
       "s": this["s"]
       });*/ /*
       * New attempt: a1 / b1 = a2 / b2 * q + r
       * => b2 * a1 = a2 * b1 * q + b1 * b2 * r
       * => (b2 * a1 % a2 * b1) / (b1 * b2)
       */ return newFraction(this["s"] * (P["d"] * this["n"]) % (P["n"] * this["d"]), P["d"] * this["d"]);
        },
        /**
     * Calculates the fractional gcd of two rational numbers
     *
     * Ex: new Fraction(5,8).gcd(3,7) => 1/56
     */ "gcd": function(a, b) {
            parse(a, b);
            // gcd(a / b, c / d) = gcd(a, c) / lcm(b, d)
            return newFraction(gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]), P["d"] * this["d"]);
        },
        /**
     * Calculates the fractional lcm of two rational numbers
     *
     * Ex: new Fraction(5,8).lcm(3,7) => 15
     */ "lcm": function(a, b) {
            parse(a, b);
            // lcm(a / b, c / d) = lcm(a, c) / gcd(b, d)
            if (P["n"] === 0 && this["n"] === 0) {
                return newFraction(0, 1);
            }
            return newFraction(P["n"] * this["n"], gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]));
        },
        /**
     * Calculates the ceil of a rational number
     *
     * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
     **/ "ceil": function(places) {
            places = Math.pow(10, places || 0);
            if (isNaN(this["n"]) || isNaN(this["d"])) {
                return new Fraction(NaN);
            }
            return newFraction(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
        },
        /**
     * Calculates the floor of a rational number
     *
     * Ex: new Fraction('4.(3)').floor() => (4 / 1)
     **/ "floor": function(places) {
            places = Math.pow(10, places || 0);
            if (isNaN(this["n"]) || isNaN(this["d"])) {
                return new Fraction(NaN);
            }
            return newFraction(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
        },
        /**
     * Rounds a rational numbers
     *
     * Ex: new Fraction('4.(3)').round() => (4 / 1)
     **/ "round": function(places) {
            places = Math.pow(10, places || 0);
            if (isNaN(this["n"]) || isNaN(this["d"])) {
                return new Fraction(NaN);
            }
            return newFraction(Math.round(places * this["s"] * this["n"] / this["d"]), places);
        },
        /**
     * Rounds a rational number to a multiple of another rational number
     *
     * Ex: new Fraction('0.9').roundTo("1/8") => 7 / 8
     **/ "roundTo": function(a, b) {
            /*
      k * x/y ≤ a/b < (k+1) * x/y
      ⇔ k ≤ a/b / (x/y) < (k+1)
      ⇔ k = floor(a/b * y/x)
      */ parse(a, b);
            return newFraction(this['s'] * Math.round(this['n'] * P['d'] / (this['d'] * P['n'])) * P['n'], P['d']);
        },
        /**
     * Gets the inverse of the fraction, means numerator and denominator are exchanged
     *
     * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
     **/ "inverse": function() {
            return newFraction(this["s"] * this["d"], this["n"]);
        },
        /**
     * Calculates the fraction to some rational exponent, if possible
     *
     * Ex: new Fraction(-1,2).pow(-3) => -8
     */ "pow": function(a, b) {
            parse(a, b);
            // Trivial case when exp is an integer
            if (P['d'] === 1) {
                if (P['s'] < 0) {
                    return newFraction(Math.pow(this['s'] * this["d"], P['n']), Math.pow(this["n"], P['n']));
                } else {
                    return newFraction(Math.pow(this['s'] * this["n"], P['n']), Math.pow(this["d"], P['n']));
                }
            }
            // Negative roots become complex
            //     (-a/b)^(c/d) = x
            // <=> (-1)^(c/d) * (a/b)^(c/d) = x
            // <=> (cos(pi) + i*sin(pi))^(c/d) * (a/b)^(c/d) = x         # rotate 1 by 180°
            // <=> (cos(c*pi/d) + i*sin(c*pi/d)) * (a/b)^(c/d) = x       # DeMoivre's formula in Q ( https://proofwiki.org/wiki/De_Moivre%27s_Formula/Rational_Index )
            // From which follows that only for c=0 the root is non-complex. c/d is a reduced fraction, so that sin(c/dpi)=0 occurs for d=1, which is handled by our trivial case.
            if (this['s'] < 0) return null;
            // Now prime factor n and d
            var N = factorize(this['n']);
            var D = factorize(this['d']);
            // Exponentiate and take root for n and d individually
            var n = 1;
            var d = 1;
            for(var k in N){
                if (k === '1') continue;
                if (k === '0') {
                    n = 0;
                    break;
                }
                N[k] *= P['n'];
                if (N[k] % P['d'] === 0) {
                    N[k] /= P['d'];
                } else return null;
                n *= Math.pow(k, N[k]);
            }
            for(var k in D){
                if (k === '1') continue;
                D[k] *= P['n'];
                if (D[k] % P['d'] === 0) {
                    D[k] /= P['d'];
                } else return null;
                d *= Math.pow(k, D[k]);
            }
            if (P['s'] < 0) {
                return newFraction(d, n);
            }
            return newFraction(n, d);
        },
        /**
     * Check if two rational numbers are the same
     *
     * Ex: new Fraction(19.6).equals([98, 5]);
     **/ "equals": function(a, b) {
            parse(a, b);
            return this["s"] * this["n"] * P["d"] === P["s"] * P["n"] * this["d"]; // Same as compare() === 0
        },
        /**
     * Check if two rational numbers are the same
     *
     * Ex: new Fraction(19.6).equals([98, 5]);
     **/ "compare": function(a, b) {
            parse(a, b);
            var t = this["s"] * this["n"] * P["d"] - P["s"] * P["n"] * this["d"];
            return (0 < t) - (t < 0);
        },
        "simplify": function(eps) {
            if (isNaN(this['n']) || isNaN(this['d'])) {
                return this;
            }
            eps = eps || 0.001;
            var thisABS = this['abs']();
            var cont = thisABS['toContinued']();
            for(var i = 1; i < cont.length; i++){
                var s = newFraction(cont[i - 1], 1);
                for(var k = i - 2; k >= 0; k--){
                    s = s['inverse']()['add'](cont[k]);
                }
                if (Math.abs(s['sub'](thisABS).valueOf()) < eps) {
                    return s['mul'](this['s']);
                }
            }
            return this;
        },
        /**
     * Check if two rational numbers are divisible
     *
     * Ex: new Fraction(19.6).divisible(1.5);
     */ "divisible": function(a, b) {
            parse(a, b);
            return !(!(P["n"] * this["d"]) || this["n"] * P["d"] % (P["n"] * this["d"]));
        },
        /**
     * Returns a decimal representation of the fraction
     *
     * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
     **/ 'valueOf': function() {
            return this["s"] * this["n"] / this["d"];
        },
        /**
     * Returns a string-fraction representation of a Fraction object
     *
     * Ex: new Fraction("1.'3'").toFraction(true) => "4 1/3"
     **/ 'toFraction': function(excludeWhole) {
            var whole, str = "";
            var n = this["n"];
            var d = this["d"];
            if (this["s"] < 0) {
                str += '-';
            }
            if (d === 1) {
                str += n;
            } else {
                if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
                    str += whole;
                    str += " ";
                    n %= d;
                }
                str += n;
                str += '/';
                str += d;
            }
            return str;
        },
        /**
     * Returns a latex representation of a Fraction object
     *
     * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
     **/ 'toLatex': function(excludeWhole) {
            var whole, str = "";
            var n = this["n"];
            var d = this["d"];
            if (this["s"] < 0) {
                str += '-';
            }
            if (d === 1) {
                str += n;
            } else {
                if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
                    str += whole;
                    n %= d;
                }
                str += "\\frac{";
                str += n;
                str += '}{';
                str += d;
                str += '}';
            }
            return str;
        },
        /**
     * Returns an array of continued fraction elements
     *
     * Ex: new Fraction("7/8").toContinued() => [0,1,7]
     */ 'toContinued': function() {
            var t;
            var a = this['n'];
            var b = this['d'];
            var res = [];
            if (isNaN(a) || isNaN(b)) {
                return res;
            }
            do {
                res.push(Math.floor(a / b));
                t = a % b;
                a = b;
                b = t;
            }while (a !== 1)
            return res;
        },
        /**
     * Creates a string representation of a fraction with all digits
     *
     * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
     **/ 'toString': function(dec) {
            var N = this["n"];
            var D = this["d"];
            if (isNaN(N) || isNaN(D)) {
                return "NaN";
            }
            dec = dec || 15; // 15 = decimal places when no repetation
            var cycLen = cycleLen(N, D); // Cycle length
            var cycOff = cycleStart(N, D, cycLen); // Cycle start
            var str = this['s'] < 0 ? "-" : "";
            str += N / D | 0;
            N %= D;
            N *= 10;
            if (N) str += ".";
            if (cycLen) {
                for(var i = cycOff; i--;){
                    str += N / D | 0;
                    N %= D;
                    N *= 10;
                }
                str += "(";
                for(var i = cycLen; i--;){
                    str += N / D | 0;
                    N %= D;
                    N *= 10;
                }
                str += ")";
            } else {
                for(var i = dec; N && i--;){
                    str += N / D | 0;
                    N %= D;
                    N *= 10;
                }
            }
            return str;
        }
    };
    if ("TURBOPACK compile-time truthy", 1) {
        Object.defineProperty(exports, "__esModule", {
            'value': true
        });
        exports['default'] = Fraction;
        module['exports'] = Fraction;
    } else //TURBOPACK unreachable
    ;
})(("TURBOPACK member replacement", __turbopack_context__.e));
}}),

};

//# sourceMappingURL=node_modules_09580c72._.js.map